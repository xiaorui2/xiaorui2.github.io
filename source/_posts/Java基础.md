---
title: Java基础
date: 2019-07-01 15:15:49
tags: 
categories: Java入门
---

# == 和 equals 的区别是什么？

直接使用`==`操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用`equals()`。

`== `对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 `equals` 默认情况下是引用比较，只是很多类重新了` equals `方法，比如` String`、`Integer` 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。

# String

`Java` 中`String `是一个不可变类，即创建一个`String`对象后，是不能直接改变字符串中的某个字符的。

## 为什么不可变？好处在哪？

因为用于存储String值的仍然是一个char型数组，并且注意到它是final修饰的，不可更改。

- 效率（因为对象不可变，所以可以使用常量池的方式优化效率；因为对象不可变，所以`String`对象可以自身缓存`HashCode`）
- 安全（`String`被许多的`Java`类(库)用来当做参数,例如 网络连接地址`URL`,文件路径`path`,还有反射机制所需要的`String`参数等, 假若`String`不是固定不变的,将会引起各种安全隐患）

## String 常量池

对于不可变对象使用`String `常量池，不然修改变量`string1`的值，`string2`的值也发生变化了。常量池的存在无疑大大降低了创建、拷贝等操作的时间复杂度和空间复杂度。

```java
String s1="ab"+“cd”;
String s2="abc"+"d";
System.out.println(s1==s2);
//True
String s3=new String("ab");
String s4=new String("ab");
System.out.println(s3==s4);
//Flase
```

由答案可以知道：`String`类确实是不可变类，`"ab"+"cd"`被当做了新字符串而不是续接`"ab"`（不然`"ab"`和`"abc"`肯定不会地址一样）；常量池确实存在，同是`"abcd"`，所有对`"abcd"`的引用都指向同一地址；如果使用`new `的话就会直接分配新的地址。

## String， Stringbuffer， StringBuilder 的区别。

- `String` 字符串常量(`final`修饰，不可被继承)，线程不安全，`String`是常量，当创建之后即不能更改。(可以通过`StringBuffer`和`StringBuilder`创建`String`对象(常用的两个字符串操作类)。) 
- `StringBuffer` 字符串变量（线程安全）其`toString`方法会进行对象缓存，以减少元素复制开销，支持同步锁。
- `StringBuilder` 字符串变量（非线程安全）其`toString`的时候，会直接返回一个新对象。

# int 和Integer

## 区别

- `int `是一个基本数据类型，而`Integer `是`int `的包装类。
- `Integer` 变量必须要实例化之后才能使用。
- `Integer`实际是对象的引用，当`new`一个`Integer`时，实际上是生成一个指针指向此对象；而`int`则是直接存储数据值 。
- `Integer`的默认值是`null`，`int`的默认值是0。

## 比较

- 两个`int` 的比较，就不用说了，就平常的数值比较即可。
- 两个`new` 生成的`Integer` 比较，由于`Integer`变量实际上是对一个`Integer`对象的引用，所以两个通过`new`生成的`Integer`变量永远是不相等的（因为`new`生成的是两个对象，其内存地址不同）。调用`equals`函数返回`true`。
- `Integer `变量和`int `变量比较时，只要两个变量的值是向等的，则结果为`true`（因为包装类`Integer`和基本数据类型`int`比较时，`java`会自动拆包装为`int`，然后进行比较，实际上就变为两个`int`变量的比较）
- 对于两个非`new`生成的`Integer`对象，进行比较时，如果两个变量的值在区间`-128`到`127`之间，则比较结果为`true`，如果两个变量的值不在此区间，则比较结果为`false`。调用`equals`函数返回`true`。
- 非`new`生成的`Integer`变量和`new Integer()`生成的变量比较时，结果为`false`。（因为非`new`生成的`Integer`变量指向的是`java`常量池中的对象，而`new Integer()`生成的变量指向堆中新建的对象，两者在内存中的地址不同）

## Integer常量池

`Integer i = value;`如果`i`是在`-128`到`127`之间，不会去堆中创建对象，而是直接返回`IntegerCache`中的值;如果值不在上面范围内则会从堆中创建对象。`= `走的是`valueOf()`方法,`valueOf(int)`会走缓存。`Integer i2 = new Integer(xxxx);`不管参数的`value`是多少都会从堆中创建对象，与`IntegerCache`没关系。

常量池都是放在方法区的。

# Static关键字

`static`方法就是没有`this`的方法。在`static`方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用`static`方法。这实际上正是`static`方法的主要用途，只要类被加载了，就可以通过类名去进行访问。

`static`方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有`this`的，因为它不依附于任何对象，既然都没有对象，就谈不上`this`了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。

`static`变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。

`static`关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。`static`块可以置于类中的任何地方，类中可以有多个`static`块。在类初次被加载的时候，会按照`static`块的顺序来执行每个`static`块，并且只会执行一次。

# Final关键字

- 修饰类当用`final`去修饰一个类的时候，表示这个类不能被继承。注意：

  a. 被`final`修饰的类，`final`类中的成员变量可以根据自己的实际需要设计为`fianl`。

  b. `final`类中的成员方法都会被隐式的指定为`final`方法。

- 被`final`修饰的方法不能被重写：

  a. 一个类的`private`方法会隐式的被指定为`final`方法。

  b. 如果父类中有`final`修饰的方法，那么子类不能去重写。

- 修饰成员变量，必须要赋初始值，而且是只能初始化一次。

# 类初始化顺序

- 非继承关系中的初始化顺序：`static`静态代码块和静态成员 -> 普通成员 -> 构造函数执行
- 继承的子类：父类静态代码块和静态成员 -> 子类静态代码块和静态成员 ->父类普通成员和非`static`块 -> 父类构造函数 -> 子类普通成员和非`static`块 -> 子类构造函数 。

# 基本数据类型

![](1.png)

注意：`String` 不属于基础类型，它属于对象。

# Java的容器和容器之间的区别

`Java `容器分为 `Collection `和 `Map` 两大类

![](2.png)

## ArrayList 和 LinkedList 区别

`ArrayList`和`LinkedList`都是实现了`List`接口的容器类，用于存储一系列的对象引用。他们都可以对元素的增删改查进行操作。

`ArrayList`是实现了基于动态数组的数据结构，`LinkedList`是基于链表结构。

`ArrayList`可以以`O(1)`时间复杂度对元素进行随机访，`LinkedList `则是`O(n)`的复杂度。

新增和删除操作`add`和`remove`，`LinkedList` 时间复杂度为`O(1)`，而`ArrayList` 为`O(n)`，因为要移动数据。对`ArrayList`和`LinkedList`而言，在列表末尾增加一个元素所花的开销都是固定的都是`O(1)`。`LinkedList`比`ArrayList`更占内存，因为`LinkedList`为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。

## ArrayList 和 Vector 的区别

- 线程安全：`Vector` 使用了` Synchronized `来实现线程同步，是线程安全的，而` ArrayList `是非线程安全的。
- 性能：`ArrayList `在性能方面要优于 `Vector`。
- 扩容：`ArrayList` 和` Vector `都会根据实际的需要动态的调整容量，只不过在` Vector` 扩容每次会增加 1 倍，而` ArrayList` 只会增加 50%。

## 实现数组和 List 之间的转换

- 数组转 `List`：使用 `Arrays. asList(array)` 进行转换。
- `List` 转数组：使用 `List `自带的 `toArray() `方法。

# 反射

`Java`反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。注意：使用反射机制可以打破封装性，导致了`java`对象的属性不安全。 

反射的好处：可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等。

有三种得到`class` 方式：通过 `Class` 对象的` forName() `静态方法来获取；直接通过 类名`.class `的方式得到,该方法最为安全可靠；通过对象调用 `getClass()` 方法来获取。注意：一个类在`JVM` 中只会有一个`class` 实例，所以三种方法得到的`class` 的地址到最后都是相等的。

# 内存泄漏和内存溢出

## 内存溢出

简单地说内存溢出就是指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。

### 常见的内存溢出

创建的对象太多，在进行垃圾回收之前对象数量达到了最大堆的容量限制造成堆溢出；常量池溢出；虚拟机栈和本地方法栈溢出

## 内存泄漏

内存泄漏指程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。

### 常见的内存泄露

静态集合类（如`HashMap`，`Vector`）引起的内存泄漏；修改`HashSet`中对象的参数值，且参数是计算哈希值的字段；监听器；各种连接（如数据库连接）。

### 避免内存泄漏的几点建议：

- 尽早释放无用对象的引用。
- 避免在循环中创建对象。
- 使用字符串处理时避免使用`String`，应使用`StringBuffer`。
- 尽量少使用静态变量，因为静态变量存放在永久代，基本不参与垃圾回收。

# Java语言的特点和特性

## Java语言的主要特点

### 跨平台性

所谓的跨平台性，是指软件可以不受计算机硬件和操作系统的约束而在任意计算机环境下正常运行。这是软件发展的趋势和编程人员追求的目标。之所以这样说，是因为计算机硬件的种类繁多，操作系统也各不相同，不同的用户和公司有自己不同的计算机环境偏好，而软件为了能在这些不同的环境里正常运行，就需要独立于这些平台。而在`Java`语言中，` Java`自带的虚拟机很好地实现了跨平台性。` Java`源程序代码经过编译后生成二进制的字节码是与平台无关的，但是可被`Java`虚拟机识别的一种机器码指令。 `Java`虚拟机提供了一个字节码到底层硬件平台及操作系统的屏障，使得`Java`语言具备跨平台性。

### 面向对象

面向对象是指以对象为基本粒度，其下包含属性和方法。对象的说明用属性表达，而通过使用方法来操作这个对象。面向对象技术使得应用程序的开发变得简单易用，节省代码。`Java`是一种面向对象的语言，也继承了面向对象的诸多好处，如代码扩展、代码复用等。

### 安全性

安全性可以分为四个层面，即语言级安全性、编译时安全性、运行时安全性、可执行代码安全性。语言级安全性指`Java`的数据结构是完整的对象，这些封装过的数据类型具有安全性。编译时要进行`Java`语言和语义的检查，保证每个变量对应一个相应的值，编译后生成`Java`类。运行时`Java`类需要类加载器载入`www jxzxmr net`，并经由字节码校验器校验之后才可以运行。 `Java`类在网络上使用时，对它的权限进行了设置，保证了被访问用户的安全性。

### 多线程

多线程在操作系统中已得到了最成功的应用。多线程是指允许一个应用程序同时存在两个或两个以上的线程，用于支持事务并发和多任务处理。 Java除了内置的多线程技术之外，还定义了一些类、方法等来建立和管理用户定义的多线程。

### 简单易用

`Java`源代码的书写不拘泥于特定的环境，可以用记事本、文本编辑器等编辑软件来实现，然后将源文件进行编译，编译通过后可直接运行，通过调试则可得到想要的结果。

## Java语言的几大特性

### 封装

封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。封装是一种信息隐藏技术，在`java`中通过关键字`private`，`protected`和`public`实现封装。什么是封装？封装把对象的所有组成部分组合在一起，封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。 适当的封装可以让程式码更容易理解和维护，也加强了程式码的安全性。

### 继承

继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 `Java`继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。这种技术使得复用以前的代码非常容易，能够大大缩短开发周期，降低开发费用

### 多态

按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作 多态的话，我觉得是更好的利用了继承这一特性，然后为什么能实现多态，因为可以重写父类的方法。说重写可能不清楚，具体来说就是子类父类可以存在分别存在名字相同的属性或者方法，然后可视声明的类去调用相应的方法等。

### 抽象 
抽象是通过分析与综合的途径，运用概念在人脑中再现对象的质和本质的方法，我觉得理解成一种方法比较好。就是我们通过对事物的认知，将某一或者一类事物的属性变化成`JAVA`语言能识别的类。

# Throwable、error、exception的区别

异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用空的引用、数组下标越界、内存溢出错误等。`Throwable` 类是` Java `语言中所有错误或异常的超类。有两个重要的子类：`Exception`（异常）和 `Error`（错误），二者都是 `Java` 异常处理的重要子类，各自都包含大量子类。4

异常和错误的本质区别：异常能被程序本身处理，而错误无法处理。`Error`是可以`catch`的，而且也可以向常规`Exception`一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉`Error`之后也可以做些其他处理。但是`Error`是一种系统内部的错误，这种错误不像`Exception`一样是可能是程序和业务上的错误是可以恢复的。

怎么`catch`？`catch throwable`会把`Error`和其他继承`Throwable`的类捕捉到。而`catch Exception`只会捕捉`Exception`及其子类，捕捉的范围更小。

`Error`：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 `JVM`出现的问题。 

# Java和c++有哪些区别

- `Java`为解释性语言，运行过程为由编译器将`Java`代码转换为字节码，然后由虚拟机解释执行。`C/C++`为编译型语言，源代码经过编译和链接生成可执行的二进制代码。因此，`Java`的执行速度比`C/C++`慢，但是`Java`能跨平台，`C/C++`不行。
- `Java`为纯面向对象语言，所有代码必须在类中实现，`C/C++`兼具面向对象和面向过程的特点，可以定义全局变量和函数。
- 与`C/C++`语言相比，`Java`语言中没有指针的概念，这有效防止了`C/C++`语言中操作指针可能引起的系统问题，从而使程序变得安全。

- `Java`没有多重继承，但是`Java`语言引入了接口的概念，可以同时实现多个接口，达到`C++`中多重继承的目的。
- 在`C++`中，需要开发人员管理对内存的分配（包括申请与释放），而`Java`语言提供了垃圾回收器来实现垃圾的自动回收。

- `Java`具有平台无关性，`C++`没有。
- 还有一些语言特性。包括运算符重载，预处理，默认函数参数，`goto`语句，自动强制转换等语言本身特性不同。

# Java反射

`Java`反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。注意：使用反射机制可以打破封装性，导致了`java`对象的属性不安全。 

## 好处

可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等。

## 实现方式

- 通过 `Class `对象的` forName() `静态方法来获取；
- 直接通过 类名`.class `的方式得到,该方法最为安全可靠；
- 通过对象调用 `getClass()` 方法来获取。

注意：一个类在`JVM` 中只会有一个`class` 实例，所以三种方法得到的`class `的地址到最后都是相等的。

## 常用API

`getName()`：获得类的完整名字；`getDeclaredFields()`：获得类的所有属性。包括`private`声明的和继承类；`getMethods()`：获得类的`public`类型的方法；

