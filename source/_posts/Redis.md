---
title: Redis
date: 2019-06-27 21:53:09
tags: Redis
categories: SpringBoot项目
---

# Redis是什么，用在哪

`Redis` 是一个使用 C 语言写成的，开源的`key-value` 数据库，和`Memcached`类似，它支持存储的`value`类型相对更多，包括`string`(字符串)、`list`(链表)、`set`(集合)、`zset`(`sorted set` --有序集合)和`hash`（哈希类型）。与`memcached`一样，为了保证效率，数据都是缓存在内存中。区别的是`redis`会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了`master-slave`(主从)同步。

`Redis` 使用场景：

- 记录帖子点赞数、点击数、评论数；
- 缓存近期热帖；
- 缓存文章详情信息；
- 记录用户会话信息。

# Redis功能

- 数据缓存功能
- 分布式锁的功能
- 支持数据持久化
- 支持事务
- 支持消息队列

# Redis和memcache有什么区别

- 存储方式不同：`memcache` 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；`Redis` 有部份存在硬盘上，这样能保证数据的持久性。
- 数据支持类型：`memcache` 对数据类型支持相对简单；`Redis` 有复杂的数据类型。
- 使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，`Redis` 自己构建了 `vm` 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
- value 值大小不同：`Redis` 最大可以达到 `512mb`；`memcache` 只有 `1mb`。

# Redis 支持的数据类型有哪些？用在什么场景？

## String

`String`数据结构是简单的`key-value`类型，`value`其实不仅可以是`String`，也可以是数字。 常规`key-value`缓存应用； 常规计数：微博数，粉丝数等。

## Hash

`Hash`是一个`string`类型的`field`和`value`的映射表，`hash`特别适合用于存储对象。 比如我们可以`Hash`数据结构来存储用户信息，商品信息等等。

## List

`list`就是链表，`Redis list`的应用场景非常多，也是`Redis`最重要的数据结构之一，比如微博的关注列表，粉丝列表，最新消息排行等功能都可以用`Redis`的`list`结构来实现。

## Set

当你需要存储一个列表数据，又不希望出现重复数据时，`set`是一个很好的选择。在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。`Redis`可以非常方便的实现如共同关注、共同喜好、二度好友等功能。

## Sorted Set

和`set`相比，`sorted set`增加了一个权重参数`score`，使得集合中的元素能够按`score`进行有序排列。在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用`Redis`中的`SortedSet`结构进行存储。

# MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）

相关知识：`redis` 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。`redis` 提供 6种数据淘汰策略：

- `volatile-lru`：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
- `volatile-ttl`：从已设置过期时间的数据集中挑选将要过期的数据淘汰
- `volatile-random`：从已设置过期时间的数据集中任意选择数据淘汰
- `allkeys-lru`：从数据集中挑选最近最少使用的数据淘汰
- `allkeys-random`：从数据集中任意选择数据淘汰
- `no-enviction`：禁止驱逐数据

`Redis`采用的内存回收算法：引用计数法或者`LRU`算法。

# Redis的并发竞争问题如何解决?

`Redis`为单进程单线程模式，，采用队列模式将并发访问变为串行访问。`Redis`本身没有锁的概念，`Redis`对于多个客户端连接并不存在竞争，但是在`Jedis`客户端对`Redis`进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：

- 客户端角度，为保证每个客户端间正常有序与`Redis`进行通信，对连接进行池化，同时对客户端读写`Redis`操作采用内部锁`synchronized`。
- 服务器角度，利用`setnx`实现锁。

# Redis缓存穿透，缓存雪崩，缓存击穿

`Redis`缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。除此之外一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。

## 缓存穿透

缓存穿透，是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果`key`不存在或者`key`已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。

## 缓存雪崩

在某一个时间段，缓存集中过期失效。特别是电商中。

## 缓存击穿

缓存击穿，是指一个`key`非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个`key`在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

# 怎么保证缓存和数据库数据的一致性

- 合理设置缓存的过期时间。
- 新增、更改、删除数据库操作时同步更新 `Redis`，可以使用事务机制来保证数据的一致性。

# 缓存技术

# Redis持久化方式

`Redis`有两种持久化的方式：快照（`RDB`文件）和追加式文件（`AOF`文件）

- `RDB`持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。
- `AOF`持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟`Redis`协议一致，以追加的方式进行保存。
- `Redis`的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。
- 两种方式的持久化是可以同时存在的，但是当`Redis`重启时，`AOF`文件会被优先用于重建数据。

## RDB

工作原理：

- `Redis`调用`fork()`，产生一个子进程。
- 子进程把数据写到一个临时的`RDB`文件。
- 当子进程写完新的`RDB`文件后，把旧的`RDB`文件替换掉。

优点：

- `RDB`文件是一个很简洁的单文件，它保存了某个时间点的`Redis`数据，很适合用于做备份。你可以设定一个时间点对`RDB`文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本。
- 基于上面所描述的特性，`RDB`很适合用于灾备。单文件很方便就能传输到远程的服务器上。
- `RDB`的性能很好，需要进行持久化时，主进程会`fork`一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的`I/O`操作。
- 比起`AOF`，在数据量比较大的情况下，`RDB`的启动速度更快。

缺点：

- `RDB`容易造成数据的丢失。假设每`5`分钟保存一次快照，如果`Redis`因为某些原因不能正常工作，那么从上次产生快照到`Redis`出现问题这段时间的数据就会丢失了。
- `RDB`使用`fork()`产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成`Redis`停止服务几毫秒。如果数据量很大且`CPU`性能不是很好的时候，停止服务的时间甚至会到`1`秒。

## AOF

快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。而`AOF`文件则提供了一种更为可靠的持久化方式。每当`Redis`接受到会修改数据集的命令时，就会把命令追加到`AOF`文件里，当你重启`Redis`时，`AOF`里的命令会被重新执行一次，重建数据。

优点：

- 比`RDB`可靠。
- 当`AOF`文件太大时，`Redis`会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时`Redis`会继续往旧的文件追加数据。
- `AOF`把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。

缺点

- 在相同的数据集下，`AOF`文件的大小一般会比`RDB`文件大。
- 在某些`fsync`策略下，`AOF`的速度会比`RDB`慢。通常`fsync`设置为每秒一次就能获得比较高的性能，而在禁止`fsync`的情况下速度可以达到`RDB`的水平。
- 在过去曾经发现一些很罕见的`BUG`导致使用`AOF`重建的数据跟原数据不一致的问题。

# Redis集群，持久化方式事务

