---
title: Redis
date: 2019-06-27 21:53:09
tags: Redis
categories: SpringBoot项目
---

# Redis是什么，用在哪

`Redis` 是一个使用 C 语言写成的，开源的`key-value` 数据库，和`Memcached`类似，它支持存储的`value`类型相对更多，包括`string`(字符串)、`list`(链表)、`set`(集合)、`zset`(`sorted set` --有序集合)和`hash`（哈希类型）。与`memcached`一样，为了保证效率，数据都是缓存在内存中。区别的是`redis`会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了`master-slave`(主从)同步。

`Redis` 使用场景：

- 记录帖子点赞数、点击数、评论数；
- 缓存近期热帖；
- 缓存文章详情信息；
- 记录用户会话信息。

个人感觉`Redis`有2个作用，一个是缓存的作用，就是`db`中的热点数据缓存在其中。第二是对于那些数据结构简单，性能要求高、一致性要求低的数据，直接存入`Redis`，它也会持久化的。

`Redis`的缺点
是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此`Redis`适合的场景主要局限在较小数据量的高性能操作和运算上。`Redis`不具备自动容错和恢复功能z

# Redis是单线程的为什么速度那么快

- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于`HashMap`，`HashMap`的优势就是查找和操作的时间复杂度都是`O(1)`；

- 数据结构简单，对数据操作也简单，`Redis`中的数据结构是专门进行设计的；

- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗` CPU`，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

- 使用多路`I/O`复用模型，非阻塞`IO`；

- 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，`Redis`直接自己构建了`VM `机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

那么为什么`Redis`是单线程？

因为`Redis`是基于内存的操作，`CPU`不是`Redis`的瓶颈，`Redis`的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且`CPU`不会成为瓶颈，那就顺理成章地采用单线程的方案了。多线程的话还需要考虑切换线程的损失，线程安全这些问题。

# Redis功能

- 数据缓存功能
- 分布式锁的功能
- 支持数据持久化
- 支持事务
- 支持消息队列

# Redis和memcache有什么区别

- 存储方式不同：`memcache` 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；`Redis` 有部份存在硬盘上，这样能保证数据的持久性。
- 数据支持类型：`memcache` 对数据类型支持相对简单；`Redis` 有复杂的数据类型。
- 使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，`Redis` 自己构建了 `vm` 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
- value 值大小不同：`Redis` 最大可以达到 `512mb`；`memcache` 只有 `1mb`。

# Redis和MySql的区别

- 类型上：从类型上来说，`mysql`是关系型数据库，`redis`是缓存数据库
- 作用上：`mysql`用于持久化的存储数据到硬盘，功能强大，但是每次请求访问数据库时，都存在着`I/O`操作，如果反复频繁的访问数据库会在反复链接数据库上花费大量时间，从而导致运行效率过慢并且也会导致数据库的负载过高，那么此时缓存的概念就衍生了出来；`redis`用于存储使用较为频繁的数据到缓存中，读取速度快
- 需求上：`mysql`和`redis`因为需求的不同，一般都是配合使用

# Redis 支持的数据类型有哪些？用在什么场景？

## String

`String`数据结构是简单的`key-value`类型，`value`其实不仅可以是`String`，也可以是数字。 常规`key-value`缓存应用； 常规计数：微博数，粉丝数等。

## Hash

`Hash`是一个`string`类型的`field`和`value`的映射表，`hash`特别适合用于存储对象。 比如我们可以`Hash`数据结构来存储用户信息，商品信息等等。

## List

`list`就是链表，`Redis list`的应用场景非常多，也是`Redis`最重要的数据结构之一，比如微博的关注列表，粉丝列表，最新消息排行等功能都可以用`Redis`的`list`结构来实现。

## Set

当你需要存储一个列表数据，又不希望出现重复数据时，`set`是一个很好的选择。在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。`Redis`可以非常方便的实现如共同关注、共同喜好、二度好友等功能。

## Sorted Set

和`set`相比，`sorted set`增加了一个权重参数`score`，使得集合中的元素能够按`score`进行有序排列。在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用`Redis`中的`SortedSet`结构进行存储。

# MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）

相关知识：`redis` 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。`redis` 提供 6种数据淘汰策略：

- `volatile-lru`：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
- `volatile-ttl`：从已设置过期时间的数据集中挑选将要过期的数据淘汰
- `volatile-random`：从已设置过期时间的数据集中任意选择数据淘汰
- `allkeys-lru`：从数据集中挑选最近最少使用的数据淘汰
- `allkeys-random`：从数据集中任意选择数据淘汰
- `no-enviction`：禁止驱逐数据

`Redis`采用的内存回收算法：引用计数法或者`LRU`算法。

# Redis的并发竞争问题如何解决?

`Redis`为单进程单线程模式，采用队列模式将并发访问变为串行访问。`Redis`本身没有锁的概念，`Redis`对于多个客户端连接并不存在竞争，但是在`Jedis`客户端对`Redis`进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：

- 客户端角度，为保证每个客户端间正常有序与`Redis`进行通信，对连接进行池化，同时对客户端读写`Redis`操作采用内部锁`synchronized`。
- 服务器角度，利用`setnx`实现锁。

# Redis缓存穿透，缓存雪崩，缓存击穿

`Redis`缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。除此之外一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。

## 缓存穿透

缓存穿透，是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果`key`不存在或者`key`已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。

### 解决方案

有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟

## 缓存雪崩

在某一个时间段，缓存集中过期失效。特别是电商中。

### 解决方案
缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

## 缓存击穿

缓存击穿，是指一个`key`非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个`key`在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

### 解决方案

使用互斥锁`(mutex key)`，简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去`load db`，而是先使用缓存工具的某些带成功操作返回值的操作（比如`Redis`的`SETNX`或者`Memcache`的`ADD`）去`set`一个`mutex key`，当操作返回成功时，再进行`load db`的操作并回设缓存；否则，就重试整个`get`缓存的方法。

# 怎么保证缓存和数据库数据的一致性

- 合理设置缓存的过期时间。
- 新增、更改、删除数据库操作时同步更新 `Redis`，可以使用事务机制来保证数据的一致性。

# 缓存技术

# Redis持久化方式

`Redis`有两种持久化的方式：快照（`RDB`文件）和追加式文件（`AOF`文件）

- `RDB`持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。
- `AOF`持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟`Redis`协议一致，以追加的方式进行保存。
- `Redis`的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。
- 两种方式的持久化是可以同时存在的，但是当`Redis`重启时，`AOF`文件会被优先用于重建数据。

## RDB

工作原理：

- `Redis`调用`fork()`，产生一个子进程。
- 子进程把数据写到一个临时的`RDB`文件。
- 当子进程写完新的`RDB`文件后，把旧的`RDB`文件替换掉。

优点：

- `RDB`文件是一个很简洁的单文件，它保存了某个时间点的`Redis`数据，很适合用于做备份。你可以设定一个时间点对`RDB`文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本。
- 基于上面所描述的特性，`RDB`很适合用于灾备。单文件很方便就能传输到远程的服务器上。
- `RDB`的性能很好，需要进行持久化时，主进程会`fork`一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的`I/O`操作。
- 比起`AOF`，在数据量比较大的情况下，`RDB`的启动速度更快。

缺点：

- `RDB`容易造成数据的丢失。假设每`5`分钟保存一次快照，如果`Redis`因为某些原因不能正常工作，那么从上次产生快照到`Redis`出现问题这段时间的数据就会丢失了。
- `RDB`使用`fork()`产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成`Redis`停止服务几毫秒。如果数据量很大且`CPU`性能不是很好的时候，停止服务的时间甚至会到`1`秒。

## AOF

快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。而`AOF`文件则提供了一种更为可靠的持久化方式。每当`Redis`接受到会修改数据集的命令时，就会把命令追加到`AOF`文件里，当你重启`Redis`时，`AOF`里的命令会被重新执行一次，重建数据。

优点：

- 比`RDB`可靠。
- 当`AOF`文件太大时，`Redis`会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时`Redis`会继续往旧的文件追加数据。
- `AOF`把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。

缺点

- 在相同的数据集下，`AOF`文件的大小一般会比`RDB`文件大。
- 在某些`fsync`策略下，`AOF`的速度会比`RDB`慢。通常`fsync`设置为每秒一次就能获得比较高的性能，而在禁止`fsync`的情况下速度可以达到`RDB`的水平。
- 在过去曾经发现一些很罕见的`BUG`导致使用`AOF`重建的数据跟原数据不一致的问题。

# Redis集群，持久化方式事务

