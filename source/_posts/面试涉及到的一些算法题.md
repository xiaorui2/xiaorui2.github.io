---
title: 面试涉及到的一些算法题
date: 2019-07-27 14:48:07
tags: Algorithm
categories: 算法题训练
---

# 有多个集合，有交集的就合并，输出合并后的结果。

思路很简单，就是对于多个集合进行排序，`x`相同`y`小的放前面，否则`x`小的放前面。

然后一遍遍历，我维护当前集合的最右边的值`tempy`，如果`tempy`大于下一个集合的初始点的值说明这两个集合有交集，更新`tempy`的值，否则更新`tempy`值为下一个集合的最右边的值。

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
using namespace std;
const int maxn = 10005;
struct Node {
    int x, y;
};
Node node[maxn];
vector<Node>v;
bool cmp(Node a, Node b) {
    if (a.x == b.x) {
        return a.y < b.y;
    }
    else {
        return a.x < b.x;
    }
}
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d %d", &node[i].x, &node[i].y);
    }
    sort(node, node + n, cmp);
    for (int i = 0; i < n; i++) {
        printf("%d %d\n", node[i].x, node[i].y);
    }
    int tempx = node[0].x;
    int tempy = node[0].y;
    for (int i = 1; i < n; i++) {
        if (tempy > node[i].x) {
            tempy = node[i].y;
            continue;
        }
        else {
            Node temp;
            temp.x = tempx;
            temp.y = tempy;
            v.push_back(temp);
            tempx = node[i].x;
            tempy = node[i].y;
        }
    }
    Node temp;
    temp.x = tempx;
    temp.y = tempy;
    v.push_back(temp);
    int len = v.size();
    for (int i = 0; i < len; i++) {
        printf("%d %d\n", v[i].x, v[i].y);
    }
}
```

# 给一个词典的集合，一组不重复字母，问这些字母可以组成几个词语

先`Hash`一下字母，然后遍历和这个词典的集合，对于每个词语去`Hash`里面查一下，都有就能组成。

时间复杂度是O(集合的词语的长度之和)

# 从10万个数中找10个最大的数

- 最普通的想法是先对这`10`万个数进行排序，然后再选取数组中前`10`个数，即为最后的答案，排序算法的时间复杂度不下于`O(N lgN)`。最好的方法是建立一个最小堆。 
- 我们首先取`10`万个元素中的前`10`个元素来建立由`10`个元素组成的最小堆。这样堆顶元素便是当前已知元素的第`10`大的数；然后依次读取剩下的`99990`个元素，若读取的元素比堆顶元素大，则将堆顶元素和当前元素替换，并自堆顶至下调整堆；这样读取完所有元素后，堆中的`10`个元素即为这`10`万个数最大的`10`个数，同时堆顶元素为这`10`万个元素第`10`大元素。 
  时间复杂度： 
  设从`N`个数中找`M`个最大数 
  每次重新恢复堆的时间复杂都为`O(logM)`,最多进行了`（N-M）`次恢复堆操作，故时间复杂度为`O(NlogM)`。
- 维持一个长度为`10`的降序数组，每一个从数组拿到的数字都与这个降序数组的最小值比较。如果小于最小值，就舍弃；如果大于最小值，就把它插入到降序数组中的合适位置，舍弃原来的最小值。这样，遍历一遍就可以找到最大的`10`个数。

# 归并排序判断逆序对的个数



# 判断回文字符串



# 二叉树的遍历

## 先序遍历

根节点—>左子树—>右字树

### 递归遍历

```c++
void PreOrder(Tnode*  root)
{
    if(root==NULL)
        return ;
    cout<<root->val<<endl;
    Preorder(root->lchild);
    Preorder(root->rchild);
}
```

### 非递归遍历

先序遍历时，每当我们压入一个结点，我们压入结点前对其进行访问

```c++
void PreOrder(Tnode *root)
{
    if(root==NULL)
        return ;
    stack<Tnode *>s;
    Tnode *now=root;
    while(!s.empty() || now)
    {
        while(now)
        {
            cout<<now->val<<"->";
            s.push(now);
            now=now->lchild;
        }
        now=s.top();
        s.pop();
        now=now->rchild;　　
    }
    cout<<endl;
}
```

## 中序遍历

左子树—>根节点—>右字树

### 递归遍历

```c++
void InOrder(Tnode*  root)
{
    if(root==NULL)
        return ;
    Preorder(root->lchild);
    cout<<root->val<<endl;
    Preorder(root->rchild);
}
```

### 非递归遍历

中序时我们需要在遍历完左子树后访问根节点，再去遍历右子树

```c++
void InOrder(Tnode *root)
{
    if(root==NULL)
        return ;
    stack<Tnode *>s;
    Tnode *now=root;
    while(!s.empty() || now)
    {
        while(now)
        {
            s.push(now);
            now=now->lchild;
        }
        now=s.top();
        cout<<now->val<<"->";
        s.pop();
        now=now->rchild;　　
    }
    cout<<endl;
}
```

## 后序遍历

左子树—>右字树—>根节点

### 递归遍历

```c++
void PostOrder(Tnode*  root)
{
    if(root==NULL)
        return ;
    Preorder(root->lchild);
    Preorder(root->rchild);
    cout<<root->val<<endl;
}
```

### 非递归遍历

后序遍历时由于访问完左右子树后才能访问根结点，因此需要将根结点在栈内保留到左右子树被访问后，但同时会出现一个问题，当右子树弹出后遇到根结点又会将右子树结点压入栈中，造成死循环，因此我们需要在定义一个变量`last`代表最后一个访问的结点，当`last`与栈顶结点的右子树结点相同时，则不再将右子树结点压入栈中。

```c++
void PostOrder(Tnode *root)
{
    if(root==NULL)
        return ;
    stack<Tnode *>s;
    Tnode *now=root;
    Tnode *last=NULL;
    while(!s.empty() || now)
    {
        while(now)
        {
            s.push(now);
            now=now->lchild;
        }
        now=s.top();
        if(now->rchild && last!=now->rchild)
            now=now->rchild;
        else if(now->rchild ==NULL || last ==now->rchild)
        {
            cout<<<now->val<<"->";
            last=now;
            s.pop();
            now=NULL;
        }
    }
}
```

## 给定中序和前序求层序或者后序

不管是求层序还是后序，主要过程都是一样的都是建树。

首先我们在上面介绍了前序，中序，后序遍历的特性。所以我们基本的思路就是先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。给个例子介绍一下：

前序遍历：`GDAFEMHZ`

中序遍历：`ADEFGHMZ`

画树求法：

- 根据前序遍历的特点，我们知道根结点为`G`
- 观察中序遍历`ADEFGHMZ`。其中`root`节点`G`左侧的`ADEF`必然是`root`的左子树，`G`右侧的`HMZ`必然是`root`的右子树。
- 观察左子树`ADEF`，左子树的中的根节点必然是大树的`root`的`leftchild`。在前序遍历中，大树的`root`的`leftchild`位于`root`之后，所以左子树的根节点为`D`。
- 同样的道理，`root`的右子树节点`HMZ`中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把`root`和`root`的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <stack>
#include <vector>
using namespace std;
typedef long long LL;
const int INF=0x3f3f3f3f;
const int maxn=50;
int n,m,s,d;
int a[maxn],b[maxn];
struct Node
{
    int l,r;
}node[maxn];
int buildtree(int la,int ra,int lb,int rb)
{
    if(la>ra)
        return 0;
    int root=b[lb];
    int len1,len2;
    len1=la;
    while(a[len1]!=root)
        len1++;
    len2=len1-la;
    node[root].l=buildtree(la,len1-1,lb+1,lb+len2);
    node[root].r=buildtree(len1+1,ra,lb+len2+1,rb);
    return root;
}
void bfs(int root)
{
    queue<int>q;
    vector<int>v;
    q.push(root);
    while(!q.empty())
    {
        int w=q.front();
        q.pop();
        if(w==0)
            break;
        v.push_back(w);
        if(node[w].l!=0)
            q.push(node[w].l);
        if(node[w].r!=0)
            q.push(node[w].r);
    }
    int len=v.size();
    for(int i=0;i<len;i++)
        printf("%d%c",v[i],i==len-1?'\n':' ');
    return;
}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
    for(int i=0;i<n;i++)
        scanf("%d",&b[i]);
    buildtree(0,n-1,0,n-1);
    int root=b[0];
    bfs(root);
    return 0;
}
```

## 给定二叉树，给出S型打印

```c++
void S_LevelOrderPrint(TreeNode t)
{
    stack<TreeNode> s1;
    stack<TreeNode> s2;
    s1.push(t);
    while(!s1.empty() || !s2.empty())
    {
        if(!s1.empty())
        {
            while(!s1.empty())
            {
                TreeNode tn = s1.top();
                cout<<tn.val<<"";
                s1.pop();
                if(tn.right != null)
                    s2.push(tn.right);
                if(tn.left != null)
                    s2.push(tn.left);
            }
        }
        else
        {
            while(!s2.empty())
            {
                TreeNode tn = s2.top();
                cout<<tn.val<<" ";
                s2.pop();
                if(tn.left != null)
                    s1.push(tn.left);
                if(tn.right != null)
                    s1.push(tn.right);
            }
        }
    }
}
```

# 数组中唯一出现过一次的数

利用异或的特性：`x ^ y ^ x = y ^ x ^ x = y`。

```c++
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int len=15;
int a[7]={2,4,3,3,2,5,5};
int main()
{
    int ans=a[0];
    for(int i=1;i<7;i++)
    {
        ans^=a[i];
    }
    printf("%d\n",ans);
    return 0;
}
```

# 一个数组里除了一个数字之外，其他数字出现了n次

我们把这个数分解成二进制，计算出每一位出现`1`的个数，我们知道如果多次出现的话，`1`的个数是能够整除这个`n`，如果发现这个`n `不能够被 整除的时候，我们就知道那个唯一的数字转换为二进制的时候在这一位上会分解到，我们把这个再转换为十进制的数即可。

```c++
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int len=15;
int a[7]={2,3,3,3,4,4,4};
int b[32];
int main()
{
    for(int i=0;i<=6;i++)
    {
        for(int j=0;j<32;j++)
        {
            b[j]+=((a[i]>>j)&1);
        }
    }
    int ans=0;
    for(int i=0;i<32;i++)
    {
        if(b[i]%3!=0)
        {
            ans+=(1<<i);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

