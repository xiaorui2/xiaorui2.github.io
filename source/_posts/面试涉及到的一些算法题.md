---
title: 面试涉及到的一些算法题
date: 2019-07-27 14:48:07
tags: Algorithm
categories: 算法题训练
---

# 有多个集合，有交集的就合并，输出合并后的结果。

思路很简单，就是对于多个集合进行排序，`x`相同`y`小的放前面，否则`x`小的放前面。

然后一遍遍历，我维护当前集合的最右边的值`tempy`，如果`tempy`大于下一个集合的初始点的值说明这两个集合有交集，更新`tempy`的值，否则更新`tempy`值为下一个集合的最右边的值。

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
using namespace std;
const int maxn = 10005;
struct Node {
    int x, y;
};
Node node[maxn];
vector<Node>v;
bool cmp(Node a, Node b) {
    if (a.x == b.x) {
        return a.y < b.y;
    }
    else {
        return a.x < b.x;
    }
}
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d %d", &node[i].x, &node[i].y);
    }
    sort(node, node + n, cmp);
    for (int i = 0; i < n; i++) {
        printf("%d %d\n", node[i].x, node[i].y);
    }
    int tempx = node[0].x;
    int tempy = node[0].y;
    for (int i = 1; i < n; i++) {
        if (tempy > node[i].x) {
            tempy = node[i].y;
            continue;
        }
        else {
            Node temp;
            temp.x = tempx;
            temp.y = tempy;
            v.push_back(temp);
            tempx = node[i].x;
            tempy = node[i].y;
        }
    }
    Node temp;
    temp.x = tempx;
    temp.y = tempy;
    v.push_back(temp);
    int len = v.size();
    for (int i = 0; i < len; i++) {
        printf("%d %d\n", v[i].x, v[i].y);
    }
}
```

# 给一个词典的集合，一组不重复字母，问这些字母可以组成几个词语

先`Hash`一下字母，然后遍历和这个词典的集合，对于每个词语去`Hash`里面查一下，都有就能组成。

时间复杂度是O(集合的词语的长度之和)

# 从10万个数中找10个最大的数

- 最普通的想法是先对这`10`万个数进行排序，然后再选取数组中前`10`个数，即为最后的答案，排序算法的时间复杂度不下于`O(N lgN)`。最好的方法是建立一个最小堆。 
- 我们首先取`10`万个元素中的前`10`个元素来建立由`10`个元素组成的最小堆。这样堆顶元素便是当前已知元素的第`10`大的数；然后依次读取剩下的`99990`个元素，若读取的元素比堆顶元素大，则将堆顶元素和当前元素替换，并自堆顶至下调整堆；这样读取完所有元素后，堆中的`10`个元素即为这`10`万个数最大的`10`个数，同时堆顶元素为这`10`万个元素第`10`大元素。 
  时间复杂度： 
  设从`N`个数中找`M`个最大数 
  每次重新恢复堆的时间复杂都为`O(logM)`,最多进行了`（N-M）`次恢复堆操作，故时间复杂度为`O(NlogM)`。
- 维持一个长度为`10`的降序数组，每一个从数组拿到的数字都与这个降序数组的最小值比较。如果小于最小值，就舍弃；如果大于最小值，就把它插入到降序数组中的合适位置，舍弃原来的最小值。这样，遍历一遍就可以找到最大的`10`个数。

# 判断回文字符串

将这串数字逆序，然后判断逆序后的数字是否和正序后的数字完全一样，如果完全一样，就是回文。

```c++
bool palindrome(char *s)
{
	int n=strlen(s);
	int i, j,count=0;
	for (i = 0, j = n - 1; i < n, j >= 0; i++, j--)
	{
		if (*(s + i) == *(s + j))
		{
			count++;
		}
	}
	if (count == n)
		return true;
}
```

# 最长回文序列

回文子序列，因为是不连续的肯定是不能直接枚举，那么利用动态规划

我们知道对于任意字符串，如果头尾字符相同，那么字符串的最长子序列等于去掉首尾的字符串的最长子序列加上首尾；如果首尾字符不同，则最长子序列等于去掉头的字符串的最长子序列和去掉尾的字符串的最长子序列的较大者。那么转移方程：

`dp[i][j]=dp[i+1][j-1] + 2  if（s[i] == s[j]）`

` dp[i][j]=max(dp[i+1][j],dp[i][j-1])  if （s[i] != s[j]）`

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const int maxn=1005;
char s[maxn];
int dp[maxn][maxn];
int main()
{
    scanf("%s",s);
    int len=strlen(s);
    for(int i=len-1;i>=0;i--)
    {
        dp[i][i]=1;
        for(int j=i+1;j<=len;j++)
        {
            if(s[i]==s[j])
                dp[i][j]=dp[i+1][j-1]+2;
            else
                dp[i][j]=max(dp[i][j-1],dp[i+1][j]);
        }
    }
    printf("%d\n",dp[0][len-1]);
    return 0;
}
```

# 最长回文子串

```c++
string longestPalindrome(string s)
{
    if (s.empty()) return "";
    int len = s.size();
    if (len == 1)return s;
    int longest = 1;
    int start=0;
    vector<vector<int> > dp(len,vector<int>(len));
    for (int i = 0; i < len; i++)
    {
        dp[i][i] = 1;
        if(i<len-1)
        {
            if (s[i] == s[i + 1])
            {
                dp[i][i + 1] = 1;
                start=i;
                longest=2;
            }
        }
    }
    for (int l = 3; l <= len; l++)//子串长度
    {
        for (int i = 0; i+l-1 < len; i++)//枚举子串的起始点
        {
            int j=l+i-1;//终点
            if (s[i] == s[j] && dp[i+1][j-1]==1)
            {
                dp[i][j] = 1;
                start=i;
                longest = l;
            }
        }
    }
    return s.substr(start,longest);
}
```

# 二叉树的遍历

## 先序遍历

根节点—>左子树—>右字树

### 递归遍历

```c++
void PreOrder(Tnode*  root)
{
    if(root==NULL)
        return ;
    cout<<root->val<<endl;
    Preorder(root->lchild);
    Preorder(root->rchild);
}
```

### 非递归遍历

先序遍历时，每当我们压入一个结点，我们压入结点前对其进行访问

```c++
void PreOrder(Tnode *root)
{
    if(root==NULL)
        return ;
    stack<Tnode *>s;
    Tnode *now=root;
    while(!s.empty() || now)
    {
        while(now)
        {
            cout<<now->val<<"->";
            s.push(now);
            now=now->lchild;
        }
        now=s.top();
        s.pop();
        now=now->rchild;　　
    }
    cout<<endl;
}
```

## 中序遍历

左子树—>根节点—>右字树

### 递归遍历

```c++
void InOrder(Tnode*  root)
{
    if(root==NULL)
        return ;
    Preorder(root->lchild);
    cout<<root->val<<endl;
    Preorder(root->rchild);
}
```

### 非递归遍历

中序时我们需要在遍历完左子树后访问根节点，再去遍历右子树

```c++
void InOrder(Tnode *root)
{
    if(root==NULL)
        return ;
    stack<Tnode *>s;
    Tnode *now=root;
    while(!s.empty() || now)
    {
        while(now)
        {
            s.push(now);
            now=now->lchild;
        }
        now=s.top();
        cout<<now->val<<"->";
        s.pop();
        now=now->rchild;　　
    }
    cout<<endl;
}
```

## 后序遍历

左子树—>右字树—>根节点

### 递归遍历

```c++
void PostOrder(Tnode*  root)
{
    if(root==NULL)
        return ;
    Preorder(root->lchild);
    Preorder(root->rchild);
    cout<<root->val<<endl;
}
```

### 非递归遍历

后序遍历时由于访问完左右子树后才能访问根结点，因此需要将根结点在栈内保留到左右子树被访问后，但同时会出现一个问题，当右子树弹出后遇到根结点又会将右子树结点压入栈中，造成死循环，因此我们需要在定义一个变量`last`代表最后一个访问的结点，当`last`与栈顶结点的右子树结点相同时，则不再将右子树结点压入栈中。

```c++
void PostOrder(Tnode *root)
{
    if(root==NULL)
        return ;
    stack<Tnode *>s;
    Tnode *now=root;
    Tnode *last=NULL;
    while(!s.empty() || now)
    {
        while(now)
        {
            s.push(now);
            now=now->lchild;
        }
        now=s.top();
        if(now->rchild && last!=now->rchild)
            now=now->rchild;
        else if(now->rchild ==NULL || last ==now->rchild)
        {
            cout<<<now->val<<"->";
            last=now;
            s.pop();
            now=NULL;
        }
    }
}
```

## 给定中序和前序求层序或者后序

不管是求层序还是后序，主要过程都是一样的都是建树。

首先我们在上面介绍了前序，中序，后序遍历的特性。所以我们基本的思路就是先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。给个例子介绍一下：

前序遍历：`GDAFEMHZ`

中序遍历：`ADEFGHMZ`

画树求法：

- 根据前序遍历的特点，我们知道根结点为`G`
- 观察中序遍历`ADEFGHMZ`。其中`root`节点`G`左侧的`ADEF`必然是`root`的左子树，`G`右侧的`HMZ`必然是`root`的右子树。
- 观察左子树`ADEF`，左子树的中的根节点必然是大树的`root`的`leftchild`。在前序遍历中，大树的`root`的`leftchild`位于`root`之后，所以左子树的根节点为`D`。
- 同样的道理，`root`的右子树节点`HMZ`中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把`root`和`root`的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <stack>
#include <vector>
using namespace std;
typedef long long LL;
const int INF=0x3f3f3f3f;
const int maxn=50;
int n,m,s,d;
int a[maxn],b[maxn];
struct Node
{
    int l,r;
}node[maxn];
int buildtree(int la,int ra,int lb,int rb)
{
    if(la>ra)
        return 0;
    int root=b[lb];
    int len1,len2;
    len1=la;
    while(a[len1]!=root)
        len1++;
    len2=len1-la;
    node[root].l=buildtree(la,len1-1,lb+1,lb+len2);
    node[root].r=buildtree(len1+1,ra,lb+len2+1,rb);
    return root;
}
void bfs(int root)
{
    queue<int>q;
    vector<int>v;
    q.push(root);
    while(!q.empty())
    {
        int w=q.front();
        q.pop();
        if(w==0)
            break;
        v.push_back(w);
        if(node[w].l!=0)
            q.push(node[w].l);
        if(node[w].r!=0)
            q.push(node[w].r);
    }
    int len=v.size();
    for(int i=0;i<len;i++)
        printf("%d%c",v[i],i==len-1?'\n':' ');
    return;
}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
    for(int i=0;i<n;i++)
        scanf("%d",&b[i]);
    buildtree(0,n-1,0,n-1);
    int root=b[0];
    bfs(root);
    return 0;
}
```

## 给定二叉树，给出S型打印

```c++
void S_LevelOrderPrint(TreeNode t)
{
    stack<TreeNode> s1;
    stack<TreeNode> s2;
    s1.push(t);
    while(!s1.empty() || !s2.empty())
    {
        if(!s1.empty())
        {
            while(!s1.empty())
            {
                TreeNode tn = s1.top();
                cout<<tn.val<<"";
                s1.pop();
                if(tn.right != null)
                    s2.push(tn.right);
                if(tn.left != null)
                    s2.push(tn.left);
            }
        }
        else
        {
            while(!s2.empty())
            {
                TreeNode tn = s2.top();
                cout<<tn.val<<" ";
                s2.pop();
                if(tn.left != null)
                    s1.push(tn.left);
                if(tn.right != null)
                    s1.push(tn.right);
            }
        }
    }
}
```

# 数组中唯一出现过一次的数

利用异或的特性：`x ^ y ^ x = y ^ x ^ x = y`。

```c++
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int len=15;
int a[7]={2,4,3,3,2,5,5};
int main()
{
    int ans=a[0];
    for(int i=1;i<7;i++)
    {
        ans^=a[i];
    }
    printf("%d\n",ans);
    return 0;
}
```

# 一个数组里除了一个数字之外，其他数字出现了n次

我们把这个数分解成二进制，计算出每一位出现`1`的个数，我们知道如果多次出现的话，`1`的个数是能够整除这个`n`，如果发现这个`n `不能够被 整除的时候，我们就知道那个唯一的数字转换为二进制的时候在这一位上会分解到，我们把这个再转换为十进制的数即可。

```c++
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int len=15;
int a[7]={2,3,3,3,4,4,4};
int b[32];
int main()
{
    for(int i=0;i<=6;i++)
    {
        for(int j=0;j<32;j++)
        {
            b[j]+=((a[i]>>j)&1);
        }
    }
    int ans=0;
    for(int i=0;i<32;i++)
    {
        if(b[i]%3!=0)
        {
            ans+=(1<<i);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

#  N 阶乘末尾0的个数。

要判断末尾有几个0就是判断可以整除几次10。10的因子有5和2，而在0~9之间5的倍数只有一个，2的倍数相对较多，所以本题也就转换成了求N阶乘中有几个5的倍数。
也就是每多出来一个5，阶乘末尾就会多出来一个0，这样n / 5就能统计完第一层5的个数，依次处理，就能统计出来所有5的个数。

```c++
#include<iostream>
using namespace std;
int main() {
    int n;
    cin>>n;
    int count = 0;
    while(n) {
        n /= 5;     //算出当前数字中可以匹配5（5和5的倍数）的个数
        count += n; //累加之
    }
    cout<<count;
    return 0;
}
```

# 给定数组，从数组中取出n个不复用的数的和为sum

深搜

```c++
void findd(vector<int>&vr,int pos,int sum,int m,int& res){
    if(sum==m){
        res++;
        return;
    }
    else if(sum>m){
        return;
    }else{
        if(pos<vr.size()){
            sum+=vr[pos];
            findd(vr,pos+1,sum,m,res);
            sum-=vr[pos];
            findd(vr,pos+1,sum,m,res);
        }
    }
}
```

DP

```c++
int main(){
    int n=0;
    int m=0;
    while(cin>>n>>m){
        vector<int> vr(n);
        for(int i=0;i<n;++i){
            cin>>vr[i];
        }
        sort(vr.begin(),vr.end(),greater<int>());
        vector<vector<long long int>>dp(n,vector<long long int>(m+1,0));
        for(int i=0;i<n;++i){
            dp[i][0]=1;
        }
        for(int i=1;i<=m;i++){
            if(vr[0]>m)//过滤
                break;
            if(vr[0]==i)
                dp[0][i]=1;
            else
                dp[0][i]=0;
        }
        for(int i=1;i<n;++i){
            if(vr[i]>m)  //过滤
                continue;
            for(int j=1;j<=m;++j){
                if(j-vr[i]>=0)
                    dp[i][j]=dp[i-1][j]+dp[i-1][j-vr[i]];
                else
                    dp[i][j]=dp[i-1][j];
            }
        }
        cout<<dp[n-1][m]<<endl;
    }
    return 0;
}
```

# 求一个无序数组的中位数

利用快排的思想。任意挑一个元素，以该元素为支点，划分集合为两部分，如果左侧集合长度恰为` (n-1)/2`，那么支点恰为中位数。如果左侧长度`<(n-1)/2`, 那么中位点在右侧，反之，中位数在左侧。 进入相应的一侧继续寻找中位点。

```c++
//快排方法，分治思想
int PartSort(int arr[], int left,int right)
{
    int key = arr[right];
    while (left < right)
    {
        //key右边，先从左找比key值大
        while (left < right && arr[left] <= key)
            ++left;
        if (left < right)
        {
            arr[right] = arr[left];
            --right;
        }
        //从右找比key小
        while (left < right && arr[right] >= key)
            --right;
        if (left < right)
        {
            arr[left] = arr[right];
            ++left;
        }           
    }
    arr[left] = key;
    return left;
}
void GetMid3(int arr[],int size)
{
    int left = 0;
    int right = size - 1;
    int mid = size / 2;
    int div = PartSort(arr, left, right);
    while (div != mid)
    {
        if (div < mid)//右半区间
            div = PartSort(arr, div + 1, right);
        else 
            div = PartSort(arr, left, div - 1);
    }
    cout << "中位数" << arr[div] << endl;
}
```

# 全排列

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
typedef long long LL;
const int maxn=1000005;
int n,m;
int a[maxn];
void perm(int s,int e)
{
    if(s==e)
    {
        for(int i=0;i<=e;i++)
            printf("%d ",a[i]);
        printf("\n");
    }
    else
    {
        for(int i=s;i<=e;i++)
        {
            swap(a[i],a[s]);
            perm(s+1,e);
            swap(a[i],a[s]);
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
    perm(0,n-1);
    return 0;
}
```

