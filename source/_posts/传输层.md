---
title: 运输层
date: 2019-05-23 17:41:11
tags: 
categories: 计算机网络
---

# 运输层概念

运输层是位于应用层和网络层之间，为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用，主要要理解的就是我们常用的UDP和TCP协议。通常我们知道的TCP它是一个可靠的传输连接，而UDP是一个不可靠的传输连接。

# 无连接运输：UDP

## UDP做的事

它是基于Internet IP协议，做了（传输层都要做的功能）复用 / 分用，简单的错误检测。它是无连接的，UDP发送方和接收方之间不需要握手，每个UDP段的处理独立于其他段，并且UDP段可能丢失，非按序到达。

## UDP为什么存在

因为无需要建立连接（减少延迟），实现简单，无需维护连接状态，头部开销少，没有拥塞控制，应用可以更好的控制发送时间和速率。用于DNS，SNMP等。

## 如何在UDP上实现可靠数据传输

在应用层增加可靠性机制，应用特定的错误恢复机制。（在应用层保证数据传输可靠）添加`seq/ack`机制，确保数据发送到对端，添加发送和接收缓冲区，主要是用户超时重传，添加超时重传机制

详细说明：发送端发送数据时，生成一个随机`seq=x`，然后每一片按照数据大小分配`seq`。数据到达接收端后接收端放入缓存，并发送一个`ack=x`的包，表示对方已经收到了数据。发送端收到了`ack`包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。

## UDP的数据格式和校验和

![](1.png)

![](2.png) ![](3.png)

# 可靠的数据传输原理

## 什么叫可靠？

数据不错，不丢，不乱。可靠数据传输对应用层，传输层，链路层都很重要。信道的不可靠性决定可靠数据传输协议（`rdt`）的复杂性。

## 可靠的数据传输协议

### 基本结构

是通过接口来实现的。调用一些 `rdt_send() `，`rdt_rcv()` ，`deliver_data()`这些函数接口。

### 可靠信道上的可靠数据传输和产生位错误的信道上的可靠数据传输

首先底层信道完全可靠（不会发生错误，不会丢弃分组），发送放和接收方的`FSM`（有限状态自动机）独立。

在会产生错误的信道传输会利用校验和来检测位错误，发送`ACK`（接收方显示的告知发送发分组已经正确的接收）或者`NAK`（错误的接收）当发现错误的时候会利用重传机制重传分组。

### 从可靠数据传输流水线可靠数据传输

`Rdt2.1`：如何解决重复分组问题：给每个分组增加序列号，接收方丢弃重复分组。应对`ACK/NAK`破坏或者被损坏的情况。

`Rdt2.2`：无`NAK`消息协议，与`Rdt2.1`功能相同，但是只使用`ACK`。如何实现？接收方通过`ACK`告知最后一个被正确接收的分组，在`ACK`消息中显示的加入被确认分组的序列号。发送发收到重复的`ACK`之后，采取和收到`NAK`的动作一样。

`Rdt3.0`：如果信道既可能发生错误也可能丢失分组，那么校验和+序列号+`ACK`+重传就不够用了（比方说`ACK`消息丢失了，发送方就一直在等待）解决方法也很简单：给发送方设置一个合理的时间，如果没有收到`ACK`就重传。但是这个合理的时间是很难确定的。那么就是需要设置定时器。`Rdt3.0`能够正常工作，但是性能很差。主要是由于停等协议导致的。

基于`Rdt3.0`，可以不使用停等协议，允许发送方发送多个分组而无需等待确认，只要最后能收获到`ACK`确认的技术就是流水线。可因此也需要增加一些内容：

允许发送发在收到ACK之前连续发送多个分组，需要更大的序列号范围；发送方和接收方需要更大存储空间以缓存分组；出现错误时候的处理：滑动窗口协议（主要是回退N步和选择重传）

## 滑动窗口协议

### 1比特滑动窗口协议（停等协议）

当发送窗口和接收窗口的大小固定为1时，滑动窗口协议退化为停等协议。该协议规定发送方每发送一帧后就要停下来，等待接收方已正确接收的确认（`ACK`）返回后才能继续发送下一帧。由于接收方需要判断接收到的帧是新发的帧还是重新发送的帧，因此发送方要为每一个帧加一个序号。由于停等协议规定只有一帧完全发送成功后才能发送新的帧，因而只用一比特来编号就够了，具有累计确认机制。

### 回退N帧协议

发送窗口大于1，接收窗口大于1， 由于停等协议要为每一个帧进行确认后才继续发送下一帧，大大降低了信道利用率，因此又提出了后退n协议。后退n协议中，发送方在发完一个数据帧后，不停下来等待应答帧，而是连续发送若干个数据帧，即使在连续发送过程中收到了接收方发来的应答帧，也可以继续发送。且发送方在每发送完一个数据帧时都要设置超时定时器。只要在所设置的超时时间内仍收到确认帧，就要重发相应的数据帧。如：当发送方发送了N个帧后，若发现该N帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不重新发送出错帧及其后的N帧。

### 选择重传协议

发送窗口大于1，接收窗口大于1。在后退n协议中，接收方若发现错误帧就不再接收后续的帧，即使是正确到达的帧，这显然是一种浪费。另一种效率更高的策略是当接收方发现某帧出错后，其后继续送来的正确的帧虽然不能立即递交给接收方的高层，但接收方仍可收下来，存放在接收缓冲区中，同时要求发送方重新传送出错的那一帧。一旦收到重新传来的帧后，就可以原已存于缓冲区中的其余帧一并按正确的顺序递交高层。这种方法称为选择重发`(SELECTICE REPEAT)`。显然，选择重发减少了浪费，但要求接收方有足够大的缓冲区空间。

# 有连接运输：TCP

## TCP特点

它是一个点到点的通信机制，只能有一个发送方和一个接收方；它提供是一个可靠的，按序的字节流机制；使用流水线机制，通过拥塞控制和流量控制的机制设置窗口尺寸；发送方和接收方都有缓存；它是一个全双工，能双向传输数据的面向连接的通信，通信双方必须在发送数据之前建立连接，连接状态只能在连接的两端维护，不能在沿途的结点维护状态。

## TCP报文段结构

![](4.png)

源地址端口，目的端口地址

序号：`TCP`传输保证连接性，发送的每个字节都要编上号

确认号：接收方期望从对方接受的字节编号。如果报文段的接收方成功的接受了对方发过来的编号x的字节，那么返回x+1作为确认号，确认号可以和数据捎带一起发送）　　

控制：定义了6中不同的控制位或者标志位：`URG`:紧急数据标志位，`ACK`：确认标志位，`PSH`：请求推送位，接收端应尽快把数据传送给应用层，`RST`：连接复位，通常，如果TCP收到的一个分段明显不属于该主机的任何一个连接，则向远程发送一个复位包，`SYN`：建立连接，让连接双方同步序列号，`FIN`：释放连接

检验和：`TCP`的使用检验和是强制性的,`UDP`使用检验和是可选的。在计算检验和是报文段要附加相同的伪首部，对于`TCP`来说伪首部的协议字段的值是6

## TCP实现可靠数据传输

`TCP`在`IP`层提供的不可靠服务基础上实现的可靠数据传输，使用流水线机制，累积确认机制，单一的重传计时器。触发重传的事件：超时，收到重复的`ACK`。

## 快速重传机制

`TCP`实现中，如果发生超时时间，超时时间间隔会重新设置，即将超时时间间隔加倍，导致其很大，重发丢失分组的时间会等待很久的时间。可以通过重复`ACK`检测检测分组丢失，`Sender`收到同一个数据的3个`ACK`，则假定该数据之后的段已经丢失，即在定时器超时之前进行重传。

## TCP流量控制

接收方为`TCP`连接分配`buffer`

![](5.png)

如果上层应用处理`buffer`中的数据较慢，发送方在这个机制下发送方不会传输的太多太快以至于淹没接收方（`buffer`溢出）实现的时候就是`Received`在`Segment`的头部字段中将`RcvWindow`告诉`Sender`，`Sender`限制自己发送的但还没收到`ACK`的数据不超过接收方的空闲`RECWindow`的尺寸。但是如果`Received`告知`Sender` `RcvWindow=0`是，发送方仍然可以发送一个很少的数据段，从而更新`RcvWindow`的值　　

## TCP拥塞控制

首先，拥塞控制和流量控制是不一样的。拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程。流量控制是点对点通信量的控制，是一个端到端的问题，主要就是抑制发送端发送数据的速率，以便接收端来得及接收。

拥塞的标志：重传计时器超时，接收到三个重复确认。

发送方维持一个叫做拥塞窗口的状态变量。拥塞窗口的大小取决于网络的拥塞程度，且动态地在变化，我们使用`TCP`拥塞控制算法，该算法包括：慢开始和拥塞避免以及快速恢复。

### 慢启动和拥塞避免

慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大（指数的增长）逐渐增加拥塞窗口的大小。拥塞避免则是让拥塞窗口缓慢地增大，即每经过一个往返时间`RTT`就把发送方的拥塞控制窗口加一

![](6.png)

为了防止拥塞窗口增长过大引起网络拥塞，设置一个慢开始门限（`ssthresh`状态变量） 
当拥塞窗口＜`ssthresh`，使用慢开始算法（指数增长） 
当拥塞窗口=`ssthresh`，既可使用慢开始算法，也可以使用拥塞避免算法（线性增长）
当拥塞窗口＞`ssthresh`，使用拥塞避免算法

但是无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。

### 快速恢复与快速重传配合使用

采用快速恢复算法时，慢开始只在`TCP`连接建立时和网络出现超时时才使用。 
当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把`ssthresh`门限减半。但是接下去并不执行慢开始算法。 

考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将`cwnd`设置为`ssthresh`的大小，然后执行拥塞避免算法。

# TCP连接管理

## TCP的三次握手

![](7.png)

建立连接。客户端发送连接请求报文段，将`SYN`位置为1，`Sequence Number`为`x`（随机数）；

服务器收到SYN报文段。服务器收到客户端的`SYN`报文段，需要对这个`SYN`报文段进行确认，设置`ACK`为`x+1(Sequence Number+1)`；同时，自己自己还要发送`SYN`请求信息，将`SYN`位置为1，`Sequence Number`为`y`；

客户端收到服务器的`SYN+ACK`报文段。然后将`ACK`设置为`y+1`，向服务器发送`ACK`报文段，

为什么需要三次握手？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

## TCP的四次挥手

![](8.png)

为什需要四次挥手？

`TCP`协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。`TCP`是全双工模式，这就意味着，当主机1发出`FIN`报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回`ACK`报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了`FIN`报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次`TCP`连接。

# 为什么TCP采用随机初始序列号

在`TCP`的三次握手中，后采用随机产生的初始化序列号进行请求，这样做主要是出于网络安全的因素着想。如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段。

# 客户端和服务器最多能发送和接收多少TCP连接数？

对于服务器，每一个`TCP`连接都要占一个文件描述符，一旦这个文件描述符使用完了，就会返回错误。我们知道操作系统上端口号1024以下是系统保留的，从1024-65535是用户使用的。由于每个`TCP`连接都要占一个端口号，所以我们最多可以有60000多个并发连接？但是事实并不是这样。

我们还知道对于`TCP`连接是由：原`IP`，原端口，目的`IP`，目的端口。但是监听`server`端`TCP`连接4元组中只有`remote ip`（也就是`client ip`）和`remote port`（客户端`port`）是可变的，因为它是固定在本地的端口上去监听，所以最大`TCP`连接为：客户端`ip`数×客户端`port`数.

而对于客户端，网络通信过程中服务端监听一个固定的端口,客户端主动发起连接请求后要经过三次握手才能与服务器建立起一个`TCP`连接.客户端每次发起一个`TCP`连接时,系统会随机选取一个空闲的端口,该端口是独占的不能与其他`TCP`连接共享,因此理论上一台机器有多少空闲的端口,就能对外发起多少个`TCP`连接。根据`TCP/IP`协议,端口`port`使用16位无符号整数`unsigned short`来存储,因此本地端口一共有2^16=65536个,即0-65535,其中0~1023是预留端口,0有特殊含义不能使用,1024以下端口都是超级管理员用户(如`root`)才可以使用,因此就算使用`root`权限,一台机器最多能使用的端口也只有65535个。但是一台机器最多只能利用28232个端口.

