<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot开发十五-发布帖子]]></title>
    <url>%2F2019%2F08%2F18%2FSpringBoot%E5%BC%80%E5%8F%91%E5%8D%81%E4%BA%94-%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发十四-过滤敏感词]]></title>
    <url>%2F2019%2F08%2F18%2FSpringBoot%E5%BC%80%E5%8F%91%E5%8D%81%E5%9B%9B-%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[项目需求—过滤敏感词利用 Tire 树实现过滤敏感词 定义前缀树，根据敏感词初始化前缀树，编写过滤敏感词的方法 代码实现我们首先把敏感词存到一个文件 sensitive.txt： 1234赌博嫖娼吸毒开票 然后我们写一个工具 SensitiveFilter 实现这个功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package com.nowcoder.community.util;import org.apache.commons.lang3.CharUtils;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.HashMap;import java.util.Map;@Componentpublic class SensitiveFilter &#123; private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class); // 替换符 private static final String REPLACEMENT = "***"; // 根节点 private TrieNode rootNode = new TrieNode(); @PostConstruct public void init() &#123; try ( InputStream is = this.getClass().getClassLoader().getResourceAsStream("sensitive-words.txt"); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); ) &#123; String keyword; while ((keyword = reader.readLine()) != null) &#123; // 添加到前缀树 this.addKeyword(keyword); &#125; &#125; catch (IOException e) &#123; logger.error("加载敏感词文件失败: " + e.getMessage()); &#125; &#125; // 将一个敏感词添加到前缀树中 private void addKeyword(String keyword) &#123; TrieNode tempNode = rootNode; for (int i = 0; i &lt; keyword.length(); i++) &#123; char c = keyword.charAt(i); TrieNode subNode = tempNode.getSubNode(c); if (subNode == null) &#123; // 初始化子节点 subNode = new TrieNode(); tempNode.addSubNode(c, subNode); &#125; // 指向子节点,进入下一轮循环 tempNode = subNode; // 设置结束标识 if (i == keyword.length() - 1) &#123; tempNode.setKeywordEnd(true); &#125; &#125; &#125; /** * 过滤敏感词 * * @param text 待过滤的文本 * @return 过滤后的文本 */ public String filter(String text) &#123; if (StringUtils.isBlank(text)) &#123; return null; &#125; // 指针1 TrieNode tempNode = rootNode; // 指针2 int begin = 0; // 指针3 int position = 0; // 结果 StringBuilder sb = new StringBuilder(); while (position &lt; text.length()) &#123; char c = text.charAt(position); // 跳过符号 if (isSymbol(c)) &#123; // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步 if (tempNode == rootNode) &#123; sb.append(c); begin++; &#125; // 无论符号在开头或中间,指针3都向下走一步 position++; continue; &#125; // 检查下级节点 tempNode = tempNode.getSubNode(c); if (tempNode == null) &#123; // 以begin开头的字符串不是敏感词 sb.append(text.charAt(begin)); // 进入下一个位置 position = ++begin; // 重新指向根节点 tempNode = rootNode; &#125; else if (tempNode.isKeywordEnd()) &#123; // 发现敏感词,将begin~position字符串替换掉 sb.append(REPLACEMENT); // 进入下一个位置 begin = ++position; // 重新指向根节点 tempNode = rootNode; &#125; else &#123; // 检查下一个字符 position++; &#125; &#125; // 将最后一批字符计入结果 sb.append(text.substring(begin)); return sb.toString(); &#125; // 判断是否为符号 private boolean isSymbol(Character c) &#123; // 0x2E80~0x9FFF 是东亚文字范围 return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; 0x2E80 || c &gt; 0x9FFF); &#125; // 前缀树 private class TrieNode &#123; // 关键词结束标识 private boolean isKeywordEnd = false; // 子节点(key是下级字符,value是下级节点) private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;(); public boolean isKeywordEnd() &#123; return isKeywordEnd; &#125; public void setKeywordEnd(boolean keywordEnd) &#123; isKeywordEnd = keywordEnd; &#125; // 添加子节点 public void addSubNode(Character c, TrieNode node) &#123; subNodes.put(c, node); &#125; // 获取子节点 public TrieNode getSubNode(Character c) &#123; return subNodes.get(c); &#125; &#125;&#125; 然后写个测试类 SensitiveTests 测试一下： 1234567891011121314151617181920212223242526272829package com.nowcoder.community;import com.nowcoder.community.util.SensitiveFilter;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest@ContextConfiguration(classes = CommunityApplication.class)public class SensitiveTests &#123; @Autowired private SensitiveFilter sensitiveFilter; @Test public void testSensitiveFilter() &#123; String text = "这里可以赌博,可以嫖娼,可以吸毒,可以开票,哈哈哈!"; text = sensitiveFilter.filter(text); System.out.println(text); text = "这里可以☆赌☆博☆,可以☆嫖☆娼☆,可以☆吸☆毒☆,可以☆开☆票☆,哈哈哈!"; text = sensitiveFilter.filter(text); System.out.println(text); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发十三-检查登录状态]]></title>
    <url>%2F2019%2F08%2F18%2FSpringBoot%E5%BC%80%E5%8F%91%E5%8D%81%E4%B8%89-%E6%A3%80%E6%9F%A5%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[需求介绍—检查登录状态防止用户知道我们的一些功能的链接，直接就进到了该页面，就像有些功能是管理员访问才能进的，就需要进行登录状态的判断。 我们知道这个功能点很多其他的功能点都需要使用，所以我们需要使用拦截器。 但是这次在方法前标示自定义注解，拦截所有的请求只处理带该注解的方法 代码实现先自定义注解 LoginRequired：内容其实啥都不用写，只起到一个标示的作用，我打上这个标记就必须登录才能访问 123456789101112package com.nowcoder.community.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface LoginRequired &#123;&#125; 那么我们需要在 user/setting 的两个方法上加上这个注解： 12345@LoginRequired@RequestMapping(path = "/setting", method = RequestMethod.GET)@LoginRequired@RequestMapping(path = "/upload", method = RequestMethod.POST) 加上后就要利用拦截器拦截带有这个注解的方法，拦截到该方法之后就判断你有没有登录，登录了可以，没登录拒绝，新建 LoginRequiredInterceptor： 123456789101112131415161718192021222324252627282930313233343536package com.nowcoder.community.controller.interceptor;import com.nowcoder.community.annotation.LoginRequired;import com.nowcoder.community.util.HostHolder;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.Method;@Componentpublic class LoginRequiredInterceptor implements HandlerInterceptor &#123; @Autowired HostHolder hostHolder; // 在请求最初判断是否是登录状态 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 首先我们只拦截方法，其他的我们不管 if (handler instanceof HandlerMethod) &#123; // 进行类型转换 HandlerMethod handlerMethod = (HandlerMethod) handler; // 拦截到的Method的对象 Method method = handlerMethod.getMethod(); // 取到对象的注解 LoginRequired loginRequired = method.getAnnotation(LoginRequired.class); if (loginRequired != null &amp;&amp; hostHolder.getUser() == null) &#123; response.sendRedirect(request.getContextPath() + "/login"); return false; &#125; &#125; return true; &#125;&#125; 最后在 WebMvcConfig 里配置一下拦截器的拦截范围： 12345678910111213141516171819202122package com.nowcoder.community.config;import com.nowcoder.community.controller.interceptor.AlphaInterceptor;import com.nowcoder.community.controller.interceptor.LoginRequiredInterceptor;import com.nowcoder.community.controller.interceptor.LoginTicketInterceptor;import com.nowcoder.community.controller.interceptor.MessageInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Autowired private LoginRequiredInterceptor loginRequiredInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(loginRequiredInterceptor) .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");&#125;]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发十二-账号设置]]></title>
    <url>%2F2019%2F08%2F18%2FSpringBoot%E5%BC%80%E5%8F%91%E5%8D%81%E4%BA%8C-%E8%B4%A6%E5%8F%B7%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[需求介绍—账号设置账号设置里面的上传头像（文件） 首先请求必须是一个 POST 请求，其次表单的属性 enctype = “multipart/form-data” 然后就是利用 MultipartFile 处理上传文件。 然后就是访问账号设置页面，上传头像，获取头像。 代码实现我们的头像上传之后是存放到我们的服务器硬盘之上，所以我们需要在 application.properties配置一下我们的资源上传之后是存放到了哪里 123# communitycommunity.path.domain=http://localhost:8080community.path.upload=e:/upload 我们上传完文件最终是需要更新用户的 HeaderUrl，所以 Service 就需要提供一个方法改变这个 URL，然后上传文件的事情我们就在 Controller 里面解决掉，业务层只解决更新路径的这个业务就可以了。 那么在 UserService 里面追加一个方法更新用户的 URL 123public int updateHeader(int userId, String headerUrl) &#123; return userMapper.updateHeader(userId, headerUrl);&#125; 首先新建一个 UserController 实现对于用户的一些请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.nowcoder.community.controller;import com.nowcoder.community.annotation.LoginRequired;import com.nowcoder.community.entity.User;import com.nowcoder.community.service.FollowService;import com.nowcoder.community.service.LikeService;import com.nowcoder.community.service.UserService;import com.nowcoder.community.util.CommunityConstant;import com.nowcoder.community.util.CommunityUtil;import com.nowcoder.community.util.HostHolder;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.multipart.MultipartFile;import javax.jws.WebParam;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;@Controller@RequestMapping("/user")public class UserController implements CommunityConstant &#123; private static final Logger logger = LoggerFactory.getLogger(UserController.class); // 上传路径要注入进来 @Value("$&#123;community.path.upload&#125;") private String uploadPath; // 域名也需要用到 @Value("$&#123;community.path.domain&#125;") private String domain; // 需要用到项目的访问路径 @Value("$&#123;server.servlet.context-path&#125;") private String contextPath; @Autowired private UserService userService; @Autowired private HostHolder hostHolder; @LoginRequired @RequestMapping(path = "/setting", method = RequestMethod.GET) public String getSettingPage() &#123; return "/site/setting"; &#125; @LoginRequired @RequestMapping(path = "/upload", method = RequestMethod.POST) public String uploadHeader(MultipartFile headerImage, Model model) &#123; if (headerImage == null) &#123; model.addAttribute("error", "你还没有上传图片"); return "/site/setting"; &#125; // 上传这个文件，要更换一下文件名不能用上传的文件名 String fileName = headerImage.getOriginalFilename();// 得到原始的文件名 String suffix = fileName.substring(fileName.lastIndexOf('.')); if (StringUtils.isBlank(suffix)) &#123; model.addAttribute("error", "文件的格式不正确"); return "/site/setting"; &#125; // 生成随机的文件名 fileName = CommunityUtil.generateUUID() + suffix; // 确定文件存放的位置 File dest = new File(uploadPath + "/" +fileName); try &#123; headerImage.transferTo(dest); &#125; catch (IOException e) &#123; logger.error("上传文件失败：" + e.getMessage()); throw new RuntimeException("上传文件失败，服务器发生异常" + e); &#125; // 更新当前用户头像的路径（web路径） // http://localhost:8080/community/user/header/xxx.png User user = hostHolder.getUser(); String headerUrl = domain + contextPath + "/user/header/" + fileName; userService.updateHeader(user.getId(), headerUrl); return "redirect:/index"; &#125; @RequestMapping(path = "/header/&#123;fileName&#125;", method = RequestMethod.GET) public void getHeader(@PathVariable("fileName") String fileName, HttpServletResponse httpServletResponse) &#123; // 服务器存放路径 fileName = uploadPath + "/" + fileName; // 文件的后缀 String suffix = fileName.substring(fileName.lastIndexOf('.')); // 响应图片 httpServletResponse.setContentType("image/" + suffix); // 因为图片是二进制，所以要先获得字节流 try ( OutputStream os = httpServletResponse.getOutputStream(); FileInputStream fis = new FileInputStream(fileName); ) &#123; byte[] buffer = new byte[1024]; int b = 0; while ((b = fis.read(buffer)) != -1) &#123; os.write(buffer, 0, b); &#125; &#125; catch (IOException e) &#123; logger.error("读取头像失败：" + e.getMessage()); &#125; &#125;&#125; 最后就是处理页面的逻辑了。]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接池]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux常用的命令]]></title>
    <url>%2F2019%2F08%2F18%2FLinux%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[删除目录下的TXT文件用什么命令 新建一个文件用什么命令 新建一个目录用什么命令 快速找到进程和对应的服务端口号 给定名称找到对应进程]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易一面]]></title>
    <url>%2F2019%2F08%2F16%2F%E7%BD%91%E6%98%93%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[时长32分钟 自我介绍 学习了哪些数据结构？ 问了堆和栈的区别：我知道想问操作系统的但是我刚开始一紧张我卡词了然后我说了一下竞赛里面的堆栈， Java内存划分：介绍了一下几个区域，然后还详细说了一下这个里面是放啥的 怎么GC？说了一下GC条件，对象存活判断的两个方法，GC算法 引用计数法的问题 new一个对象是放到堆上那么你new一个线程呢，放到哪里？ 不知道 问了堆的划分，问了GC Eden区的时候对象会怎么办 问了Java虚拟机初始化的参数，我不知道说了有关年轻代的几个参数 如果老年代满了怎么办，我不清楚说了好像是有个full gc可以操作一下 说一下项目的登录注册功能，说一下如何保持你的登录态 你说了你做性能优化，为什么要做性能优化 说一下你项目中出现的异常 数据库挂掉了是怎么表现的，比方说什么日志？ 哎都给提醒了我也不知道了，就说了你网页请求访问是没有响应的，功能都没了 最近看了哪几本书，你怎么学习 比方说你碰到了Redis的一个问题，谷歌不到，认识的人也不会，你怎么办？ 我说去官网找客服，谁都可以不会但是开发的人员不能不回会 有没有看过一些开源的源码？一开始尬住了，最近是没怎么看源码，面试官很好问了我又没有看过jdk的，我说了看了hashmap，courrenthashmap这些数据结构的都看了 问了一下为什么长度达到一定的长度要转化为红黑树 有什么问题？问了部门业务，说接下来有段空档期想给点建议好继续学习，说了学习微服务，redis继续深入的了解]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库索引]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[什么是索引一个索引是存储的表中一个特定列的值数据结构。索引是在表的列上创建，以协助快速查询、更新数据库表中数据。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。请记住记住这一点：索引是一种数据结构。 那什么样的数据结构可以作为索引？ B-Tree 是最常用的用于索引的数据结构。因为它们是时间复杂度低， 查找、删除、插入操作都可以可以在对数时间内完成。另外一个重要原因存储在 B-Tree 中的数据是有序的。数据库管理系统通常决定索引应该用哪些数据结构。但是，在某些情况下，你在创建索引时可以指定索引要使用的数据结构。 为什么要加索引，它是怎么提高性能的，在哪列加索引比方说我们运行以下的 sql 语句 1SELECT * FROM Employee WHERE Employee_Name = 'Jesus' 一旦我们运行这个查询由于我们想要得到每一个名字为 Jesus 的雇员信息，在查询到第一个符合条件的行后，不能停止查询，因为可能还有其他符合条件的行。所以，必须一行一行的查找直到最后一行，这就意味数据库不得不检查上千行数据才能找到所以名字为 Jesus 的雇员。这就是所谓的全表扫描。 使用索引的话，因为索引基本上是用来存储列值的数据结构，这使查找这些列值更加快速。如果索引使用最常用的数据结构 B-Tree那么其中的数据是有序的。假设我们在 Employee_Name这一列上创建一个B-Tree索引，索引已经排序意味着查询一个名字会快很多，因为名字少字母为‘J’的员工都是排列在一起的。另外重要的一点是，索引同时存储了表中相应行的指针以获取其他列的数据。 因此索引的全部意义就是通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度。 那么在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引： 一般来说，应该在这些列上创建索引： 在经常需要搜索的列上，可以加快搜索的速度； 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 不应该创建索引的的这些列具有下列特点： 对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 对于那些定义为 text , image 和 bit 数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。 索引的好处和缺点好处 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 缺点 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引存了哪些内容数据库索引是创建在表的某列上的，并且存储了这一列的所有值。但是，数据库索引并不存储这个表中其他列（字段）的值，同时索引还存储了指向表中某一行的指针。 索引种类 唯一索引：UNIQUE 例如：create unique index stusno on student（sno）；表明此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。 主键索引： primary key数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引（也叫聚簇索引）：cluster在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。 如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。 根据实现方式 聚集索引 非聚集索引 哈希索引 B+-树索引（二分查找） 索引原理就是底层使用的数据结构，然后可以介绍一下索引的优缺点]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解ThreadLocal]]></title>
    <url>%2F2019%2F08%2F15%2F%E7%90%86%E8%A7%A3ThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal介绍ThreadLocal提供了线程的局部变量，每个线程都可以通过 set() 和 get() 来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。简单的来说往 ThreadLocal 中填充的变量是属于当前线程的。设计的目的就是为了能够在当前线程中有属于自己的变量，并不是为了解决并发或者共享变量的问题 实现的原理先看 ThreadLocal 的 set() 方法，因为我们一般使用都是 new 完对象，就往里边 set 对象了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void set(T value) &#123; // 得到当前线程对象 Thread t = Thread.currentThread(); // 这里获取ThreadLocalMap ThreadLocalMap map = getMap(t); // 如果map存在，则将当前线程对象t作为key，要存储的对象作为value存到map里面去 if (map != null) map.set(this, value); else createMap(t, value);&#125;// 看下ThreadLocalMap是啥static class ThreadLocalMap &#123; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as "stale entries" in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; //....很长&#125;// 通过上面我们可以发现的是ThreadLocalMap是ThreadLocal的一个内部类。用Entry类来进行存储我们的值都是存储到这个Map上的，key是当前ThreadLocal对象！// 如果该Map不存在，则初始化一个,存在的话则从Thread中获取void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;// 而Thread又维护了ThreadLocalMap变量ThreadLocal.ThreadLocalMap threadLocals = null// ThreadLocalMap是在ThreadLocal中使用内部类来编写的，但对象的引用是在Thread中！于是我们可以总结出：Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象 那么我们再看 get() 方法 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 原理整理： 每个 Thread 维护着一个 ThreadLocalMap 的引用 ThreadLocalMap 是 ThreadLocal 的内部类，用 Entry 来进行存储 调用 ThreadLocal 的 set() 方法时，实际上就是往 ThreadLocalMap 设置值，key 是 ThreadLocal 对象，值是传递进来的对象 调用 ThreadLocal 的 get() 方法时，实际上就是往 ThreadLocalMap 获取值，key 是 ThreadLocal 对象 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。 对象存放在哪里我们知道在 Java 中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。 但是ThreadLocal 的实例以及其值不是存放在栈上而是存放在堆上，只是通过一些技巧处理使得修改了可见性。 ThreadLocal 内存泄漏由于 ThreadLocalMap 的生命周期跟 Thread 一样长，如果没有手动删除对应 key 就会导致内存泄漏，而不是因为弱引用。想要避免内存泄露就要手动 remove() 掉！ 使用的点管理数据库 Connection ，为了方便操作写了一个简单数据库连接池，需要数据库连接池的理由也很简单，频繁创建和关闭 Connection 是一件非常耗费资源的操作，因此需要创建数据库连接池～ 数据库连接池的连接怎么管理呢？我们交由 ThreadLocal 来进行管理。为什么交给它来管理呢？ThreadLocal能够实现当前线程的操作都是用同一个Connection，保证了事务！ ThreadLocal是如何做到为每一个线程维护变量的副本的呢在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。 ThreadLocal 和同步机制的区别在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序缜密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。 而 ThreadLocal 则从另一个角度来解决多线程的并发访问。ThreadLocal 为每一个线程提供一个独立的变量副本，从而隔离了多个线程对访问数据的冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal 提供了线程安全的对象封装，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 由于 ThreadLocal 中可以持有任何类型的对象，低版本 JDK 所提供的 get( ) 返回的是 Object 对象，需要强制类型转换。但 JDK 5.0 通过泛型很好的解决了这个问题，在一定程度上简化 ThreadLocal 的使用，代码清单9-2就使用了 JDK 5.0 新的 ThreadLocal 版本 synchronized 关键字也用来解决多线程环境下访问变量的问题，这两者的区别在于 ThreadLocal 是用空间换取时间，synchronized 关键字是用时间换空间。]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发十一-显示登录信息]]></title>
    <url>%2F2019%2F08%2F13%2FSpringBoot%E5%BC%80%E5%8F%91%E5%8D%81%E4%B8%80-%E6%98%BE%E7%A4%BA%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[需求介绍—显示登录信息我们需要在每个页面的头部都要把登录用户的头像显示出来，另外在详细信息里面你需要显示用户的名字，除此之外如果登录了，我们显示首页 信息 头像 三个功能的链接，否则显示首页 登录两个功能点，也就是根据登录与否显示头部的内容。 我们每个静态页面都有这个内容，都需要显示登录信息，那么开发这个功能你需要每个请求都需要实现这个工能。我们想要低耦合的解决这个功能，就利用 Spring 的拦截器，它可以拦截访问服务器的请求，拦截请求之后可以在拦截这个请求之后的开始或者结束的部分插入一些代码，从而解决一些请求共有点的一些功能实现。 代码实现使用拦截器的方法： 先写一个类实现 HandlerInterceptor 接口，然后配置拦截器的处理范围，拦截哪些请求，不拦截哪些请求。写个实例，先写类 AlphaInterceptor 实现 HandlerInterceptor 接口： 12345678910111213141516171819202122232425262728293031323334353637package com.nowcoder.community.controller.interceptor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Component// 把拦截器交给容器管理public class AlphaInterceptor implements HandlerInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(AlphaInterceptor.class); // 在Controller之前执行 // Object是拦截的方法 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug("preHandle: "+ handler.toString()); return true; &#125; // 在调用完Controller之后执行，模板之前执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; logger.debug("postHandle:" + handler.toString()); &#125; // 在TemplateEngine之后执行 // 异常是在调用Controller或者模板过程中出现了异常就会赋值给这个ex参数 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; logger.debug("afterCompletion: " + handler.toString()); &#125;&#125; 我们写好了之后要写一个配置类 WebMvcConfig： 一般配置类都是引入第三方的 Bean，但是拦截器需要实现 WebMvcConfigurer 接口。 1234567891011121314151617181920212223package com.nowcoder.community.config;import com.nowcoder.community.controller.interceptor.AlphaInterceptor;import com.nowcoder.community.controller.interceptor.LoginRequiredInterceptor;import com.nowcoder.community.controller.interceptor.LoginTicketInterceptor;import com.nowcoder.community.controller.interceptor.MessageInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Autowired private AlphaInterceptor alphaInterceptor; // .excludePathPatterns 表示哪些路径不被拦截比方说一些静态资源， // .addPathPatterns 表示确定的拦截的路径 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(alphaInterceptor) .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg") .addPathPatterns("/register", "/login");&#125; 知道拦截器怎么用了，我们就正式来写一下，根据我们的需求， 我们需要在请求开始时查询登录用户，然后在本次请求中持有用户数据（就是存到内存里），然后在模板视图上引用，最后在请求结束时清理用户数据。 第一步我们知道 Cookie 是从 HttpServletRequest 对象里面取出来的，因为很多情况下都需要获获取 Cookie，所以写一个工具帮我们实现一下 CookieUtil： 12345678910111213141516171819202122232425package com.nowcoder.community.util;import org.springframework.web.bind.annotation.CookieValue;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;public class CookieUtil &#123; public static String getValue(HttpServletRequest httpServletRequest, String name) &#123; if (httpServletRequest == null || name == null) &#123; throw new IllegalArgumentException("参数为空！"); &#125; Cookie[] cookies = httpServletRequest.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(name)) &#123; return cookie.getValue(); &#125; &#125; &#125; return null; &#125;&#125; 其次我们说了我们通过 Ticket 查询到的用户，我们需要把它存下来，但是由于服务器对应客户端是一对多的，它是一个处理多线程的，每个线程隔离的存这个对象，那么我们写个工具 HostHolder 存 User 对象，起到一个容器的作用： 123456789101112131415161718192021222324package com.nowcoder.community.util;import com.nowcoder.community.entity.User;import org.springframework.stereotype.Component;/** * 持有用户信息，用于代替session对象 */@Componentpublic class HostHolder &#123; private ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;&gt;(); public void setUser(User user) &#123; users.set(user); &#125; public User getUser() &#123; return users.get(); &#125; public void clear() &#123; users.remove(); &#125;&#125; 然后写个拦截器 LoginTicketInterceptor： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.nowcoder.community.controller.interceptor;import com.nowcoder.community.entity.LoginTicket;import com.nowcoder.community.entity.User;import com.nowcoder.community.service.UserService;import com.nowcoder.community.util.CookieUtil;import com.nowcoder.community.util.HostHolder;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.context.SecurityContextImpl;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.net.Authenticator;import java.util.Date;@Componentpublic class LoginTicketInterceptor implements HandlerInterceptor &#123; @Autowired private UserService userService; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 从Cookie中获取凭证 String ticket = CookieUtil.getValue(request, "ticket"); if (ticket != null) &#123; // 查询凭证 LoginTicket loginTicket = userService.findLoginTicket(ticket); // 检查凭证是否有效 if (loginTicket != null &amp;&amp; loginTicket.getStatus() == 0 &amp;&amp; loginTicket.getExpired().after(new Date())) &#123; // 根据凭证查用户 User user = userService.findUserById(loginTicket.getUserId()); // 在本次请求中持有用户，多线程，利用ThreadLocal hostHolder.setUser(user); &#125; &#125; return true; &#125; // 在模板引擎调用之前把这个User存放到modelAndView里面 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; User user = hostHolder.getUser(); if (user != null &amp;&amp; modelAndView != null) &#123; modelAndView.addObject("loginUser", user); &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; hostHolder.clear(); SecurityContextHolder.clearContext(); &#125;&#125; 写好拦截器就要注入到 WebMvcConfig： 12345678910111213141516171819202122232425262728package com.nowcoder.community.config;import com.nowcoder.community.controller.interceptor.AlphaInterceptor;import com.nowcoder.community.controller.interceptor.LoginRequiredInterceptor;import com.nowcoder.community.controller.interceptor.LoginTicketInterceptor;import com.nowcoder.community.controller.interceptor.MessageInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Autowired private AlphaInterceptor alphaInterceptor; @Autowired private LoginTicketInterceptor loginTicketInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(alphaInterceptor) .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg") .addPathPatterns("/register", "/login"); registry.addInterceptor(loginTicketInterceptor) .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");&#125; 然后就是处理页面了。]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发十-开发登录，退出功能]]></title>
    <url>%2F2019%2F08%2F13%2FSpringBoot%E5%BC%80%E5%8F%91%E5%8D%81-%E5%BC%80%E5%8F%91%E7%99%BB%E5%BD%95%EF%BC%8C%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[需求介绍—开发登录，退出功能访问登录页面：点击头部区域的链接打开登录页面 登录： 验证账号，密码，验证码 成功时生成登录凭证发放给客户端，失败时跳转回登录页面 退出： 将登录状态修改为失效的状态 跳转至往网站的首页 代码实现现在我们暂时把登录凭证存到数据库里面有一张表login_tickrt，以后会存到Redis里面。 那么首先要把登录凭证的相关操作实现了，首先写个实体类对应login_tickrt表里的数据，将其封装起来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.nowcoder.community.entity;import java.util.Date;public class LoginTicket &#123; private int id; private int userId; private String ticket; private int status; private Date expired; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getUserId() &#123; return userId; &#125; public void setUserId(int userId) &#123; this.userId = userId; &#125; public String getTicket() &#123; return ticket; &#125; public void setTicket(String ticket) &#123; this.ticket = ticket; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public Date getExpired() &#123; return expired; &#125; public void setExpired(Date expired) &#123; this.expired = expired; &#125; @Override public String toString() &#123; return "LoginTicket&#123;" + "id=" + id + ", userId=" + userId + ", ticket='" + ticket + '\'' + ", status=" + status + ", expired=" + expired + '&#125;'; &#125;&#125; 接下来实现数据访问的逻辑，那么新建一个接口LoginTicketMapper，对应的有以下几种方法：增加一个凭证，依据ticket来查凭证，修改凭证的状态。 这次我们通过注解的方式实现sql查询。 123456789101112131415161718192021222324252627package com.nowcoder.community.dao;import com.nowcoder.community.entity.LoginTicket;import org.apache.ibatis.annotations.*;@Mapperpublic interface LoginTicketMapper &#123; @Insert(&#123; "insert into login_ticket(user_id,ticket,status,expired) ", "value(#&#123;userId&#125;,#&#123;ticket&#125;,#&#123;status&#125;,#&#123;expired&#125;)" &#125;) // 希望id自动生成， @Options(useGeneratedKeys = true, keyProperty = "id") int insertLoginTicket(LoginTicket loginTicket); @Select(&#123; "select id,user_id,ticket,status,expired ", "from login_ticket where ticket=#&#123;ticket&#125;" &#125;) LoginTicket selectByTicket(String ticket); @Update(&#123; "update login_ticket set status=#&#123;status&#125; where ticket=#&#123;ticket&#125;" &#125;) int updateStatus(String ticket, int status);&#125; 那么现在就开发业务层UserService： 12345678910111213141516171819202122232425262728293031323334353637383940// 封装一个Map，返回多种情况的返回结果public Map&lt;String, Object&gt; login(String username, String password, long expiredSeconds) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); if(StringUtils.isBlank(username)) &#123; map.put("usernameMsg", "账号不能为空"); &#125; if(StringUtils.isBlank(password)) &#123; map.put("passwordMsg", "密码不能为空"); &#125; // 验证账号 User user = userMapper.selectByName(username); if (user == null) &#123; map.put("usernameMsg", "该账号不存在"); return map; &#125; // 验证状态 if(user.getStatus() == 0) &#123; map.put("usernameMsg", "该账号未激活"); return map; &#125; // 验证密码 password = CommunityUtil.md5(password + user.getSalt()); if (!user.getPassword().equals(password)) &#123; map.put("passwordMsg", "密码不正确"); return map; &#125; // 生成登录凭证 LoginTicket loginTicket = new LoginTicket(); loginTicket.setUserId(user.getId()); loginTicket.setTicket(CommunityUtil.generateUUID()); loginTicket.setStatus(0); loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000)); loginTicketMapper.insertLoginTicket(loginTicket); map.put("ticket", loginTicket.getTicket()); return map; &#125; 那么现在写表现层，写LoginController来处理页面传来的请求，写能处理请求的方法就可以了。 对于记住我的勾选我们要有不同的保存时间，所以我们定义两个常量的时间比较好，在CommunityConstant里添加定义： 123456789/*** 默认状态的登录凭证的超时时间*/int DEFAULT_EXPIRED_SECONDS = 3600 * 12;/*** 记住状态的登录凭证的超时时间*/int REMEMBER_EXPIRED_SECONDS = 3600 * 24 *100; 辅助功能完成就写对应的表现层： 12345678910111213141516171819202122232425262728293031// 我们在决定Cookie的有效路径,最好是用变量来显示比较方便@Value("$&#123;server.servlet.context-path&#125;")private String contextPath;@RequestMapping(path = "/login", method = RequestMethod.POST)public String login(String username, String password, String code, boolean rememberme, Model model, HttpSession httpSession, HttpServletResponse httpServletResponse) &#123; // 检查验证码 String kaptcha = (String) httpSession.getAttribute("kaptcha"); if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) &#123; model.addAttribute("codeMsg","验证码不正确"); return "/site/login"; &#125; // 检查账号，密码 int expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS; Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds); if(map.containsKey("ticket")) &#123; // 需要给客户端发送一个Cookie Cookie cookie = new Cookie("ticket", map.get("ticket").toString()); cookie.setPath(contextPath); cookie.setMaxAge(expiredSeconds); httpServletResponse.addCookie(cookie); return "redirect:/index"; &#125; else &#123; model.addAttribute("usernameMsg", map.get("usernameMsg")); model.addAttribute("passwordMsg", map.get("passwordMsg")); return "/site/login"; &#125; &#125; 最后开发退出： 首先数据层我们已经写好了，只需要写个业务层和表现层 1234// 业务层调一下mapper的update方法就可以了public void logout(String ticket) &#123; loginTicketMapper.updateStatus(ticket, 1);&#125; 表现层要从Cookie中拿到ticket，然后调业务层。 12345@RequestMapping(path = "/logout", method = RequestMethod.GET)public String logout(@CookieValue("ticket") String ticket) &#123; userService.logout(ticket); return "redirect:/login";&#125;]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发九-生成验证码]]></title>
    <url>%2F2019%2F08%2F13%2FSpringBoot%E5%BC%80%E5%8F%91%E4%B9%9D-%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[需求介绍—生成验证码先生成随机字符串然后利用Kaptcha API生成验证图片 代码实现先在pom.xml引入 12345&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt; 因为SpringBoot中没有整合kaptcha，所以我们需要自己对这个做一个配置，所以要写一个配置类KaptchaConfig加载到Spring容器里面对其做一个初始化。 1234567891011121314151617181920212223242526272829303132package com.nowcoder.community.config;import com.google.code.kaptcha.Producer;import com.google.code.kaptcha.impl.DefaultKaptcha;import com.google.code.kaptcha.util.Config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Properties;// 该注解表示这个是一个配置类@Configurationpublic class KaptchaConfig &#123; // 实例化这个接口 @Bean public Producer kaptchaProducer() &#123; Properties properties = new Properties(); properties.setProperty("kaptcha.image.width", "100"); properties.setProperty("kaptcha.image.height", "40"); properties.setProperty("kaptcha.textproducer.font.size", "32"); properties.setProperty("kaptcha.textproducer.font.color", "0,0,0"); // 验证码的字符在哪个范围里随机产生 properties.setProperty("kaptcha.textproducer.char.string", "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"); // 验证码的长度 properties.setProperty("kaptcha.textproducer.char.length", "4"); properties.setProperty("kaptcha.noise.impl", "com.google.code.kaptcha.impl.NoNoise"); DefaultKaptcha kaptcha = new DefaultKaptcha(); Config config = new Config(properties); kaptcha.setConfig(config); return kaptcha; &#125;&#125; 然后再登录页面LoginController里面使用，思想是在一个方法是给浏览器返回一个html，这个html里面会包含一个验证码的路径，浏览器会再访问服务器得到这个验证码图片，所以要写一个方法向浏览器返回图片，但是在模板里会引入这个路径。 123456789101112131415161718192021@Autowiredprivate Producer kaptchaProducer;@RequestMapping(path = "/kaptcha", method = RequestMethod.GET) public void getKaptcha(HttpServletResponse httpServletResponse, HttpSession httpSession) &#123; // 生成验证码 String text = kaptchaProducer.createText(); BufferedImage image = kaptchaProducer.createImage(text); // 将验证码存入session httpSession.setAttribute("kaptcha", text); // 将图片输出给浏览器 httpServletResponse.setContentType("image/png"); try &#123; OutputStream os = httpServletResponse.getOutputStream(); ImageIO.write(image, "png", os); &#125; catch (IOException e) &#123; logger.error("响应验证码失败" + e.getMessage()); &#125;&#125; 当然你还需要在login.html文件里面改一下对应的那个验证码的路径就可以实现了。]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发七-会话管理]]></title>
    <url>%2F2019%2F08%2F13%2FSpringBoot%E5%BC%80%E5%8F%91%E5%85%AB-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[需求介绍—会话管理利用Cookie和Seesion使得HTTP变成有会话的连接，写几个实例演示一下 代码实现先写个例子，表示客户端第一次访问服务器，服务器端创建一个Cookie发送给客户端。 不管是返回什么，都是通过做出响应，都是通过HttpServletResponse作响应，存到HttpServletResponse的头部 1234567891011121314151617181920@RequestMapping(path = "/cookie/set", method = RequestMethod.GET)@ResponseBodypublic String setCookie(HttpServletResponse httpServletResponse) &#123; // 创建对象 Cookie cookie = new Cookie("code", CommunityUtil.generateUUID()); // 指定路径，设置cookie有效范围,只有这个范围发送的时候才会发送Cookie cookie.setPath("/community"); // 设置cookie生存时间，以秒为单位 cookie.setMaxAge(60 * 10); // 发送cookie httpServletResponse.addCookie(cookie); return "set cookie";&#125;// 查看Cookie,通过@CookieValue注解，可以在服务端得到Cookie，通过里面的变量值来得到某一个Cookie的Value值，不然那得到是头携带的所有的Cookie@RequestMapping(path = "/cookie/get", method = RequestMethod.GET)@ResponseBodypublic String getCookie(@CookieValue("code") String code) &#123; System.out.println(code); return "get cookie";&#125; 结果： 那现在看下Session的创建，下发，响应。 Session可以存任意的数据，而Cookie一般只能存String 12345678910111213141516// Session示例@RequestMapping(path = "/sesssion/set", method = RequestMethod.GET)@ResponseBodypublic String setSession(HttpSession httpSession) &#123; httpSession.setAttribute("id",1); httpSession.setAttribute("name","Test"); return "set Session";&#125;// 从session中取值@RequestMapping(path = "/session/get", method = RequestMethod.GET)@ResponseBodypublic String getSession(HttpSession httpSession) &#123; System.out.println(httpSession.getAttribute("id")); System.out.println(httpSession.getAttribute("name")); return "get Session";&#125;]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试常见的机智题]]></title>
    <url>%2F2019%2F08%2F13%2F%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%BA%E6%99%BA%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2个人拿一百个东西，一个人一次能拿1-5个，有没有必胜的方法12345这种题目是考虑倍数的问题。每次最多取 5 个最少 1 个，这样的话就考虑每次取 6，100÷6=16余4。先拿的人拿 4 个，不论第二个人拿几个，第一个人把他凑成 6 个，这样永远是第一个人取到最后一个 A，B从一堆玻璃球（共100个）里向外拿球，规则如下： (1)A先拿，然后一人一次交替着拿； (2)每次只能拿1个或2个或4个； (3)谁拿最后一个球，谁就是最后的失败者；问A，B谁将是失败者？12345678A是失败者，证明过程如下。1）经验算，当谁面临着4个球的时候，谁要拿球就是失败者原因：全拿，输了；拿一个，对方拿两个，输了；拿两个，对方拿一个，输了。2）其余的96（16*6）个球，正好是6的倍数，假设A,在剩下4个球之前，从来没一次拿过1个球。（拿得是2、4），则B可以每次拿4或2，组成和为6的循环，直至剩下4个球给A.3）假设在上述96（16*6）个球中，A有过一次拿1个球，我们假设前15轮都是每轮6个球（15*6），目前的情况是，完成15轮之后，剩下10个球；3.1）此时A拿了1个球，B面临9个球。如可以选择1,2,4，但是B会选择拿2个球，（因为拿一个，剩下8个给对方，对方拿4个，自己就输了详见1条；拿4个，剩下5个给对方，对方拿一个，自己也输了）。3.2）此时A面临7个球，因为是假设A只有一次拿球，所以，A要拿2或4，结果是留给对方5或3，对方拿走4或2之后，自己肯定就输了。4）假设2中，A有过两次拿1个球，则B可以选择拿两次2个球，有凑成了6，只不过是多了一步，但是不打破16*6的规律。总结就是如果拿偶数次，则不会破坏16*6的趋势，如果拿奇数次，则奇数-1，归到15*6中去最后一次同3. 有两根不均匀分布的香，香烧完的时间是一个小时，你能用什么方法来确定一段15分钟的时间？1第一根香先点一端，第二根香在第一根香点燃时候同时把两端点燃，这样第二根香烧完是半小时，此时第一根香也剩半小时，在第二根香烧完的同时把第一根香的另外一端也点燃，那么从第二根香烧完到第一根香烧完的这段时间就是15分钟。 抛硬币，正面继续抛，反面不抛。问抛的次数的期望延伸到连续抛 n 次假设已经连续抛出 n-1 次正面，需要 Tn−1 次。想得到 n 次正面，则再进行一次投掷，若硬币为正面则游戏结束，还需要抛 0 次（Tn=Tn−1+1+0.5∗0+?Tn=Tn−1+1+0.5∗0+?）；如果硬币为反面，则游戏重来，还需要投掷0.5∗Tn0.5∗Tn次，递推公式如下所示：Tn=Tn−1+1+0.5∗0+0.5∗Tn 求出通项公式为： Tn=2^(n+1)−2 在n很大时，我们可以用下面的公式来近似估计： Tn≈1/ (p^(n+1))]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cookie，Session，Token]]></title>
    <url>%2F2019%2F08%2F13%2FCookie%EF%BC%8CSession%EF%BC%8CToken%2F</url>
    <content type="text"><![CDATA[我们知道HTTP是一种无状态的协议，为了分辨链接是谁发起的，需自己去解决这个问题。而且一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。导致有些情况下即使是同一个网站每打开一个页面也都要登录一下。而Session和Cookie就是为解决这个问题而提出来的两个机制。 同样的Token也能解决这个问题，它们之间只是一个说法的差别，其实做的事情都是一样的。 Cookie实际上是一小段的文本信息是访问某些网站后在本地存储的一些网站相关信息，下次访问时减少一些步骤。更准确的说法是：Cookie是服务器在本地机器上存储的小段文本信息并随每一个请求发送至同一服务器，是在客户端保持状态的方案。主要包括：名字，值，过期时间，路径和域。路径与域一起构成Cookie的作用范围。 会话Cookie和持久Cookie若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在浏览器的不同进程间共享。这种称为持久Cookie。 Session它存在服务器的一种用来存放用户数据的类HashTable结构，是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。 session的创建当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了sessionId，如果已包含则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId，sessionId的值是一个既不会重复，又不容易被找到规律以仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。 当服务器为用户建立一次会话，可以在用户授权成功时给他一个唯一的cookie。当一个用户提交了表单时，浏览器会将用户的SessionId自动附加在HTTP头信息中，服务器通过SessionId作为key，读写到对应的value，这就达到了保持会话信息的目的。 如果客户端禁用了cookie，通常有两种方法实现session而不依赖cookie：URL重写，就是把sessionId直接附加在URL路径的后面；表单隐藏字段。 Session共享对于多网站(同一父域不同子域)单服务器，我们需要解决的就是来自不同网站之间SessionId的共享。由于域名不同(aaa.test.com和bbb.test.com)，而SessionId又分别储存在各自的cookie中，因此服务器会认为对于两个子站的访问,是来自不同的会话。解决的方法是通过修改cookies的域名为父域名达到cookie共享的目的,从而实现SessionId的共享。带来的弊端就是，子站间的cookie信息也同时被共享了。 Cookie和Session的区别 Cookie和Session都是会话技术，Cookie是运行在客户端，Session是运行在服务器端。 Cookie有大小限制以及浏览器在存cookie的个数也有限制（单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie），Session是没有大小限制和服务器的内存大小有关。 Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。 Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。 Session的弊端以及Token的引入弊端： 服务器压力增大：通常session是存储在内存中的，每个用户通过认证之后都会将session数据保存在服务器的内存中，而当用户量增大时，服务器的压力增大。 CSRF跨站伪造请求攻击：session是基于cookie进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。 扩展性不强 token，注册登录-&gt;服务端将生成一个token，并将token与user加密生成一个密文-&gt;将token+user+密文数据 返回给浏览器-&gt;再次访问时传递token+user+密文数据，后台会再次使用token+user，生成新密文，与传递过来的密文比较，一致则正确。就是token从设计上必须通过get参数或者post参数提交，一般是不允许保存在cookies当中的，容易产生CSRF漏洞。 token与session的不同主要在①认证成功后，会对当前用户数据进行加密，生成一个加密字符串token，返还给客户端（服务器端并不进行保存） ②浏览器会将接收到的token值存储在Local Storage中，（通过js代码写入Local Storage，通过js获取，并不会像cookie一样自动携带） ③再次访问时服务器端对token值的处理：服务器对浏览器传来的token值进行解密，解密完成后进行用户数据的查询，如果查询成功，则通过认证，实现状态保持，所以，即时有了多台服务器，服务器也只是做了token的解密和用户数据的查询，它不需要在服务端去保留用户的认证信息或者会话信息，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利，解决了session扩展性的弊端。]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发七-开发注册功能]]></title>
    <url>%2F2019%2F08%2F11%2FSpringBoot%E5%BC%80%E5%8F%91%E4%B8%83-%E5%BC%80%E5%8F%91%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[需求介绍—开发注册功能首先访问注册页面—点击顶部的链接，打开注册页面 提交注册数据 通过表单提交数据 服务端验证账号是否存在，邮箱是否已经注册 服务端发送激活邮件 激活注册账号 点击邮件中的链接，访问服务端的激活服务 实现代码按着需求一个个完成。 首先访问注册页面只是打开页面，没有业务，访问数据库。只需要请求提交给Controller，然后调用模板，模板做出相应就可以了 12345678910111213package com.nowcoder.community.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class LoginController &#123; @RequestMapping(path = "/register", method = RequestMethod.GET) public String getRegisterpage() &#123; return "/site/register"; &#125;&#125; 然后就去处理对应的&quot;/site/register&quot;进行模板改造就可以了。同时你要在index.html改一下链接就好了。 效果如下： 再完成提交注册数据首先因为在这个过程中经常会到判断字符串，集合等常用的数据空值的情况，我们引入以下包 1234&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;&lt;/dependency&gt; 然后在application.properties配置我们网站的域名： 12# communitycommunity.path.domain=http://localhost:8080 然后我们写一个工具类CommunityUtil用来提供两个方法支持我们的注册功能，比方生成随机字符串这个方法 123456789101112131415161718192021222324package com.nowcoder.community.util;import com.alibaba.fastjson.JSONObject;import org.apache.commons.lang3.StringUtils;import org.springframework.util.DigestUtils;import java.util.HashMap;import java.util.Map;import java.util.UUID;public class CommunityUtil &#123; // 生成随机的字符串 public static String generateUUID() &#123; return UUID.randomUUID().toString().replace("-",""); &#125; // MD5加密 只能加密不能解密，采用加盐加密 public static String md5(String key) &#123; if(StringUtils.isBlank(key)) &#123; return null; &#125; return DigestUtils.md5DigestAsHex(key.getBytes()); &#125;&#125; 因为我们的注册是针对用户表的操作，所以逻辑应该写在UserService里面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.nowcoder.community.service;import com.nowcoder.community.dao.LoginTicketMapper;import com.nowcoder.community.dao.UserMapper;import com.nowcoder.community.entity.LoginTicket;import com.nowcoder.community.entity.User;import com.nowcoder.community.util.CommunityConstant;import com.nowcoder.community.util.CommunityUtil;import com.nowcoder.community.util.MailClient;import com.nowcoder.community.util.RedisKeyUtil;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import org.thymeleaf.TemplateEngine;import org.thymeleaf.context.Context;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.Random;import java.util.concurrent.TimeUnit;@Servicepublic class UserService implements CommunityConstant &#123; @Autowired private UserMapper userMapper; @Autowired private MailClient mailClient; @Autowired private TemplateEngine templateEngine; @Autowired private RedisTemplate redisTemplate; // 要把域名和项目名注入进来 @Value("$&#123;community.path.domain&#125;") private String domain; @Value("$&#123;server.servlet.context-path") private String contextPath; public User findUserById(int id) &#123; return userMapper.selectById(id); &#125; public Map&lt;String, Object&gt; register(User user) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 空值判断处理 if (user == null) &#123; throw new IllegalArgumentException("参数不能为空"); &#125; if (StringUtils.isBlank(user.getUsername())) &#123; map.put("usernameMsg","账号不能为空"); return map; &#125; if (StringUtils.isBlank(user.getPassword())) &#123; map.put("passwordMsg","密码不能为空"); return map; &#125; if (StringUtils.isBlank(user.getEmail())) &#123; map.put("emailMsg","邮箱不能为空"); return map; &#125; // 验证账号 User u = userMapper.selectByName(user.getUsername()); if (u != null) &#123; map.put("usernameMsg","该账号已存在"); return map; &#125; // 验证邮箱 u = userMapper.selectByEmail(user.getEmail()); if (u != null) &#123; map.put("emailMsg","该邮箱已经存在"); return map; &#125; // 注册用户，生成随机字符串利用MD5加密 user.setSalt(CommunityUtil.generateUUID().substring(0, 5)); user.setPassword(CommunityUtil.md5(user.getPassword()+user.getSalt())); user.setType(0); user.setStatus(0); user.setActivationCode(CommunityUtil.generateUUID()); user.setHeaderUrl(String.format("http://image.nowcoder.com/head/%dt.png", new Random().nextInt(1000))); user.setCreateTime(new Date()); userMapper.insertUser(user); // 激活邮件 Context context = new Context(); context.setVariable("email", user.getEmail()); // http://localhost:8080/community/activation/101/code String url = domain + contextPath + "/activation/" + user.getId() + "/" + user.getActivationCode(); context.setVariable("url",url); String content = templateEngine.process("/mail/activation",context); mailClient.sendMail(user.getEmail(), "激活账号", content); return map; &#125; public int avtivation(int userId, String code) &#123; User user = userMapper.selectById(userId); if (user.getStatus() == 1) &#123; return ACTIVATION_REPATE; &#125; else if (user.getActivationCode().equals(code)) &#123; userMapper.updateStatus(userId,1); clearCache(userId); return ACTIVATION_SUCCESS; &#125; else &#123; return ACTIVATION_FAILURE; &#125; &#125;&#125; 那么业务写完了，我们需要继续在LoginController里面写前后端交互 123456789101112131415161718192021222324252627282930313233package com.nowcoder.community.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class LoginController &#123; @Autowired private UserService userService; @RequestMapping(path = "/register", method = RequestMethod.GET) public String getRegisterpage() &#123; return "/site/register"; &#125; @RequestMapping(path = "/register", method = RequestMethod.POST) public String register(Model model, User user) &#123; // 调用业务层的代码返回数值 Map&lt;String, Object&gt; map = userService.register(user); if(map == null || map.isEmpty()) &#123; model.addAttribute("msg","注册成功，我们已经向您的邮箱发送了一封激活邮件，请尽快激活"); model.addAttribute("target","/index"); return "/site/operate-result"; &#125; else &#123; model.addAttribute("usernameMsg",map.get("usernameMsg")); model.addAttribute("passwordMsg",map.get("passwordMsg")); model.addAttribute("emailMsg",map.get("emailMsg")); return "/site/register"; &#125; &#125;&#125; 处理激活账号的事情那么我们应该在UserService里增加方法。但是因为这个情况有很多的情况，比方说激活成功，重复激活，激活失败，所以我们定义一些常量接口CommunityConstant。 123456789101112131415161718package com.nowcoder.community.util;public interface CommunityConstant &#123; /** * 激活成功 */ int ACTIVATION_SUCCESS = 0; /** * 重复激活 */ int ACTIVATION_REPATE = 1; /** * 激活失败 */ int ACTIVATION_FAILURE = 2;&#125; 那么现在写对应的方法了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.nowcoder.community.service;import com.nowcoder.community.dao.LoginTicketMapper;import com.nowcoder.community.dao.UserMapper;import com.nowcoder.community.entity.LoginTicket;import com.nowcoder.community.entity.User;import com.nowcoder.community.util.CommunityConstant;import com.nowcoder.community.util.CommunityUtil;import com.nowcoder.community.util.MailClient;import com.nowcoder.community.util.RedisKeyUtil;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import org.thymeleaf.TemplateEngine;import org.thymeleaf.context.Context;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.Random;import java.util.concurrent.TimeUnit;@Servicepublic class UserService implements CommunityConstant &#123; @Autowired private UserMapper userMapper; @Autowired private MailClient mailClient; @Autowired private TemplateEngine templateEngine; @Autowired private RedisTemplate redisTemplate; // 要把域名和项目名注入进来 @Value("$&#123;community.path.domain&#125;") private String domain; @Value("$&#123;server.servlet.context-path") private String contextPath; public int avtivation(int userId, String code) &#123; User user = userMapper.selectById(userId); if (user.getStatus() == 1) &#123; return ACTIVATION_REPATE; &#125; else if (user.getActivationCode().equals(code)) &#123; userMapper.updateStatus(userId,1); return ACTIVATION_SUCCESS; &#125; else &#123; return ACTIVATION_FAILURE; &#125; &#125;&#125; 那么方法写好了，需要在Controller调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.nowcoder.community.controller;import com.google.code.kaptcha.Producer;import com.nowcoder.community.entity.User;import com.nowcoder.community.service.UserService;import com.nowcoder.community.util.CommunityConstant;import com.nowcoder.community.util.CommunityUtil;import com.nowcoder.community.util.CookieUtil;import com.nowcoder.community.util.RedisKeyUtil;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import javax.imageio.ImageIO;import javax.mail.search.SearchTerm;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.awt.image.BufferedImage;import java.io.IOException;import java.io.OutputStream;import java.util.Map;import java.util.concurrent.TimeUnit;@Controllerpublic class LoginController implements CommunityConstant &#123; private static final Logger logger = LoggerFactory.getLogger(LoginController.class); @Autowired private UserService userService; @Autowired private Producer kaptchaProducer; @Autowired private RedisTemplate redisTemplate; @Value("$&#123;server.servlet.context-path&#125;") private String contextPath; @RequestMapping(path = "/register", method = RequestMethod.GET) public String getRegisterpage() &#123; return "/site/register"; &#125; @RequestMapping(path = "/login", method = RequestMethod.GET) public String getLoginpage() &#123; return "/site/login"; &#125; @RequestMapping(path = "/register", method = RequestMethod.POST) public String register(Model model, User user) &#123; Map&lt;String, Object&gt; map = userService.register(user); if(map == null || map.isEmpty()) &#123; model.addAttribute("msg","注册成功，我们已经向您的邮箱发送了一封激活邮件，请尽快激活"); model.addAttribute("target","/index"); return "/site/operate-result"; &#125; else &#123; model.addAttribute("usernameMsg",map.get("usernameMsg")); model.addAttribute("passwordMsg",map.get("passwordMsg")); model.addAttribute("emailMsg",map.get("emailMsg")); return "/site/register"; &#125; &#125; // http://localhost:8080/community/activation/101/code @RequestMapping(path = "/activation/&#123;userId&#125;/&#123;code&#125;", method = RequestMethod.GET) public String activation(Model model, @PathVariable("userId") int userId, @PathVariable("code") String code) &#123; int result = userService.avtivation(userId, code); if (result == ACTIVATION_SUCCESS) &#123; model.addAttribute("msg","激活成功，您的账号已经可以正常使用了"); model.addAttribute("target","/login"); &#125; else if (result == ACTIVATION_REPATE) &#123; model.addAttribute("msg","无效的操作，该账号已经激活过了"); model.addAttribute("target","/index"); &#125; else &#123; model.addAttribute("msg","激活失败，您提供的激活码不正确"); model.addAttribute("target","/index"); &#125; return "/site/operate-result"; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发六-发送邮件]]></title>
    <url>%2F2019%2F08%2F11%2FSpringBoot%E5%BC%80%E5%8F%91%E5%85%AD-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[需求介绍—发送邮件首先要进行邮箱设置，要启用客户端SMTP服务。 而且SpringBoot也给了JavaMailSender发送邮件。 代码实现首先你需要设置好邮箱，步骤百度一大堆，记住要配置一个授权码，是需要在后续进行配置的password。 然后就是正式的来写了。 首先引入一个jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 然后在application.properties进行邮箱的配置 12345678# MailPropertiesspring.mail.host=smtp.163.comspring.mail.port=465spring.mail.username=***@163.comspring.mail.password=***spring.mail.protocol=smtpsspring.mail.properties.smtp.auth=truespring.mail.properties.mail.smtp.ssl.enable=true 那么这个邮箱发送的话我们就建一个工具类MailClient，实现能够复用。 123456789101112131415161718192021222324252627282930313233343536373839package com.nowcoder.community.util;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.stereotype.Component;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;@Componentpublic class MailClient &#123; private static final Logger logger = LoggerFactory.getLogger(MailClient.class); @Autowired private JavaMailSender mailSender; // 每次发送的username，也就是我们之前配置的名称 @Value("$&#123;spring.mail.username&#125;") private String from; // 实现一个方法调用，需要告诉方法你发给谁，主题是什么，内容是什么 // 所以主要是要构建MimeMessage，在SpringBoot中给我们MimeMessageHelper这边帮助类帮助我们进行构建这个对象 public void sendMail(String to, String subject, String content) &#123; try &#123; MimeMessage message = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); // 加了true，支持发送html邮件 helper.setText(content, true); mailSender.send(helper.getMimeMessage()); &#125; catch (MessagingException e) &#123; logger.error("发送邮件失败:" + e.getMessage()); &#125; &#125;&#125; 那么我们写一个测试类测试一下MailTests： 12345678910111213141516171819202122232425262728293031323334353637383940package com.nowcoder.community;import com.nowcoder.community.util.MailClient;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringRunner;import org.thymeleaf.TemplateEngine;import org.thymeleaf.context.Context;@RunWith(SpringRunner.class)@SpringBootTest@ContextConfiguration(classes = CommunityApplication.class)public class MailTests &#123; @Autowired private MailClient mailClient; // 主动的调用thymeleaf模板引擎 @Autowired private TemplateEngine templateEngine; @Test public void testTextMail() &#123; mailClient.sendMail("838567391@qq.com","test","Welcome"); &#125; // 你发送html模板的话，需要利用thymeleaf模板，我在下面给了一个demo， @Test public void testHtmlMail() &#123; Context context = new Context(); // 给模板传参数，要和demo里面申明的一样 context.setVariable("username","sunday"); // 得到内容，把context传到demo里面 String content = templateEngine.process("/mail/demo",context); System.out.println(content); mailClient.sendMail("838567391@qq.com","HtmlTest",content); &#125;&#125; 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;邮件实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;欢迎你，&lt;span style="color:red;" th:text="$&#123;username&#125;"&gt;&lt;/span&gt;!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这样的话就能进行邮件发送了，如果你发给qq邮箱的话要注意邮件一般是发送到了垃圾箱里面。]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发五-社区首页开发]]></title>
    <url>%2F2019%2F08%2F11%2FSpringBoot%E5%BC%80%E5%8F%91%E4%BA%94%2F</url>
    <content type="text"><![CDATA[需求介绍—社区首页根据之前的学习，我们一般都是先按照DAO-&gt;Service-&gt;Controller这个顺序去开发 分布实现： 开发社区首页，显示前十个帖子。 开发分页组件，分页显示所有的帖子 代码实现首先我们要知道贴子我们是放在discuss_post这个表里面，所以我们的操作都是根据这个表来操作。 那第一步来写一下DiscussPost实体类对应这个表里面的字段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.nowcoder.community.entity;import java.util.Date;public class DiscussPost &#123; private int id; private int userId; private String title; private String content; private int type; private int status; private Date createTime; private int commentCount; private double score; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getUserId() &#123; return userId; &#125; public void setUserId(int userId) &#123; this.userId = userId; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public int getType() &#123; return type; &#125; public void setType(int type) &#123; this.type = type; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; public int getCommentCount() &#123; return commentCount; &#125; public void setCommentCount(int commentCount) &#123; this.commentCount = commentCount; &#125; public double getScore() &#123; return score; &#125; public void setScore(double score) &#123; this.score = score; &#125; @Override public String toString() &#123; return "DiscussPost&#123;" + "id=" + id + ", userId=" + userId + ", title='" + title + '\'' + ", content='" + content + '\'' + ", type=" + type + ", status=" + status + ", createTime=" + createTime + ", commentCount=" + commentCount + ", score=" + score + '&#125;'; &#125;&#125; 那么我们对应去开发DiscussPostMapper，完成对应对于这个数据库操作的函数声明。 12345678910111213141516171819202122package com.nowcoder.community.dao;import com.nowcoder.community.entity.DiscussPost;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import java.util.List;@Mapperpublic interface DiscussPostMapper &#123; /* 查到的事多个帖子，所以是集合，这个userId是为了开发我的主页的时候才需要，但是首页的时候就不传， 得到的是0，那么对应的就是一个动态的sql*/ List&lt;DiscussPost&gt; selectDiscussPosts(int userId, int offset, int limit); // @Param 用来为参数取别名 //如果需要动态的拼一个条件，在&lt;if&gt;里面使用，并且这个方法有且只有一个参数，这个参数前面必须取别名 // 这个userId和上面是一样的功能 int selectDiscussPostRows(@Param("userId") int userId); int insertDiscussPost(DiscussPost discussPost);&#125; 那么函数声明了，就要去discusspost-mapper.xml文件里面写实现的了 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.nowcoder.community.dao.DiscussPostMapper"&gt; &lt;sql id="selectFields"&gt; id, user_id, title, content, type, status, create_time, comment_count, score &lt;/sql&gt; &lt;sql id="insertFields"&gt; user_id, title, content, type, status, create_time, comment_count, score &lt;/sql&gt; // 如果返回的类型不是Java自带的类型的话，就需要加resultType，表示返回类型 &lt;select id="selectDiscussPosts" resultType="DiscussPost"&gt; select &lt;include refid="selectFields"&gt;&lt;/include&gt; from discuss_post where status != 2 &lt;if test="userId!=0"&gt; and user_id = #&#123;userId&#125; &lt;/if&gt; order by type desc, create_time desc limit #&#123;offset&#125;, #&#123;limit&#125; &lt;/select&gt; &lt;select id="selectDiscussPostRows" resultType="int"&gt; select count(id) from discuss_post where status != 2 &lt;if test="userId!=0"&gt; and user_id = #&#123;userId&#125; &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; 至此数据访问层就开发完了，那么要继续开发业务组件DiscussPostService。 12345678910111213141516171819202122232425package com.nowcoder.community.service;import com.nowcoder.community.dao.DiscussPostMapper;import com.nowcoder.community.entity.DiscussPost;import com.nowcoder.community.util.SensitiveFilter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.util.HtmlUtils;import java.util.List;@Servicepublic class DiscussPostService &#123; @Autowired private DiscussPostMapper discussPostMapper; // 查询帖子 public List&lt;DiscussPost&gt; findDiscussPosts(int userId, int offset, int limit) &#123; return discussPostMapper.selectDiscussPosts(userId, offset, limit); &#125; // 查询行数的方法 public int findDiscussPostRows(int userId) &#123; return discussPostMapper.selectDiscussPostRows(userId); &#125;&#125; 但是现在有个问题就是在平时的时候我们在页面上显示的肯定都是显示username而不是userId所以我们需要写个方法把两者关联起来，因为这个只涉及到User那么我们可以对写UserService对其进行操作 1234567891011121314151617181920package com.nowcoder.community.service;import com.nowcoder.community.dao.LoginTicketMapper;import com.nowcoder.community.dao.UserMapper;import com.nowcoder.community.entity.User;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.Random;import java.util.concurrent.TimeUnit;@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User findUserById(int id) &#123; return userMapper.selectById(id);&#125; 那么至此业务层的逻辑我们就写完了，现在就开始写表现层DiscussController： 我们先查前10条的帖子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.nowcoder.community.controller;import com.nowcoder.community.entity.DiscussPost;import com.nowcoder.community.entity.Page;import com.nowcoder.community.entity.User;import com.nowcoder.community.service.DiscussPostService;import com.nowcoder.community.service.LikeService;import com.nowcoder.community.service.UserService;import com.nowcoder.community.util.CommunityConstant;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;// 初始化界面以及分页功能点实现@Controllerpublic class HomeController implements CommunityConstant &#123; @Autowired private DiscussPostService discussPostService; @Autowired private UserService userService; @RequestMapping(path = "/index", method = RequestMethod.GET) public String getIndexPage(Model model) &#123; // 方法调用之前，SpringMVC会自动实例化Model和Page，并将Page注入到Model中 // 所以，在thymeleaf中可以直接访问Page对象中的数据。 List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(0,0,10); // 把上面这个集合遍历一遍，但是它们的数据是不完整的，比方说我们查到的只是id不是userId List&lt;Map&lt;String, Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;(); if (list != null) &#123; for(DiscussPost post : list) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("post", post); User user = userService.findUserById(post.getUserId()); map.put("user", user); discussPosts.add(map); &#125; &#125; // 把值传到这个模板里面 model.addAttribute("discussPosts", discussPosts); return "/index"; &#125;&#125; 然后就是处理对应的页面，我这里就不写了，基本的功能点在这了，运行之后可以查到表里面的前十条数据如下图所示： 现在就继续完善分页的功能，那么现在客户端要给服务端除了之前传递的数据还要传递现在是第几页这些其他的信息，服务端也需要根据传来的信息确定这个页码是否超过了能有的最大的页码（可以根据数据库中帖子的数量很分页每页显示多少条来计算得到），因为这个数据传递的很频繁所以我们单独写个组件来实现。 那么我们先实现Page来确定分页的一些条件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.nowcoder.community.entity;/** * 封装分页相关的信息 */public class Page &#123; // 页面传给服务端的数据 // 当前页码 private int current = 1; // 显示上限 private int limit = 10; // 服务端查到的 // 数据总数（用于计算总页数） private int rows; // 查询路径(用于复用分页链接） private String path; public int getCurrent() &#123; return current; &#125; public void setCurrent(int current) &#123; if (current &gt;= 1) &#123; this.current = current; &#125; &#125; public int getLimit() &#123; return limit; &#125; public void setLimit(int limit) &#123; if (limit &gt;= 1 &amp;&amp; limit &lt;= 100) &#123; this.limit = limit; &#125; &#125; public int getRows() &#123; return rows; &#125; public void setRows(int rows) &#123; if (rows &gt;= 0) &#123; this.rows = rows; &#125; &#125; public String getPath() &#123; return path; &#125; public void setPath(String path) &#123; this.path = path; &#125; /** * 获取当前页的起始行 * @return */ public int getOffset() &#123; // current * limit - limit return (current - 1) * limit; &#125; /** * 获取总页数 * @return */ public int getTotal() &#123; // rows / limit if (rows % limit == 0) &#123; return rows / limit; &#125; else &#123; return rows / limit + 1; &#125; &#125; /** * 获取起始页码 */ public int getFrom() &#123; int from = current - 2; return from &lt; 1 ? 1 : from; &#125; /** * 获取结束页码 * @return */ public int getTo() &#123; int to = current + 2; return to &gt; getTotal() ? getTotal() : to; &#125;&#125; 那么要改造HomeController来实现分页： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.nowcoder.community.controller;import com.nowcoder.community.entity.DiscussPost;import com.nowcoder.community.entity.Page;import com.nowcoder.community.entity.User;import com.nowcoder.community.service.DiscussPostService;import com.nowcoder.community.service.LikeService;import com.nowcoder.community.service.UserService;import com.nowcoder.community.util.CommunityConstant;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;// 初始化界面以及分页功能点实现@Controllerpublic class HomeController implements CommunityConstant &#123; @Autowired private DiscussPostService discussPostService; @Autowired private UserService userService; @RequestMapping(path = "/index", method = RequestMethod.GET) public String getIndexPage(Model model, Page page) &#123; // 方法调用之前，SpringMVC会自动实例化Model和Page，并将Page注入到Model中 // 所以，在thymeleaf中可以直接访问Page对象中的数据。 page.setRows(discussPostService.findDiscussPostRows(0)); page.setPath("/index"); List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(0,page.getOffset(),page.getLimit()); // 把上面这个集合遍历一遍，但是它们的数据是不完整的，比方说我们查到的只是id不是userId List&lt;Map&lt;String, Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;(); if (list != null) &#123; for(DiscussPost post : list) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("post", post); User user = userService.findUserById(post.getUserId()); map.put("user", user); discussPosts.add(map); &#125; &#125; // 把值传到这个模板里面 model.addAttribute("discussPosts", discussPosts); return "/index"; &#125;&#125; 那么还要在页面上动态的配置好对应的链接 123456789101112131415161718&lt;nav class="mt-5" th:if="$&#123;page.rows&gt;0&#125;" th:fragment="pagination"&gt; &lt;ul class="pagination justify-content-center"&gt; &lt;li class="page-item"&gt; &lt;a class="page-link" th:href="@&#123;$&#123;page.path&#125;(current=1)&#125;"&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li th:class="|page-item $&#123;page.current==1?'disabled':''&#125;|"&gt; &lt;a class="page-link" th:href="@&#123;$&#123;page.path&#125;(current=$&#123;page.current-1&#125;)&#125;"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li th:class="|page-item $&#123;i==page.current?'active':''&#125;|" th:each="i:$&#123;#numbers.sequence(page.from,page.to)&#125;"&gt; &lt;a class="page-link" href="#" th:text="$&#123;i&#125;"&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li th:class="|page-item $&#123;page.current==page.total?'disabled':''&#125;|"&gt; &lt;a class="page-link" th:href="@&#123;$&#123;page.path&#125;(current=$&#123;page.current+1&#125;)&#125;"&gt;下一页&lt;/a&gt; &lt;/li&gt; &lt;li class="page-item"&gt; &lt;a class="page-link" th:href="@&#123;$&#123;page.path&#125;(current=$&#123;page.total&#125;)&#125;"&gt;末页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; 那么至此分页的功能点就写完了，经测试功能正常，首页能正常测试]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS协议]]></title>
    <url>%2F2019%2F08%2F09%2FDNS%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[什么是DNS域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们使用的机器名字转换成为IP地址。主要功能就是域名转换为IP地址。 因特网的域名空间： 域名服务器如果采用上述的树状结构，每一个节点都采用一个域名服务器，这样会使得域名服务器的数量太多，使域名服务器系统的运行效率降低。所以在DNS中，采用划分区的方法来解决。 一个服务器所负责管辖(或有权限)的范围叫做区zone。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机到域名IP地址的映射。总之，DNS服务器的管辖范围不是以“域”为单位，而是以“区”为单位。区是DNS服务器实际管辖的范围。区&lt;= 域。 一般是有着：本地域名服务器 -&gt; 权限域名服务器 -&gt; 顶级域名服务器 -&gt; 根域名服务器（从小到大） 域名解析过程先看两个概念： 递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机 迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。 具体的流程可描述如下： 主机10.74.36.90先向本地域名服务器10.74.1.11进行递归查询 本地域名服务器采用迭代查询，向一个根域名服务器进行查询 根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器dns.me的IP地址 本地域名服务器向顶级域名服务器 dns.me进行查询 顶级域名服务器me告诉本地域名服务器，下一步查询权限服务器dns.jocent.me 的IP地址 本地域名服务器向权限服务器 ```dns.jocent.me`进行查询 权限服务器 dns.jocent.me告诉本地域名服务器所查询的主机的IP地址 本地域名服务器最后把查询结果告诉 10.74.36.90。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PDD提前批一面]]></title>
    <url>%2F2019%2F08%2F08%2FPDD%E6%8F%90%E5%89%8D%E6%89%B9%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[PDD一面面经：42分钟 首先问了一下在实习，实习是主要干啥了。 简单介绍一下自己。 参加的程序设计竞赛，数学建模竞赛你觉得对你的意义在哪 你以后的发展设想 问了项目如果要部署在哪个环境下：Linux。其实根本没部署 Linux环境下上线一个服务，如果CPU占用太满了，怎么排查。用ps命令鬼扯了一下 怎么查看内存占用。用top命令扯了一下。 说到内存泄漏，问有没有碰到，内存泄漏怎么解决？我说了GC 说了一下怎么判断对象是否存活，介绍了一下GC的算法 问了一下c++每次都要new，delete，但是经常会忘了delete，那么有什么方式解决这个问题？我觉得比较像IOC的原理，就说了用容器去管理对象，我们在外面不用new，只需要从容器里拿，容器帮助我们解决new，delete。 生活场景下什么时候用UDP。 介绍一下TCP，说一下三次连接的过程，为什么不是二次，四次挥手为什么不是四次？ 有没有写过这个连接，说了一下课设写过一个简单的聊天服务器，不过就很简单的你发送我回答那种 问了一个我的项目是什么。说了一下是跟着视频写的，但是自己做了一些优化，感觉凉凉。 说一下mysql和redis的区别，感觉回答的不好 redis为什么不能代替mysql，如果redis能存大量的数据呢为什么不能？说到了事务 问我项目中哪里用到了，woc，一紧张给忘了哪用了 又扯了一下实习的工作，说下自己对于这个的理解 有没有什么想我的？问了一下工作地点 因为感觉自己面得不好问了一下能不能给个评价，好让自己继续努力.。面试官说总体还行就没，还说了个啥不记得了，感觉是没有了。]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存泄漏和内存溢出]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[内存泄漏和内存溢出内存溢出简单地说内存溢出就是指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。 常见的内存溢出创建的对象太多，在进行垃圾回收之前对象数量达到了最大堆的容量限制造成堆溢出；常量池溢出；虚拟机栈和本地方法栈溢出 内存泄漏内存泄漏指程序运行过程中分配内存给临时变量，用完之后却没有被 GC 回收，始终占用着内存，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。 常见的内存泄露静态集合类（如 HashMap，Vector）引起的内存泄漏；修改 HashSet 中对象的参数值，且参数是计算哈希值的字段；监听器；各种连接（如数据库连接）。 避免内存泄漏的几点建议： 尽早释放无用对象的引用。 避免在循环中创建对象。 使用字符串处理时避免使用String，应使用StringBuffer。 尽量少使用静态变量，因为静态变量存放在永久代，基本不参与垃圾回收。]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阻塞队列以及生产者消费者的实现]]></title>
    <url>%2F2019%2F08%2F07%2F%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[阻塞队列它是Java util.concurrent包下重要的数据结构，BlockingQueue提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。 Java中的阻塞队列接口BlockingQueue继承自Queue接口： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123; //将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量） //在成功时返回 true，如果此队列已满，则抛IllegalStateException。 boolean add(E e); //将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量） // 将指定的元素插入此队列的尾部，如果该队列已满， //则在到达指定的等待时间之前等待可用的空间,该方法可中断 boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; //将指定的元素插入此队列的尾部，如果该队列已满，则一直等到（阻塞）。 void put(E e) throws InterruptedException; //获取并移除此队列的头部，如果没有元素则等待（阻塞）， //直到有元素将唤醒等待线程执行该操作 E take() throws InterruptedException; //获取并移除此队列的头部，在指定的等待时间前一直等到获取元素， //超过时间方法将结束 E poll(long timeout, TimeUnit unit) throws InterruptedException; //从此队列中移除指定元素的单个实例（如果存在）。 boolean remove(Object o); &#125;//除了上述方法还有继承自Queue接口的方法 //获取但不移除此队列的头元素,没有则跑异常NoSuchElementException E element(); //获取但不移除此队列的头；如果此队列为空，则返回 null。 E peek(); //获取并移除此队列的头，如果此队列为空，则返回 null。 E poll();上述方法呢，对应的操作如果没有办法执行，也会报不一样的错误。主要有抛异常，特定值，阻塞，超时这四种，可以看下面的介绍/*插入方法：add(E e) : 添加成功返回true，失败抛IllegalStateException异常offer(E e) : 成功返回 true，如果此队列已满，则返回 false。put(E e) :将元素插入此队列的尾部，如果该队列已满，则一直阻塞删除方法:remove(Object o) :移除指定元素,成功返回true，失败返回falsepoll() : 获取并移除此队列的头元素，若队列为空，则返回 nulltake()：获取并移除此队列头元素，若没有元素则一直阻塞。检查方法element() ：获取但不移除此队列的头元素，没有元素则抛异常peek() :获取但不移除此队列的头；若队列为空，则返回 null。*/ 阻塞队列的对元素的增删查操作主要就是上述的这些方法。 阻塞队列的实现类 ArrayBlockingQueue：ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。而且ArrayBlockingQueue中的元素存在公平访问与非公平访问的区别 DelayQueue：DelayQueue对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed接口。 LinkedBlockingQueue：LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。 PriorityBlockingQueue：PriorityBlockingQueue是一个无界的并发队列。它使用了和类 java.util.PriorityQueue一样的排序规则。你无法向这个队列中插入 null值。所有插入到 PriorityBlockingQueue的元素必须实现java.lang.Comparable接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。 SynchronousQueue：SynchronousQueue是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。 ArrayBlockingQueue底层分析ArrayBlockingQueue内部的阻塞队列是通过重入锁ReenterLock和Condition条件队列实现的。 先看下内部成员变量 1234567891011121314151617181920212223242526public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; /** 存储数据的数组 */ final Object[] items; /**获取数据的索引，主要用于take，poll，peek，remove方法 */ int takeIndex; /**添加数据的索引，主要用于 put, offer, or add 方法*/ int putIndex; /** 队列元素的个数 */ int count; /** 控制并非访问的锁 */ final ReentrantLock lock; /**notEmpty条件对象，用于通知take方法队列已有元素，可执行获取操作 */ private final Condition notEmpty; /**notFull条件对象，用于通知put方法队列未满，可执行添加操作 */ private final Condition notFull; // 迭代器 transient Itrs itrs = null;&#125; ArrayBlockingQueue内部是通过数组对象items来存储所有的数据，通过一个ReentrantLock来同时控制添加线程与移除线程的并发访问。对于notEmpty条件对象则是用于存放等待或唤醒调用take方法的线程，告诉他们队列已有元素，可以执行获取操作。同理notFull条件对象是用于等待或唤醒调用put方法的线程，告诉它们，队列未满，可以执行添加元素的操作。takeIndex代表的是下一个方法(take，poll，peek，remove)被调用时获取数组元素的索引，putIndex则代表下一个方法（put, offer, or add）被调用时元素添加到数组中的索引。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//add方法实现，间接调用了offer(e)public boolean add(E e) &#123; if (offer(e)) return true; else throw new IllegalStateException("Queue full"); &#125;//offer方法public boolean offer(E e) &#123; checkNotNull(e);//检查元素是否为null final ReentrantLock lock = this.lock; lock.lock();//加锁 try &#123; if (count == items.length)//判断队列是否满 return false; else &#123; enqueue(e);//添加元素到队列 return true; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;//入队操作private void enqueue(E x) &#123; //获取当前数组 final Object[] items = this.items; //通过putIndex索引对数组进行赋值 items[putIndex] = x; //索引自增，如果已是最后一个位置，重新设置 putIndex = 0; if (++putIndex == items.length) putIndex = 0; count++;//队列中元素数量加1 //唤醒调用take()方法的线程，执行元素获取操作。 notEmpty.signal();&#125;//put方法，阻塞时可中断，put方法是一个阻塞的方法，如果队列元素已满，那么当前线程将会被notFull条件对象挂起加到等待队列中，直到队列有空档才会唤醒执行添加操作。但如果队列没有满，那么就直接调用enqueue(e)方法将元素加入到数组队列中。 public void put(E e) throws InterruptedException &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly();//该方法可中断 try &#123; //当队列元素个数与数组长度相等时，无法添加元素 while (count == items.length) //将当前调用线程挂起，添加到notFull条件队列中等待唤醒 notFull.await(); enqueue(e);//如果队列没有满直接添加。。 &#125; finally &#123; lock.unlock(); &#125; &#125;// 其余方法分析，可以看 https://blog.csdn.net/javazejian/article/details/77410889 LinkedBlockingQueue和ArrayBlockingQueue差异 队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。 数据存储容器不同，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。 由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响。 两者的实现队列添加或移除的锁不一样，ArrayBlockingQueue实现的队列中的锁是没有分离的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。 消费者生产者模式生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。 阻塞队列的最长使用的例子就是生产者消费者模式,也是各种实现生产者消费者模式方式中首选的方式。但是消费者生产者不一定非要用阻塞队列实现，可以看其实现的几种方式。 参考：消费者生产者模式实现 wait()和notify()方法的实现这也是最简单最基础的实现，缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Test1 &#123; private static Integer count = 0; private static final Integer FULL = 10; private static String LOCK = "lock"; public static void main(String[] args) &#123; Test1 test1 = new Test1(); new Thread(test1.new Producer()).start(); new Thread(test1.new Consumer()).start(); new Thread(test1.new Producer()).start(); new Thread(test1.new Consumer()).start(); new Thread(test1.new Producer()).start(); new Thread(test1.new Consumer()).start(); new Thread(test1.new Producer()).start(); new Thread(test1.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (LOCK) &#123; while (count == FULL) &#123; try &#123; LOCK.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count++; System.out.println(Thread.currentThread().getName() + "生产者生产，目前总共有" + count); LOCK.notifyAll(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (LOCK) &#123; while (count == 0) &#123; try &#123; LOCK.wait(); &#125; catch (Exception e) &#123; &#125; &#125; count--; System.out.println(Thread.currentThread().getName() + "消费者消费，目前总共有" + count); LOCK.notifyAll(); &#125; &#125; &#125; &#125;&#125; 可重入锁ReentrantLock的实现通过对lock的lock()方法和unlock()方法实现了对锁的显示控制， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Test2 &#123; private static Integer count = 0; private static final Integer FULL = 10; //创建一个锁对象 private Lock lock = new ReentrantLock(); //创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空 private final Condition notFull = lock.newCondition(); private final Condition notEmpty = lock.newCondition(); public static void main(String[] args) &#123; Test2 test2 = new Test2(); new Thread(test2.new Producer()).start(); new Thread(test2.new Consumer()).start(); new Thread(test2.new Producer()).start(); new Thread(test2.new Consumer()).start(); new Thread(test2.new Producer()).start(); new Thread(test2.new Consumer()).start(); new Thread(test2.new Producer()).start(); new Thread(test2.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //获取锁 lock.lock(); try &#123; while (count == FULL) &#123; try &#123; notFull.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; count++; System.out.println(Thread.currentThread().getName() + "生产者生产，目前总共有" + count); //唤醒消费者 notEmpty.signal(); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; lock.lock(); try &#123; while (count == 0) &#123; try &#123; notEmpty.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count--; System.out.println(Thread.currentThread().getName() + "消费者消费，目前总共有" + count); notFull.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; &#125;&#125; 阻塞队列BlockingQueue的实现使用take()和put()方法，这里生产者和生产者，消费者和消费者之间不存在同步，所以会出现连续生成和连续消费的现象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;public class Test3 &#123; private static Integer count = 0; //创建一个阻塞队列 final BlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(10); public static void main(String[] args) &#123; Test3 test3 = new Test3(); new Thread(test3.new Producer()).start(); new Thread(test3.new Consumer()).start(); new Thread(test3.new Producer()).start(); new Thread(test3.new Consumer()).start(); new Thread(test3.new Producer()).start(); new Thread(test3.new Consumer()).start(); new Thread(test3.new Producer()).start(); new Thread(test3.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; blockingQueue.put(1); count++; System.out.println(Thread.currentThread().getName() + "生产者生产，目前总共有" + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; try &#123; blockingQueue.take(); count--; System.out.println(Thread.currentThread().getName() + "消费者消费，目前总共有" + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
      <tags>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程安全]]></title>
    <url>%2F2019%2F08%2F06%2FJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[什么是线程安全线程安全可以简单理解为一个方法或者一个实例可以在多线程环境中使用而不会出现问题。多说一点就是线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是“脏”数据。 比方说ArrayList是非线程安全的，Vector是线程安全的；HashMap是非线程安全的，HashVector是线程安全的；StringBuilder是非线程安全的，StringBuffer是线程安全的。 产生线程不安全的原因在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。 记住引用不是线程安全的，即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的。 Java线程安全的类 通过synchronized 关键字给方法加上内置锁来实现线程安全Timer，TimerTask，Vector，Stack，HashTable，StringBuffer 原子类Atomicxxx—包装类的线程安全类如AtomicLong，AtomicInteger等等 BlockingQueue 和BlockingDeque ThreadPoolExecutorThreadPoolExecutor也是使用了ReentrantLock显式加锁同步 锁的种类和区别公平锁/非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。 对于 Java ReentrantLock 而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。对于 Synchronized 而言，也是一种非公平锁。由于其并不像 ReentrantLock 是通过 AQS 的来实现线程调度，所以并没有任何办法使其变成公平锁。 可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。 Java ReentrantLock以及Synchronized都是可重入锁 独享锁/共享锁独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。 对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。Synchronized是独享锁。 乐观锁/悲观锁乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。 从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。 偏向锁/轻量级锁/重量级锁这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。 自旋锁在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。 synchronized三种应用方式 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 作用于实例方法的时候，会出现new了两个不同的实例对象，这也就意味着存在着两个不同的实例对象锁，这个时候各自的进程使用的就是不同的锁就不能保证线程的安全，这个时候就是用Synchronized作用于静态方法，因为锁对象是当前类的class对象。 Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象（存在于每个Java对象的对象头）实现， 无论是显式同步(有明确的 monitorenter和 monitorexit指令,即同步代码块)还是隐式同步都是如此。 synchronized代码块底层原理同步语句块的实现使用的是monitorenter 和 monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor的持有权，当 objectref的monitor的进入计数器为 0，那线程可以成功取得monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有monitor 。 synchronized方法底层原理方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。 Java虚拟机对synchronized的优化锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，把我们刚才看的锁的进一步看一下在synchronized是怎么应用的。 偏向锁偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。 轻量级锁倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段。 自旋锁轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。 锁消除消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间 ReentrantLockReentrantLock是基于AQS实现的，AQS的基础又是CAS。 CASCAS设计到三个操作数：V 内存地址存放的实际值；O预期的值（旧值）；N更新的新值。当V和O相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值O就是目前来说最新的值了，自然而然可以将新值N赋值给V。反之，V和O不相同，表明该值已经被其他线程改过了则该旧值O不是最新版本的值了，所以不能将新值N赋给V，返回V即可。所以多个线程同时访问的时候就只会有一个线程成功。 实例理解一下：比方说在内存地址V中，存放着值为10的变量，此时此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。线程1开始提交更新，首先进行A和地址V的实际值比较，发现A不等于V的实际值，提交失败。线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。线程1进行SWAP，把地址V的值替换为B，也就是12。 CAS 原理CAS 底层使用 JNI 调用 C 代码实现的，最终是通过 Unsafe_CompareAndSwapInt 这个函数调用了 Atomic::cmpxchg(x, addr, e) 其中 x 是即将更新的值，参数 e 是原内存的值。 最后 JDK 通过 CPU 的 cmpxchgl 指令的支持，实现 AtomicInteger 的 CAS操作的原子性。 CSA 的问题 ABA 问题：CAS 需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是 CAS 的 ABA 问题。 常见的解决思路是使用版本号。 循环时间长开销大：如果 CAS 不成功，则会原地自旋，如果长时间自旋会给 CPU 带来非常大的执行开销 实现原理AQS是基于FIFO队列的实现，因此必然存在一个个节点，Node就是一个节点。Node里面有： AQS的变量和方法一般重点掌握tryAcquire(int arg)和tryRelease(int arg)两个方法，因为一般这两个函数是会被重写的。 ReentrantLock类中有三个内部类，Sync是另外两个类的父类，ReentrantLock的公平锁和非公平锁的实现就是通过Sync的两个子类NonfairSync和FairSync来完成的。默认ReentrantLock实现的是非公平锁，非公平锁虽然失去了公平但是获得了更好地吞吐量。 非公平锁的lock方法：12345678final void lock() &#123;// 如果锁没有被任何线程锁定且加锁成功则设定当前线程为锁的拥有者 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else// 否则执行acquire方法传入参数为1 acquire(1);&#125; 关键的逻辑在acquire也就是当有线程发生竞争的时候： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//首先调用tryAcquire方法来再一次尝试获取锁，如果成功则返回，否则执行acquireQueued方法public final void acquire(int arg) &#123;if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; //非公平锁的获取方法final boolean nonfairTryAcquire(int acquires) &#123; //首先获取当前线程 final Thread current = Thread.currentThread(); //获取锁的状态 int c = getState(); //如果为0则继续通过原子操作设置state，如果成功则设置获取锁的线程为当前线程并返回成功 if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //否则锁已经被某个线程获取到，判断是否为当前线程 else if (current == getExclusiveOwnerThread()) &#123; //如果是当前线程则将state+1，可以看出锁的可重入性就体现在这里 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); //设置状态，并返回成功 setState(nextc); return true; &#125; //否则该锁已经被其他线程占用，因此后面需要考虑阻塞该线程。 return false;&#125; //新增等待线程节点 private Node addWaiter(Node mode) &#123; //使用当前线程构造出新的节点 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure //第一次tail肯定为空则走enq(node)入队列 Node pred = tail; if (pred != null) &#123; //非第一次竞争 node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; //入队列操作private Node enq(final Node node) &#123; //乐观等待 for (;;) &#123; //第一次tail仍然为空 Node t = tail; if (t == null) &#123; // Must initialize //当第一次产生竞争的时候初始化虚拟头结点，节省空间 Node h = new Node(); // Dummy header //头结点h的下一个节点指向前面新建的节点 h.next = node; //双向链表 node.prev = h; //原子操作设置头结点，如果成功则尾节点为前面新建的节点，否则循环直到成功，如果同一时刻有其他线程set成功，则可能走else分支 if (compareAndSetHead(h)) &#123; //返回头结点 tail = node; return h; &#125; &#125; else &#123; //否则 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 非公平锁的unlock方法走AQS的release 123public void unlock() &#123; sync.release(1);&#125; 先调用Sync的tryRelease尝试释放锁： 123456789101112131415161718protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; //只有持有锁的线程才能进行释放动作 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; //锁被释放，独占线程设置为null setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125;/*首先，只有当c==0的时候才会让free=true，这和上面一个线程多次调用lock方法累加state是对应的，调用了多少次的lock()方法自然必须调用同样次数的unlock()方法才行，这样才把一个锁给全部解开。当一条线程对同一个ReentrantLock全部解锁之后，AQS的state自然就是0了，AbstractOwnableSynchronizer的exclusiveOwnerThread将被设置为null，这样就表示没有线程占有锁，方法返回true。代码继续往下走，上面的release方法的第四行，h不为null成立，h的waitStatus为-1，不等于0也成立，所以走第5行的unparkSuccessor方法：*/ 唤醒node节点的后继，保证整个FIFO队列减少一个Node（参考https://www.cnblogs.com/xrq730/p/4979021.html） 1234567891011121314151617private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) //如果当前节点为SIGNAL则修改为0 compareAndSetWaitStatus(node, ws, 0); // 若后续节点为空或已被cancel，则从尾部开始找到队列中第一个waitStatus&lt;=0，即未被cancel的节点 Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; //如果找到这么一个节点它的状态&lt;=0则唤醒该节点中的线程 if (s != null) LockSupport.unpark(s.thread); &#125; synchronized和ReentrantLock的异同同： 它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的 异： 对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。 使用Synchronized。如果Thread1不释放，Thread2将一直等待，不能被中断；使用ReentrantLock。如果Thread1不释放，Thread2等待了很长时间以后，可以中断等待，转而去做别的事情。 Synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁。 锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。Synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件。但如果要和多于一个的条件关联的时候，就不得不额外添加一个锁。 Synchronized修饰静态方法和成员方法的区别Synchronized 修饰静态方法以及同步代码块的 Synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。Synchronized 修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。 对应的问题：那我现在有一个父类synchronized修饰非static方法和两个子类，现在两个子类调用这个方法会发生竞争吗？ 加载非 static 不会，加载 static 会，非 static 相当于对象锁吧，两个子类就是两个对象，static 相当于类锁]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[B树和B+树]]></title>
    <url>%2F2019%2F08%2F05%2FB%E6%A0%91%E5%92%8CB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉排序树它的定义如下：若左子树不空，则左子树上所有节点的值均小于它的根节点的值若右子树不空，则右子树上所有节点的值均大于它的根节点的值，它的左、右子树也分别为二叉排序数（递归生成），如下图： 这样的数据结构能够帮助我们在O(logn) 的时间复杂度找到一个树，但是有个情况是如果这颗树的结构出现问题，出现一条支路非常长的情况下，就会出现失衡这种情况。所以因此延伸出平衡二叉树。而B树和B+树是一个平衡的多叉查找树。 B树m阶平衡多叉查找树，样例如下： 性质如下： 根结点至少有两个子女（如果根节点是叶子节点，那么这颗树只有根节点这一个结点）； 每个结点的值的个数为 1 &lt;= n &lt; m； 所有的叶子结点都位于同一层； 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子。 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 每个结点中的值都按照从小到大的顺序排列，每个值的左子树中的所有的值都小于它，而右子树中的所有的值都大于它。 以一个3阶的B树为例插入思想：首先插入都是插入到叶子结点的。 该结点的关键字个数没有到达2个，那么直接插入即可； 该结点的关键字个数已经到达了2个，那么根据B树的性质显然无法满足，需要将其进行分裂，该结点分成两半，将中间的关键字进行提升，加入到父亲结点中，但是这又可能存在父亲结点也满员的情况，则不得不向上进行回溯，甚至是要对根结点进行分裂，那么整棵树都加了一层。 图解可以看：https://blog.csdn.net/m0_38075425/article/details/81777364 删除的话：http://www.cainiaoxueyuan.com/suanfa/4547.html 看这个就能清楚了。 B+树性质如下： 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 B+树相比B树的优势：IO次数更少；查询性能更稳定（B+树的查询最终必须查找到叶子结点，而B树只要找到匹配元素即可）；范围查询更简单（因为所有叶子节点形成有序链表）。 为什么数据库索引中用B+数而不用B树 B+树的磁盘读写代价更低同时并没有解决元素遍历的效率低下的问题， B+树的查询效率更加稳定 B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2019%2F08%2F05%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉查找树它不为空树时，它左子树上所有的元素都小于根节点的元素，而根节点右子树上所有的元素都大于根节点的元素。 为了保证二叉查找树不失衡（出现线性查找的情况），就有了平衡的二叉查找树：红黑树。 红黑树特性 满足二叉树的型组织 每个节点或者是黑色，或者是红色。 根节点是黑色。 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] 如果一个节点是红色的，则它的子节点必须是黑色的。 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 插入一个元素到红黑树的时间为log(N)；采用迭代器遍历一棵红黑树的时间复杂度是O(N) 红黑树什么时候需要变色或者左旋右旋？ 为了满足如上的规则，实现结构的平衡，我们在插入或删除节点的时候，就需要做一些相应的调整，就是对应的变色，左旋，右旋操作。 红黑树的插入 如果插入的节点是根节点，也就是说初始的红黑树为空，这是最简单的情况，直接将该节点标识成黑色即可。 如果新插入的节点不是红黑树的根节点，如果新插入的节点的父节点是黑色的话，那么红黑树是不需要调整的 如果新插入的节点的父亲P和叔叔U都是红色的情况。这时，将P、U都染成黑色，而G染成红色以满足性质5（从任一节点出发到其每个叶子节点的路径，黑色节点的数量是相等的）。现在，当前的红色节点N有一个黑色的父亲，而且所有经过父亲和叔叔节点的路径仍然保持与原来相同的节点个数。但是爷爷节点G可能会违反性质2（根节点必须是黑色）或者性质4（红色节点必须有两个黑色儿子节点）（在G节点的父亲也是红色节点时，会破坏性质4）。要修复这个问题，可以对节点G递归执行Case1的操作 父亲P是红色，叔叔U是黑色，并且N是P的右孩子，P是G的左孩子的情况。这时，对节点P执行左旋操作，使P变成N的左孩子,N变成G的左孩子,也就是说进入了5 的情况。 父亲P是红色，但叔叔U是黑色， N是左孩子，P也是左孩子的情况。此时，对节点G执行一次右旋。使P成为N和G的父节点。已知G是黑色（P是红色，为了不破坏性质4（红色节点必须有两个黑色儿子节点），G肯定是黑色），所以将G染成红色，P染成黑色。 红黑树的删除看这个吧：https://www.cnblogs.com/zutterhao/p/7535878.html]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Foreach原理以及Fail-fast机制]]></title>
    <url>%2F2019%2F08%2F05%2FForeach%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AFast-fail%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Fail-fast机制它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。 我们通过ArrayList源代码来分析，先看下迭代器的源码 12345678910111213141516171819202122232425262728private class Itr implements Iterator&lt;E&gt; &#123; int cursor; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return (this.cursor != ArrayList.this.size); &#125; public E next() &#123; checkForComodification(); /** 省略此处代码 */ &#125; public void remove() &#123; if (this.lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); /** 省略此处代码 */ &#125; final void checkForComodification() &#123; if (ArrayList.this.modCount == this.expectedModCount) return; throw new ConcurrentModificationException(); &#125; &#125; 从上面的源代码我们可以看出，迭代器在调用next()、remove()方法时都是调用checkForComodification()方法，该方法主要就是检测modCount == expectedModCount ? 若不等则抛出ConcurrentModificationException 异常，从而产生fail-fast机制。所以我们要确定什么时候modCount != expectedModCount，他们的值在什么时候发生改变的。 我们看源码可以知道expectedModCount 是在Itr中定义的：int expectedModCount = ArrayList.this.modCount;所以他的值是不可能会修改的，所以会变的就是modCount，modCount是在 AbstractList 中定义的，为全局变量。 1protected transient int modCount = 0; 再看它什么时候会改变， 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean add(E paramE) &#123; ensureCapacityInternal(this.size + 1); /** 省略此处代码 */ &#125; private void ensureCapacityInternal(int paramInt) &#123; if (this.elementData == EMPTY_ELEMENTDATA) paramInt = Math.max(10, paramInt); ensureExplicitCapacity(paramInt); &#125; private void ensureExplicitCapacity(int paramInt) &#123; this.modCount += 1; //修改modCount /** 省略此处代码 */ &#125; public boolean remove(Object paramObject) &#123; int i; if (paramObject == null) for (i = 0; i &lt; this.size; ++i) &#123; if (this.elementData[i] != null) continue; fastRemove(i); return true; &#125; else for (i = 0; i &lt; this.size; ++i) &#123; if (!(paramObject.equals(this.elementData[i]))) continue; fastRemove(i); return true; &#125; return false; &#125; private void fastRemove(int paramInt) &#123; this.modCount += 1; //修改modCount /** 省略此处代码 */ &#125; public void clear() &#123; this.modCount += 1; //修改modCount /** 省略此处代码 */ &#125; 从上面的源代码我们可以看出，ArrayList中无论add、remove、clear方法只要是涉及了改变ArrayList元素的个数的方法都会导致modCount的改变。所以我们这里可以初步判断由于expectedModCount 得值与modCount的改变不同步，导致两者之间不等从而产生fail-fast机制。知道产生fail-fast产生的根本原因了，我们可以有如下场景：有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount = N ，而modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。 fail-fast解决办法 在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。 使用CopyOnWriteArrayList来替换ArrayList CopyOnWriteArrayList它是ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 该类产生的开销比较大，但是在两种情况下，它非常适合使用。 在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。 当遍历操作的数量大大超过可变操作的数量时。 CopyOnWriterArrayList的无论是从数据结构、定义都和ArrayList一样。它和ArrayList一样，同样是实现List接口，底层使用数组实现。在方法上也包含add、remove、clear、iterator等方法。 CopyOnWriterArrayList根本就不会产生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制。以add方法为例，它是在于copy原来的array，再在copy数组上进行add操作，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。 Foreach我们知道在JAVA中，遍历集合和数组一般有以下三种形式：第一种是普通的for循环遍历、第二种是使用迭代器进行遍历，第三种我们一般称之为增强for循环（for each）。 那么Foreach底层是怎么做的，使得它能够进行循环。 我们对以下代码进行反编译： 123for (Integer i : list) &#123; System.out.println(i);&#125; 反编译后： 123456789101112Integer i;for(Iterator iterator = list.iterator(); iterator.hasNext(); System.out.println(i))&#123; i = (Integer)iterator.next(); &#125;/*Integer i; 定义一个临时变量iIterator iterator = list.iterator(); 获取List的迭代器iterator.hasNext(); 判断迭代器中是否有未遍历过的元素i = (Integer)iterator.next(); 获取第一个未遍历的元素，赋值给临时变量iSystem.out.println(i) 输出临时变量i的值如此循环往复，直到遍历完List中的所有元素。*/ 通过反编译，我们看到，其实JAVA中的增强for循环底层是通过迭代器模式来实现的。那么必然就会有Fail-fast机制，在使用迭代器遍历元素的时候，在对集合进行删除的时候一定要注意，使用不当有可能发生ConcurrentModificationException。 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用Iterator 本身的方法 remove() 来删除对象，Iterator.remove()方法会在删除当前迭代对象的同时维护索引的一致性。 123456789101112for (Student stu : students) &#123; if (stu.getId() == 2) students.remove(stu); &#125;// 会抛出ConcurrentModificationException异常。Iterator&lt;Student&gt; stuIter = students.iterator(); while (stuIter.hasNext()) &#123; Student student = stuIter.next(); if (student.getId() == 2) stuIter.remove();/*这里要使用Iterator的remove方法移除当前对象，如果使用List的remove方法，则同样会出现ConcurrentModificationException*/ &#125;// 不会抛出ConcurrentModificationException异常]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试涉及到的一些算法题]]></title>
    <url>%2F2019%2F07%2F27%2F%E9%9D%A2%E8%AF%95%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[有多个集合，有交集的就合并，输出合并后的结果。思路很简单，就是对于多个集合进行排序，x相同y小的放前面，否则x小的放前面。 然后一遍遍历，我维护当前集合的最右边的值tempy，如果tempy大于下一个集合的初始点的值说明这两个集合有交集，更新tempy的值，否则更新tempy值为下一个集合的最右边的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 10005;struct Node &#123; int x, y;&#125;;Node node[maxn];vector&lt;Node&gt;v;bool cmp(Node a, Node b) &#123; if (a.x == b.x) &#123; return a.y &lt; b.y; &#125; else &#123; return a.x &lt; b.x; &#125;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d %d", &amp;node[i].x, &amp;node[i].y); &#125; sort(node, node + n, cmp); for (int i = 0; i &lt; n; i++) &#123; printf("%d %d\n", node[i].x, node[i].y); &#125; int tempx = node[0].x; int tempy = node[0].y; for (int i = 1; i &lt; n; i++) &#123; if (tempy &gt; node[i].x) &#123; tempy = node[i].y; continue; &#125; else &#123; Node temp; temp.x = tempx; temp.y = tempy; v.push_back(temp); tempx = node[i].x; tempy = node[i].y; &#125; &#125; Node temp; temp.x = tempx; temp.y = tempy; v.push_back(temp); int len = v.size(); for (int i = 0; i &lt; len; i++) &#123; printf("%d %d\n", v[i].x, v[i].y); &#125;&#125; 给一个词典的集合，一组不重复字母，问这些字母可以组成几个词语先Hash一下字母，然后遍历和这个词典的集合，对于每个词语去Hash里面查一下，都有就能组成。 时间复杂度是O(集合的词语的长度之和) 从10万个数中找10个最大的数 最普通的想法是先对这10万个数进行排序，然后再选取数组中前10个数，即为最后的答案，排序算法的时间复杂度不下于O(N lgN)。最好的方法是建立一个最小堆。 我们首先取10万个元素中的前10个元素来建立由10个元素组成的最小堆。这样堆顶元素便是当前已知元素的第10大的数；然后依次读取剩下的99990个元素，若读取的元素比堆顶元素大，则将堆顶元素和当前元素替换，并自堆顶至下调整堆；这样读取完所有元素后，堆中的10个元素即为这10万个数最大的10个数，同时堆顶元素为这10万个元素第10大元素。时间复杂度：设从N个数中找M个最大数每次重新恢复堆的时间复杂都为O(logM),最多进行了（N-M）次恢复堆操作，故时间复杂度为O(NlogM)。 维持一个长度为10的降序数组，每一个从数组拿到的数字都与这个降序数组的最小值比较。如果小于最小值，就舍弃；如果大于最小值，就把它插入到降序数组中的合适位置，舍弃原来的最小值。这样，遍历一遍就可以找到最大的10个数。 判断回文字符串将这串数字逆序，然后判断逆序后的数字是否和正序后的数字完全一样，如果完全一样，就是回文。 1234567891011121314bool palindrome(char *s)&#123; int n=strlen(s); int i, j,count=0; for (i = 0, j = n - 1; i &lt; n, j &gt;= 0; i++, j--) &#123; if (*(s + i) == *(s + j)) &#123; count++; &#125; &#125; if (count == n) return true;&#125; 最长回文序列回文子序列，因为是不连续的肯定是不能直接枚举，那么利用动态规划 我们知道对于任意字符串，如果头尾字符相同，那么字符串的最长子序列等于去掉首尾的字符串的最长子序列加上首尾；如果首尾字符不同，则最长子序列等于去掉头的字符串的最长子序列和去掉尾的字符串的最长子序列的较大者。那么转移方程： dp[i][j]=dp[i+1][j-1] + 2 if（s[i] == s[j]） dp[i][j]=max(dp[i+1][j],dp[i][j-1]) if （s[i] != s[j]） 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1005;char s[maxn];int dp[maxn][maxn];int main()&#123; scanf("%s",s); int len=strlen(s); for(int i=len-1;i&gt;=0;i--) &#123; dp[i][i]=1; for(int j=i+1;j&lt;=len;j++) &#123; if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1]+2; else dp[i][j]=max(dp[i][j-1],dp[i+1][j]); &#125; &#125; printf("%d\n",dp[0][len-1]); return 0;&#125; 最长回文子串123456789101112131415161718192021222324252627282930313233343536string longestPalindrome(string s)&#123; if (s.empty()) return ""; int len = s.size(); if (len == 1)return s; int longest = 1; int start=0; vector&lt;vector&lt;int&gt; &gt; dp(len,vector&lt;int&gt;(len)); for (int i = 0; i &lt; len; i++) &#123; dp[i][i] = 1; if(i&lt;len-1) &#123; if (s[i] == s[i + 1]) &#123; dp[i][i + 1] = 1; start=i; longest=2; &#125; &#125; &#125; for (int l = 3; l &lt;= len; l++)//子串长度 &#123; for (int i = 0; i+l-1 &lt; len; i++)//枚举子串的起始点 &#123; int j=l+i-1;//终点 if (s[i] == s[j] &amp;&amp; dp[i+1][j-1]==1) &#123; dp[i][j] = 1; start=i; longest = l; &#125; &#125; &#125; return s.substr(start,longest);&#125; 二叉树的遍历先序遍历根节点—&gt;左子树—&gt;右字树 递归遍历12345678void PreOrder(Tnode* root)&#123; if(root==NULL) return ; cout&lt;&lt;root-&gt;val&lt;&lt;endl; Preorder(root-&gt;lchild); Preorder(root-&gt;rchild);&#125; 非递归遍历先序遍历时，每当我们压入一个结点，我们压入结点前对其进行访问 1234567891011121314151617181920void PreOrder(Tnode *root)&#123; if(root==NULL) return ; stack&lt;Tnode *&gt;s; Tnode *now=root; while(!s.empty() || now) &#123; while(now) &#123; cout&lt;&lt;now-&gt;val&lt;&lt;"-&gt;"; s.push(now); now=now-&gt;lchild; &#125; now=s.top(); s.pop(); now=now-&gt;rchild; &#125; cout&lt;&lt;endl;&#125; 中序遍历左子树—&gt;根节点—&gt;右字树 递归遍历12345678void InOrder(Tnode* root)&#123; if(root==NULL) return ; Preorder(root-&gt;lchild); cout&lt;&lt;root-&gt;val&lt;&lt;endl; Preorder(root-&gt;rchild);&#125; 非递归遍历中序时我们需要在遍历完左子树后访问根节点，再去遍历右子树 1234567891011121314151617181920void InOrder(Tnode *root)&#123; if(root==NULL) return ; stack&lt;Tnode *&gt;s; Tnode *now=root; while(!s.empty() || now) &#123; while(now) &#123; s.push(now); now=now-&gt;lchild; &#125; now=s.top(); cout&lt;&lt;now-&gt;val&lt;&lt;"-&gt;"; s.pop(); now=now-&gt;rchild; &#125; cout&lt;&lt;endl;&#125; 后序遍历左子树—&gt;右字树—&gt;根节点 递归遍历12345678void PostOrder(Tnode* root)&#123; if(root==NULL) return ; Preorder(root-&gt;lchild); Preorder(root-&gt;rchild); cout&lt;&lt;root-&gt;val&lt;&lt;endl;&#125; 非递归遍历后序遍历时由于访问完左右子树后才能访问根结点，因此需要将根结点在栈内保留到左右子树被访问后，但同时会出现一个问题，当右子树弹出后遇到根结点又会将右子树结点压入栈中，造成死循环，因此我们需要在定义一个变量last代表最后一个访问的结点，当last与栈顶结点的右子树结点相同时，则不再将右子树结点压入栈中。 1234567891011121314151617181920212223242526void PostOrder(Tnode *root)&#123; if(root==NULL) return ; stack&lt;Tnode *&gt;s; Tnode *now=root; Tnode *last=NULL; while(!s.empty() || now) &#123; while(now) &#123; s.push(now); now=now-&gt;lchild; &#125; now=s.top(); if(now-&gt;rchild &amp;&amp; last!=now-&gt;rchild) now=now-&gt;rchild; else if(now-&gt;rchild ==NULL || last ==now-&gt;rchild) &#123; cout&lt;&lt;&lt;now-&gt;val&lt;&lt;"-&gt;"; last=now; s.pop(); now=NULL; &#125; &#125;&#125; 给定中序和前序求层序或者后序不管是求层序还是后序，主要过程都是一样的都是建树。 首先我们在上面介绍了前序，中序，后序遍历的特性。所以我们基本的思路就是先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。给个例子介绍一下： 前序遍历：GDAFEMHZ 中序遍历：ADEFGHMZ 画树求法： 根据前序遍历的特点，我们知道根结点为G 观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。 观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。 同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int INF=0x3f3f3f3f;const int maxn=50;int n,m,s,d;int a[maxn],b[maxn];struct Node&#123; int l,r;&#125;node[maxn];int buildtree(int la,int ra,int lb,int rb)&#123; if(la&gt;ra) return 0; int root=b[lb]; int len1,len2; len1=la; while(a[len1]!=root) len1++; len2=len1-la; node[root].l=buildtree(la,len1-1,lb+1,lb+len2); node[root].r=buildtree(len1+1,ra,lb+len2+1,rb); return root;&#125;void bfs(int root)&#123; queue&lt;int&gt;q; vector&lt;int&gt;v; q.push(root); while(!q.empty()) &#123; int w=q.front(); q.pop(); if(w==0) break; v.push_back(w); if(node[w].l!=0) q.push(node[w].l); if(node[w].r!=0) q.push(node[w].r); &#125; int len=v.size(); for(int i=0;i&lt;len;i++) printf("%d%c",v[i],i==len-1?'\n':' '); return;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); for(int i=0;i&lt;n;i++) scanf("%d",&amp;b[i]); buildtree(0,n-1,0,n-1); int root=b[0]; bfs(root); return 0;&#125; 给定二叉树，给出S型打印1234567891011121314151617181920212223242526272829303132333435void S_LevelOrderPrint(TreeNode t)&#123; stack&lt;TreeNode&gt; s1; stack&lt;TreeNode&gt; s2; s1.push(t); while(!s1.empty() || !s2.empty()) &#123; if(!s1.empty()) &#123; while(!s1.empty()) &#123; TreeNode tn = s1.top(); cout&lt;&lt;tn.val&lt;&lt;""; s1.pop(); if(tn.right != null) s2.push(tn.right); if(tn.left != null) s2.push(tn.left); &#125; &#125; else &#123; while(!s2.empty()) &#123; TreeNode tn = s2.top(); cout&lt;&lt;tn.val&lt;&lt;" "; s2.pop(); if(tn.left != null) s1.push(tn.left); if(tn.right != null) s1.push(tn.right); &#125; &#125; &#125;&#125; N 阶乘末尾0的个数。要判断末尾有几个0就是判断可以整除几次10。10的因子有5和2，而在0~9之间5的倍数只有一个，2的倍数相对较多，所以本题也就转换成了求N阶乘中有几个5的倍数。也就是每多出来一个5，阶乘末尾就会多出来一个0，这样n / 5就能统计完第一层5的个数，依次处理，就能统计出来所有5的个数。 12345678910111213#include&lt;iostream&gt;using namespace std;int main() &#123; int n; cin&gt;&gt;n; int count = 0; while(n) &#123; n /= 5; //算出当前数字中可以匹配5（5和5的倍数）的个数 count += n; //累加之 &#125; cout&lt;&lt;count; return 0;&#125; 给定数组，从数组中取出n个不复用的数的和为sum深搜 12345678910111213141516void findd(vector&lt;int&gt;&amp;vr,int pos,int sum,int m,int&amp; res)&#123; if(sum==m)&#123; res++; return; &#125; else if(sum&gt;m)&#123; return; &#125;else&#123; if(pos&lt;vr.size())&#123; sum+=vr[pos]; findd(vr,pos+1,sum,m,res); sum-=vr[pos]; findd(vr,pos+1,sum,m,res); &#125; &#125;&#125; DP 1234567891011121314151617181920212223242526272829303132333435int main()&#123; int n=0; int m=0; while(cin&gt;&gt;n&gt;&gt;m)&#123; vector&lt;int&gt; vr(n); for(int i=0;i&lt;n;++i)&#123; cin&gt;&gt;vr[i]; &#125; sort(vr.begin(),vr.end(),greater&lt;int&gt;()); vector&lt;vector&lt;long long int&gt;&gt;dp(n,vector&lt;long long int&gt;(m+1,0)); for(int i=0;i&lt;n;++i)&#123; dp[i][0]=1; &#125; for(int i=1;i&lt;=m;i++)&#123; if(vr[0]&gt;m)//过滤 break; if(vr[0]==i) dp[0][i]=1; else dp[0][i]=0; &#125; for(int i=1;i&lt;n;++i)&#123; if(vr[i]&gt;m) //过滤 continue; for(int j=1;j&lt;=m;++j)&#123; if(j-vr[i]&gt;=0) dp[i][j]=dp[i-1][j]+dp[i-1][j-vr[i]]; else dp[i][j]=dp[i-1][j]; &#125; &#125; cout&lt;&lt;dp[n-1][m]&lt;&lt;endl; &#125; return 0;&#125; 求一个无序数组的中位数利用快排的思想。任意挑一个元素，以该元素为支点，划分集合为两部分，如果左侧集合长度恰为(n-1)/2，那么支点恰为中位数。如果左侧长度&lt;(n-1)/2, 那么中位点在右侧，反之，中位数在左侧。 进入相应的一侧继续寻找中位点。 1234567891011121314151617181920212223242526272829303132333435363738394041//快排方法，分治思想int PartSort(int arr[], int left,int right)&#123; int key = arr[right]; while (left &lt; right) &#123; //key右边，先从左找比key值大 while (left &lt; right &amp;&amp; arr[left] &lt;= key) ++left; if (left &lt; right) &#123; arr[right] = arr[left]; --right; &#125; //从右找比key小 while (left &lt; right &amp;&amp; arr[right] &gt;= key) --right; if (left &lt; right) &#123; arr[left] = arr[right]; ++left; &#125; &#125; arr[left] = key; return left;&#125;void GetMid3(int arr[],int size)&#123; int left = 0; int right = size - 1; int mid = size / 2; int div = PartSort(arr, left, right); while (div != mid) &#123; if (div &lt; mid)//右半区间 div = PartSort(arr, div + 1, right); else div = PartSort(arr, left, div - 1); &#125; cout &lt;&lt; "中位数" &lt;&lt; arr[div] &lt;&lt; endl;&#125; 全排列123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=1000005;int n,m;int a[maxn];void perm(int s,int e)&#123; if(s==e) &#123; for(int i=0;i&lt;=e;i++) printf("%d ",a[i]); printf("\n"); &#125; else &#123; for(int i=s;i&lt;=e;i++) &#123; swap(a[i],a[s]); perm(s+1,e); swap(a[i],a[s]); &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); perm(0,n-1); return 0;&#125; 36进制加法12345678910111213141516171819202122232425262728293031package collection;public class Main &#123; private static final String chars = "0123456789abcdefghijklmnopqrstuvwxyz"; public static void main(String[] args) &#123; System.out.println(add_36("1b", "10")); &#125; public static String add_36(String a, String b) &#123; int alength = a.length(); int blength = b.length(); int m = Math.max(alength, blength); int inc = 0; int clength = chars.length(); String result = ""; for (int i = 0; i &lt; m; i++) &#123; int ia = i &lt; alength ? chars.indexOf(a.charAt(alength - i - 1)) : 0; int ib = i &lt; blength ? chars.indexOf(b.charAt(blength - i - 1)) : 0; int add = ia + ib + inc; if (add &gt; clength) &#123; inc = add / clength; &#125; result = chars.charAt(add % clength) + result; &#125; if (inc &gt; 0) &#123; result = chars.charAt(inc) + result; &#125; return result; &#125;&#125; n条直线最多把平面分割成几部分?n条直线最多把平面分成An部分，于是A0=1 A1=2 A2=4 对于已经有n条直线 将平面分成了最多的An块 那么加一条直线 他最多与前n条直线有n个交点 于是被它穿过的区域都被一分为二 那么增加的区域数就是穿过的区域 数 也就是这条直线自身被分成的段数 就是n+1 故 A(n+1) = A(n)+n+1 An = n+(n-1)+...+2+A1 = n(n+1)/2 +1 n条折线分割平面根据直线分平面可知，由交点决定了射线和线段的条数，进而决定了新增的区域数。当n-1条折线时，区域数为f（n-1）。为了使增加的区域最多，则折线的两边的线段要和n-1条折线的边，即2*（n-1）条线段相交。那么新增的线段数为4*（n-1），射线数为2。但要注意的是，折线本身相邻的两线段只能增加一个区域。 123456f(n)=f(n-1)+4(n-1)+2-1=f(n-1)+4(n-1)+1=f(n-2)+4(n-2)+4(n-1)+2……=f(1)+4+4*2+……+4(n-1)+(n-1) =2n^2-n+1 n个平面分割空间n个平面最多把空间分成bn个部分 于是b0=1 b1=2 b2=4 对于已经有n个平面 将空间分成了最多的bn块 那么加入一个平面 它最多与每个平面相交 在它的上面就会得到至多n条交线 同时被它穿过的空间区域也被它一分为二 那么增加的区域数仍旧是它穿过的区域数 也就是这个平面自身被直线分割成的块数 就是an于是b(n+1)=bn+an 123456bn=a(n-1)+b(n-1)=...=a(n-1)+a(n-2)+...+a1+b1=(n-1)n/2 +(n-2)(n-1)/2+...+1*(1+1)/2+n+2=求和[1方到(n-1)方]/2 + 求和[1到(n-1)]/2 +n+1=n(n-1)(2n-1)/12 +n(n-1)/4 +n+1=n(n+1)(n-1)/6 +n+1=(n^3+5n+6)/6 数组中唯一出现过一次的数利用异或的特性：x ^ y ^ x = y ^ x ^ x = y。 1234567891011121314151617#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int len=15;int a[7]=&#123;2,4,3,3,2,5,5&#125;;int main()&#123; int ans=a[0]; for(int i=1;i&lt;7;i++) &#123; ans^=a[i]; &#125; printf("%d\n",ans); return 0;&#125; 一个数组里除了一个数字之外，其他数字出现了n次我们把这个数分解成二进制，计算出每一位出现1的个数，我们知道如果多次出现的话，1的个数是能够整除这个n，如果发现这个n不能够被 整除的时候，我们就知道那个唯一的数字转换为二进制的时候在这一位上会分解到，我们把这个再转换为十进制的数即可。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int len=15;int a[7]=&#123;2,3,3,3,4,4,4&#125;;int b[32];int main()&#123; for(int i=0;i&lt;=6;i++) &#123; for(int j=0;j&lt;32;j++) &#123; b[j]+=((a[i]&gt;&gt;j)&amp;1); &#125; &#125; int ans=0; for(int i=0;i&lt;32;i++) &#123; if(b[i]%3!=0) &#123; ans+=(1&lt;&lt;i); &#125; &#125; printf("%d\n",ans); return 0;&#125; 找1到n中缺失的数字数组有序直接二分时间复杂度为O(logN)。如果中间元素的值和下标相等，那么下一轮查找只需要查找右半边；如果中间元素的值和下标不相等，并且它前面一个元素和它的下标相等，这意味着这个中间的数字正好是第一个值和下标不相等的元素，它的下标就是在数组中不存在的数字；如果中间元素的值和下标不相等，并且它前面一个元素和它的下标不相等，这意味着下一轮查找我们只需要在左半边查找即可。 12345678910111213int getLoseNum(int a[], int left, int right)&#123; int mid; while(left &lt;= right) &#123; mid = (left + right) / 2; if(a[mid] == mid + 2) //缺失的数据在后半部分 right = mid - 1; else if(a[mid] == mid + 1) //缺失的数据在前半部分 left = mid + 1; &#125; return left + 1;&#125; 数组无序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*利用异或运算， 任何数异或自己都等于0，x^x=0，任何数异或0都等于他自己x^0=x； 假如缺的为3。result = 1^2^4^5^N 第二次异或后 result = 1^2^4^5^N ^1^2^3^4^5^N = 0^3 = 3 时间复杂度：O(n) 空间复杂度：O(1) 异或方法，n：最大元素的值*/int getLose(int a[], int n)&#123; int t = 0; for(int i =1; i&lt;=n; i++) t = t ^ i; //最大值为n，缺失一个元素，则元素个数为n-2 for(int i=0; i&lt;n-1; i++) t = t ^ a[i]; return t;&#125;/*用1+2+…+n减去当前输入数据的总和，则所得的差就是缺失的那个数。 时间复杂度：O(n) 空间复杂度：O(1)*///n：最大元素的值而不是元素的个数int getNum(int a[], int n)&#123; int sum = n*(n+1)/2; int t; for(int i=0; i&lt;n-1; i++) &#123; sum = sum - a[i]; &#125; return sum;&#125;/*对输入数据进行Hash，然后从头到尾遍历一次。时间复杂度O(n) 空间复杂度O(n) */int getMiss(int a[], int max)&#123; //hash表的长度比max大1 int *tmp = new int[max+1]; //数组的值从1开始，因此hash表的0位不用 for(int i=1; i&lt;=max; i++) tmp[i] = 0; //对数组遍历，缺失一个数，数组的长度为max-2 for(int i=0; i&lt;max-1; i++) &#123; tmp[a[i]]++; &#125; for(int i=1; i&lt;=max; i++) if(tmp[i] == 0) return i;&#125; 找1到n中缺失的两个数字也是采用异或。假设，缺失的数为s1和s2。则s1^s2=1^2^3.....^n^a[0]^a[1]^....a[n-3]。这个式子一目了然，无需多解释。 问题是如何通过这个式子求出s1与s2的值。只要能求出一个值，比如说s1，则s2=s1^(s1^s2)。 s1^s2的值必然不为0，则必然存在一位，s1与s2在此对应位不同。我们就可以按照此对应位是0或者1，将1-n分为两堆，将a[0]-a[n-3]分为两堆。将该为为1的两堆数相异或就能求出缺失的一个数。 举个例子。1-7中缺失3,4。转化为二进制位：011和100。三位都不同，我们用最后一位来判别，将1-n和数组非为两堆。则结果为： 标志位(最后一位） 1 0 1-n 1、3、5、7 2、4、6 a[0]-a[n-3] 1、5、7 2、6 用标志位为1的数进行异或 1^3^5^7^1^5^7=3。这样就求出了一个缺失数。 12345678910111213141516171819202122void find_missing_number2 (int a[], int size, int&amp; miss1, int&amp; miss2)&#123; miss1 = 0; miss2 = 0; int number=0; for (int i=0;i&lt;size;i++) number ^= ((i+1)^a[i]); number ^= (size+1); number ^= (size+2); int k = number - (number&amp;(number-1)); for (int i=0;i&lt;size;i++) &#123; if ( (i+1)&amp;k ) miss1 ^= (i+1); if ( a[i]&amp;k ) miss1 ^= a[i]; &#125; if ( (size+1) &amp; k ) miss1 ^= size+1; if ( (size+2) &amp; k ) miss1 ^= size+2; miss2 = number ^ miss1;&#125; 下一个最大数系列给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。在遍历数组的过程中，如果是往后遇到大的数，那就是第一个更大的数，如果一直遇到不断小的数，才会一直找不到，我们可以用一个栈来记录，遇到比栈顶小的数字就放入栈中，遇到比栈顶大的数字就说明这是栈顶数字的下一个更大的数，就将其放在结果数组的对应位置上，栈顶的元素出栈，继续比较新的栈顶的数，如果还是大，那么继续记录，出栈，直到栈顶的数比新数要小，那么就可以将新数入栈了。因为我们要将找到的更大的数放在对应位置上，所以栈中记录的应该是元素位置，而不是具体的数字，但比较的时候还是比较原来的数组中这个位置的数字，此外，因为会出现循环寻找的情况，所以数组我们可能遍历两次。算法的时间复杂度是O(n)，空间复杂度也是O(n)。 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; const int N = nums.size(); vector&lt;int&gt; res(N, -1); stack&lt;int&gt; stack; for (int i = 0; i &lt; N * 2; i++) &#123; while (!stack.empty() &amp;&amp; nums[stack.top()] &lt; nums[i % N]) &#123; res[stack.top()] = nums[i % N]; stack.pop(); &#125; if (i &lt; N) stack.push(i); &#125; return res; &#125;&#125;; 输入一个数组，代表每天的温度，求解每天需要经过几天会升温，即需找数组每个元素右边第一个比自己大的数。利用单调栈性质创建单调递减栈，遍历数组入栈，当将要入栈元素小于栈顶元素时入栈，若要入栈元素大于栈顶元素时，表示入栈元素为所求元素，记录索引，弹出栈顶元素，将此元素压栈，重新比较，一次循环时间复杂度O(n)。 样例输入：[73, 74, 75, 71, 69, 72, 76, 73] 样例输出： [1, 1, 4, 2, 1, 1, 0, 0]. 123456789101112131415161718192021222324252627/*样例解析：73入栈，74&gt;73，73出栈，74入栈，74使得73出栈，所以73需要等待1-0=1天 ，栈内元素74.75入栈，75&gt;74, 74出栈，75入栈，75使得74出栈，所以74需要等待2-1=1天，栈内元素75.71入栈，71&lt;75，直接入栈，栈内元素 75,7169直接入栈，栈内元素75,71,6972入栈，72&gt;69,69出栈，72使69出栈，所以69需要等待5-4=1天，此时栈内元素75,71，由与72&gt;71,任不满足单调栈性质，71出栈，72使71出栈，所以71需要等待5-3=2天，站内元素75,75&gt;72,72直接入栈，栈内元素为：75,72.*/class Solution &#123; public int[] dailyTemperatures(int[] temperatures) &#123; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int[] res = new int[temperatures.length]; for(int i=0;i&lt;temperatures.length;i++)&#123; if(s.isEmpty()||temperatures[i]&lt;temperatures[s.peek()])&#123; s.push(i); &#125; else &#123; while(!s.isEmpty()&amp;&amp;temperatures[s.peek()]&lt;temperatures[i])&#123; int index = s.pop(); res[index] = i-index; &#125; s.push(i); &#125; &#125; return res; &#125;&#125; 链表中的下一个更大节点未排序的数组第 k 大的数第一种解法，利用优先队列，维护一个 size == k 的优先队列 123456789101112131415class Solution &#123; public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; /** priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q; **/ priority_queue&lt;int, vector&lt;int&gt;&gt; q; int len=nums.size(); for(int val:nums)&#123; q.push(val); &#125; while(q.size() &gt; len-k+1)&#123; q.pop(); &#125; return q.top(); &#125;&#125;; 第二种解法：利用快排的思想，就跟无序数组中找中位数一样 12345678910111213141516171819202122232425262728class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int high = nums.size(); int low = 0; while (low &lt; high) &#123; int i = low; int j = high-1; int pivot = nums[low]; while (i &lt;= j) &#123; while (i &lt;= j &amp;&amp; nums[i] &gt;= pivot) i++; while (i &lt;= j &amp;&amp; nums[j] &lt; pivot) j--; if (i &lt; j) swap(nums[i++],nums[j--]); &#125; swap(nums[low],nums[j]); if (j == k-1) return nums[j]; else if (j &lt; k-1) low = j+1; else high = j; &#125; &#125;&#125;; 计算数字 n 有多少个二进制 1利用 n&amp;(n-1) 清除最右边的 1，记录 1 的个数就可以了。 因为从二进制的角度讲，n 相当于在 n - 1 的最低位加上 1。举个例子，8（1000）= 7（0111）+ 1（0001），所以 8 &amp; 7 = （1000）&amp;（0111）= 0（0000），清除了 8 最右边的 1（其实就是最高位的 1，因为 8 的二进制中只有一个1）。再比如7（0111）= 6（0110）+ 1（0001），所以7 &amp; 6 = （0111）&amp;（0110）= 6（0110），清除了7的二进制表示中最右边的 1（也就是最低位的 1） 123456789int BitCount2(unsigned int n)&#123; unsigned int c =0 ; for (c =0; n; ++c) &#123; n &amp;= (n -1) ; // 清除最低位的1 &#125; return c ;&#125; 由上面的解法，我们可以判断一个数是 2 的幂数的最快方法是 1234567if(n&amp;(n-1)) then n不是2的幂数;else n是2的幂数;因为如果n=2^K,那么n = 1000...0(k个0）,则n-1 = 111...0(k个1);相与之后则为0如果 n!=2^k，那么n跟（n-1)第一位都为1，则相与这后然后第一位为1，则不为0. 1-n 中有多少个二进制 1我觉得 for 一遍循环，就很快了差不多 O(n) 的时间复杂度。 找出只由 a,b,c 组成的字符串中包含 abc 的个数给个样例，abccc 可以找到 3 个 abc。 思路就是 一个数组中只有0,1,2三个元素，进行排序，要求时间复杂度为O(n)设置三个标记指针，pos0，pos2，cur ，令 pos0 从前往后遍历，指向第一个非 0 的位置，pos2 从后往前遍历，指向第一个非 2 的位置然后 cur 从 pos0 开始往后遍历：遇到 0 就和pos0交换，pos0++;遇到 1 什么也不做;遇到 2 就和 pos2 交换，pos2 向前滑动到下一个非2的位置，交换后还要重新检查 cur 的值；直到 cur 与 pos2 相遇。 12345678910111213141516171819202122232425262728293031nt main()&#123; int arr[14] = &#123;0,1,2,1,2,0,2,0,1,2,2,2,1,2&#125;; int pos0=0, pos2=sizeof(arr)/4 -1, pcur=0; while(0 == arr[pos0]) ++pos0; while(2 == arr[pos2]) --pos2; pcur = pos0; while(pcur &lt;= pos2)&#123; if(0 == arr[pcur])&#123; swap(arr[pcur], arr[pos0]); ++pos0; &#125; else if(2 == arr[pcur])&#123; swap(arr[pcur], arr[pos2]); if(0 == arr[pcur])&#123;//若交换之后，pcur当前指向的元素为0，则继续将pcur指向的元素和pos0指向的元素进行交换 swap(arr[pcur], arr[pos0]); ++pos0;//交换之后，将pos0向前移动一位 &#125; --pos2;//pos2向后移动一位 while(arr[pos2] == 2)//若移动之后指向的元素还是2，则继续向前移动，直到指向第一个非2的元素 --pos2; &#125; ++pcur;//将pcur向前移动 &#125; //将原数组打印出来 for(int i =0;i &lt; sizeof(arr)/4;++i) cout&lt;&lt;arr[i]&lt;&lt;" "; cout&lt;&lt;endl; return 0;&#125; 输出一个递增排序数组的旋转数组中的最小元素 或者 下标1234567891011121314151617181920212223242526272829int find_min_num(const int *arr, size_t n)&#123; int left = 0; int right = n-1; int mid = (right-left)/2; while(left &lt; right) &#123; if((arr[left] &lt;= arr[mid]) &amp;&amp; (arr[mid] &lt;= arr[right])) &#123; break;//当数组区间为递增时，最小值就为最左值 &#125; else if((arr[mid-1] &gt; arr[mid]) &amp;&amp; (arr[mid+1] &gt; arr[mid])) &#123; return arr[mid];//当取到的中间值就为旋转点时，最小值就为中间值 &#125; else if((arr[left] &lt;= arr[mid]) &amp;&amp; (arr[mid] &gt;= arr[right])) &#123; left = mid + 1;//当中间值比左边大且比右边大时 &#125; else &#123; right = mid - 1;//除去上面的三种情况就只剩一种了，那就是中间值比左线小且比右边小 &#125; mid = (right-left)/2 + left; &#125; return arr[left]; // return left;&#125; 求二叉树中节点的差的最大值其实就是求出二叉树中结点的最大值和最小值，相减就是结果。 1234567891011121314151617181920212223242526typedef struct node&#123;int value; struct node *lchild; struct node *rchild;&#125;binarytree;void preorder(binarytree *p, int &amp;max, int &amp;min)//先序遍历&#123; if (NULL==p) return; if(p-&gt;value&gt;max) max=p-&gt;value; if(p-&gt;value&lt;min) min=p-&gt;value; preorder(head-&gt;lchild, max, min); preorder(head-&gt;rchild, max, min); return;&#125;int chazhi_max(binarytree *head)//返回最大差值&#123; if(NULL==head) return -1; int max, min; max = min = head-&gt;value; preorder(head, max, min); return max-min;&#125; 实现pow函数求x的y次方123456789101112131415161718192021class Solution &#123;public: //分治法：分而治之 double pow(double x, int n) &#123; if (n &lt; 0) return 1.0/power(x, -n); else return power(x, n); &#125; double power(double x, int n) &#123; if (n == 0) return 1; double result = 0; double temp = pow(x, n/2);//递归的处理相乘的幂，重复利用已经的出来的值。 if (n%2 == 1) result = x * temp * temp;//当幂为奇数的时候，多乘一个就变为偶数问题了。 else result = temp * temp;//当幂为偶数的时候， return result; &#125;&#125;;]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OPPO提前批二面+HR面]]></title>
    <url>%2F2019%2F07%2F27%2FOPPO%E6%8F%90%E5%89%8D%E6%89%B9%E4%BA%8C%E9%9D%A2-HR%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[没有涉及到什么技术问题本来不想写了，想了一下还是补一下面经，方便自己日后回顾。已经拿了OPPO提前批OFFER。 二面： 前期主要是介绍项目，介绍项目的难点，你是怎么解决的。为什么这样去解决。 你是怎么学习的。 你的日后职业生涯规划是什么。 差不多都是这样的问题吧，都是聊项目。 HR面试： 内容被要求保密，但基本上都是差不多HR常问的那些问题，不过还是要前期准备一下，不然有的时候你会答不出来。 关键关键以后要是面其他家的公司一定要去了解一下这个公司的企业文化，要有认同感，这个很重要！！！]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F07%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式它属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 根据定义可以看到，单例类只能有一个实例。单例类必须自己创建自己的唯一实例。单例类必须给所有其他对象提供这一实例。 优点：在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例以及避免对资源的多重占用。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 几种实现方式懒汉式，线程不安全这种实现最大的问题就是不支持多线程。因为没有加锁synchronized，所以严格意义上它并不算单例模式。 Singleton类刚刚被初始化，instance对象还是空，这时候两个线程同时访问getInstance方法，因为Instance是空，所以两个线程同时通过了条件判断，开始执行new操作，这样一来，显然instance被构建了两次 12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 懒汉式，线程安全第一次调用才初始化，避免内存浪费。必须加锁 synchronized 才能保证单例，但加锁会影响效率。 12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 饿汉式，线程安全这种方式比较常用，但容易产生垃圾对象。它没有加锁，执行效率会提高。但是类加载时就初始化，浪费内存。 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 典型的双重检查锁定1234567891011121314class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。 工厂模式简单工厂定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 优点：一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。 实例：创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图。 首先定义一个接口，作为这三个图像的公共父类,并在其中声明一个公共的draw方法。 123public interface Shape &#123; void draw();&#125; 下面就是编写具体的图形：圆形，正方形，三角形，每种图形都实现Shape接口 12345678910// 圆形public class CircleShape implements Shape &#123; public CircleShape() &#123; System.out.println( "CircleShape: created"); &#125; @Override public void draw() &#123; System.out.println( "draw: CircleShape"); &#125;&#125; 12345678910// 正方形public class RectShape implements Shape &#123; public RectShape() &#123; System.out.println( "RectShape: created"); &#125; @Override public void draw() &#123; System.out.println( "draw: RectShape"); &#125;&#125; 1234567891011// 三角形public class TriangleShape implements Shape &#123; public TriangleShape() &#123; System.out.println( "TriangleShape: created"); &#125; @Override public void draw() &#123; System.out.println( "draw: TriangleShape"); &#125;&#125; 再是工厂类的具体实现 1234567891011121314public class ShapeFactory &#123; public static final String TAG = "ShapeFactory"; public static Shape getShape(String type) &#123; Shape shape = null; if (type.equalsIgnoreCase("circle")) &#123; shape = new CircleShape(); &#125; else if (type.equalsIgnoreCase("rect")) &#123; shape = new RectShape(); &#125; else if (type.equalsIgnoreCase("triangle")) &#123; shape = new TriangleShape(); &#125; return shape; &#125; &#125; 在这个工厂类中通过传入不同的type可以new不同的形状，返回结果为Shape 类型，这个就是简单工厂核心的地方了。 客户端使用 12345678910// 画圆形Shape shape= ShapeFactory.getShape("circle");shape.draw();// 画正方形Shape shape= ShapeFactory.getShape("rect");shape.draw();// 画三角形Shape shape= ShapeFactory.getShape("triangle");shape.draw();// 只通过给ShapeFactory传入不同的参数就实现了各种形状的绘制 工厂模式工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。 实例：现在需要设计一个这样的图片加载类，它具有多个图片加载器，用来加载jpg，png，gif格式的图片，每个加载器都有一个read（）方法，用于读取图片。 首先完成图片加载器的设计，编写一个加载器的公共接口。 123public interface Reader &#123; void read();&#125; 完成各个加载器的代码： 123456789101112131415161718192021// Jpg图片加载器public class JpgReader implements Reader &#123; @Override public void read() &#123; System.out.print("read jpg"); &#125;&#125;// Png图片加载器public class PngReader implements Reader &#123; @Override public void read() &#123; System.out.print("read png"); &#125;&#125;// Gif图片加载器public class GifReader implements Reader &#123; @Override public void read() &#123; System.out.print("read gif"); &#125;&#125; 按照定义所说定义一个抽象的工厂接口ReaderFactory 123public interface ReaderFactory &#123; Reader getReader();&#125; 接下来我们把上面定义好的每个图片加载器都提供一个工厂类，这些工厂类实现了ReaderFactory。在每个工厂类中我们都通过复写的getReader（）方法返回各自的图片加载器对象。 123456789101112131415161718192021// Jpg加载器工厂public class JpgReaderFactory implements ReaderFactory &#123; @Override public Reader getReader() &#123; return new JpgReader(); &#125;&#125;// Png加载器工厂public class PngReaderFactory implements ReaderFactory &#123; @Override public Reader getReader() &#123; return new PngReader(); &#125;&#125;// Gif加载器工厂public class GifReaderFactory implements ReaderFactory &#123; @Override public Reader getReader() &#123; return new GifReader(); &#125;&#125; 客户端使用： 123456789101112// 读取JpgReaderFactory factory=new JpgReaderFactory();Reader reader=factory.getReader();reader.read();// 读取PngReaderFactory factory=new PngReaderFactory();Reader reader=factory.getReader();reader.read();// 读取GifReaderFactory factory=new GifReaderFactory();Reader reader=factory.getReader();reader.read(); 抽象工厂模式和工厂方法模式区别工厂模式：定义一个用于创建对象的借口，让子类决定实例化哪一个类 抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类 代理模式代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 优点：职责清晰；高扩展性；智能化。 缺点：由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 实例：将创建一个 Image 接口和实现Image接口的实体类。ProxyImage是一个代理类，减少RealImage对象加载的内存占用。 ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。 先创建一个接口： 123public interface Image &#123; void display();&#125; 创建实现接口的实体类。 1234567891011121314public class RealImage implements Image &#123; private String fileName; public RealImage(String fileName)&#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display() &#123; System.out.println("Displaying " + fileName); &#125; private void loadFromDisk(String fileName)&#123; System.out.println("Loading " + fileName); &#125;&#125; 1234567891011121314public class ProxyImage implements Image&#123; private RealImage realImage; private String fileName; public ProxyImage(String fileName)&#123; this.fileName = fileName; &#125; @Override public void display() &#123; if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display(); &#125;&#125; 当被请求时，使用ProxyImage来获取RealImage 类的对象。 123456789101112131415public class ProxyPatternDemo &#123; public static void main(String[] args) &#123; Image image = new ProxyImage("test_10mb.jpg"); // 图像将从磁盘加载 image.display(); System.out.println(""); // 图像不需要从磁盘加载 image.display(); &#125;&#125;// 运行结果Loading test_10mb.jpgDisplaying test_10mb.jpgDisplaying test_10mb.jpg]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2019%2F07%2F25%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[在平时的时候，我们使用线程的时候就去创建一个线程，但并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。所以我们会使用线程池。线程池的优势很明显，如下： 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗； 提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行； 方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率； 更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单； Java中的ThreadPoolExecutor类java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，在ThreadPoolExecutor类中提供了四个构造方法。 1234567891011public class ThreadPoolExecutor extends AbstractExecutorService &#123; ..... public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler); ...&#125; 创建线程池，在构造一个新的线程池时，必须满足下面的条件： corePoolSize（线程池基本大小）必须大于或等于0； maximumPoolSize（线程池最大大小）必须大于或等于1； maximumPoolSize必须大于或等于corePoolSize； keepAliveTime（线程存活保持时间）必须大于或等于0； workQueue（任务队列）不能为空； threadFactory（线程工厂）不能为空，默认为DefaultThreadFactory类 handler（线程饱和策略）不能为空，默认策略为ThreadPoolExecutor.AbortPolicy。 对应的参数解释： corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，才会根据是否存在空闲线程，来决定是否需要创建新的线程。除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread()或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。 maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。 keepAliveTime（线程存活保持时间）：默认情况下，当线程池的线程个数多于corePoolSize时，线程的空闲时间超过keepAliveTime则会终止。但只要keepAliveTime大于0，allowCoreThreadTimeOut(boolean)方法也可将此超时策略应用于核心线程。另外，也可以使用setKeepAliveTime()动态地更改参数。 unit（存活时间的单位）：时间单位，分为7类，从细到粗顺序：NANOSECONDS（纳秒），MICROSECONDS（微妙），MILLISECONDS（毫秒），SECONDS（秒），MINUTES（分），HOURS（小时），DAYS（天）； workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。可以使用此队列与线程池进行交互： 如果运行的线程数少于 corePoolSize，则 Executor始终首选添加新的线程，而不进行排队。 如果运行的线程数等于或多于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。 如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。 threadFactory（线程工厂）：用于创建新线程。由同一个threadFactory创建的线程，属于同一个ThreadGroup，创建的线程优先级都为Thread.NORM_PRIORITY，以及是非守护进程状态。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）; handler（线程饱和策略）：当线程池和队列都满了，则表明该线程池已达饱和状态。 ThreadPoolExecutor.AbortPolicy：处理程序遭到拒绝，则直接抛出运行时异常 RejectedExecutionException。(默认策略) ThreadPoolExecutor.CallerRunsPolicy：调用者所在线程来运行该任务，此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 ThreadPoolExecutor.DiscardPolicy：无法执行的任务将被删除。 ThreadPoolExecutor.DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重新尝试执行任务（如果再次失败，则重复此过程）。 线程池的状态在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态： 12345volatile int runState;static final int RUNNING = 0;static final int SHUTDOWN = 1;static final int STOP = 2;static final int TERMINATED = 3; runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性； 下面的几个static final变量表示runState可能的几个取值。 当创建线程池后，初始时，线程池处于RUNNING状态； 如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕； 如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务； 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。 线程池任务执行流程 判断核心线程池是否已满，即已创建线程数是否小于corePoolSize？没满则创建一个新的工作线程来执行任务。已满则进入下个流程。 判断工作队列是否已满？没满则将新提交的任务添加在工作队列，等待执行。已满则进入下个流程。 判断整个线程池是否已满，即已创建线程数是否小于maximumPoolSize？没满则创建一个新的工作线程来执行任务，已满则交给饱和策略来处理这个任务。 线程池中的线程初始化默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。 在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到： prestartCoreThread()：初始化一个核心线程； prestartAllCoreThreads()：初始化所有核心线程 任务缓存队列及排队策略在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。 workQueue的类型为BlockingQueue&lt;Runnable&gt;，通常可以取下面三种类型： ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；有界队列 LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；无界队列 synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。直接提交，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。 任务拒绝策略当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略： ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 几种线程池Java API针对不同需求，利用Executors类提供了4种不同的线程池：newCachedThreadPool, newFixedThreadPool, newScheduledThreadPool,newSingleThreadExecutor。其中线程工厂的默认类为DefaultThreadFactory，线程饱和的默认策略为ThreadPoolExecutor.AbortPolicy。 newCachedThreadPool创建一个可缓存的无界线程池，该方法无参数。当线程池中的线程空闲时间超过60s则会自动回收该线程，当任务超过线程池的线程数则创建新线程。线程池的大小上限为Integer.MAX_VALUE，可看做是无限大。 newFixedThreadPool创建一个固定大小的线程池，该方法可指定线程池的固定大小，对于超出的线程会在LinkedBlockingQueue队列中等待。 newSingleThreadExecutor创建一个只有线程的线程池，该方法无参数，所有任务都保存队列LinkedBlockingQueue中，等待唯一的单线程来执行任务，并保证所有任务按照指定顺序(FIFO或优先级)执行。 newScheduledThreadPool创建一个可定时执行或周期执行任务的线程池，该方法可指定线程池的核心线程个数。 配置线程池大小一般需要根据任务的类型来配置线程池大小： 如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为NCPU+1 如果是IO密集型任务，参考值可以设置为2*NCPU 当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OPPO提前批一面]]></title>
    <url>%2F2019%2F07%2F15%2FOPPO%E6%8F%90%E5%89%8D%E6%89%B9%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[三点多面试的OPPO一面，写下面经。希望能有二面。 自我介绍 static关键字，final关键字。 HashMap是不是线程安全的？为什么不是线程安全？ courrenthashmap怎么保证线程安全？回答了jdk改版后的区别。 问了CAS是啥，大致的说了一下，过程说的是对的，但是几个字母说错了，尴尬。 线程池有几种，记得有四种，只说了三个名字出来。 说一些你知道的这几个线程池的区别，各自的特点。 说了一下一个新的进程加入到线程池的步骤 说一下线程池的几个重要的参数。 问了我newFixedThreadPool这个线程池的初始化大小是怎么决定的，我说测试一下看一般会有多少线程再来决定，面试官想知道一个理论的方法，我不知道。 问了一下你在项目里面承担了什么样的角色，你觉得比较难的点在哪，怎么解决的？ 大致说了一下Redis的持久化，以及前缀树来过滤敏感词，问了时间复杂度和空间复杂度。 不知道空间复杂度是多少。 然后看了我在简历上说在学院的助理干过。问我这个工作是干啥的，中间有没有发生什么事情？ 说了一件比较操蛋的事情，然后问我是怎么解决的，自己是怎么想的？ 然后问了他Java在OPPO里面会用来干啥，就结束了。 为什么要聊后面的内容啊，我面的好慌啊，有几个点感觉还是没答好，特别是项目那一块。 哭了啊，想要二面啊。]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发四]]></title>
    <url>%2F2019%2F07%2F14%2FSpringBoot%E5%BC%80%E5%8F%91%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[需求介绍-MyBatis入门首先就是安装Mysql Server 和Mysql Workbench。 SqlSessionFactory：用于创建SqlSession的工厂类 SqlSession：MyBatis的核心组件用于向数据库执行SQL XML文件：对MyBatis底层做一些配置。 Mapper接口：也就是DAO接口，常称为Mapper Mapper映射器：用于编写SQL，并且将SQL和实体类映射的组件采用XML，注解都可以实现。 编写一些操作用户数据的代码。 代码首先要引用MyBatis和Mysql的依赖，在pom.xml文件里。 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt; 然后配置一下Mysql： 123456789101112131415# DataSourcePropertiesspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/community?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Hongkongspring.datasource.username=rootspring.datasource.password=****（数据库密码）spring.datasource.type=com.zaxxer.hikari.HikariDataSourcespring.datasource.hikari.maximum-pool-size=15spring.datasource.hikari.minimum-idle=5spring.datasource.hikari.idle-timeout=30000# MybatisPropertiesmybatis.mapper-locations=classpath:mapper/*.xmlmybatis.type-aliases-package=com.nowcoder.community.entitymybatis.configuration.useGeneratedKeys=truemybatis.configuration.mapUnderscoreToCamelCase=true 对User表进行数据处理，首先要写个实体类对应表，封装表里面的数据，方便我们去处理，写在entity下面： User： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.nowcoder.community.entity;import java.util.Date;public class User &#123; private int id; private String username; private String password; private String salt; private String email; private int type; private int status; private String activationCode; private String headerUrl; private Date createTime; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getSalt() &#123; return salt; &#125; public void setSalt(String salt) &#123; this.salt = salt; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public int getType() &#123; return type; &#125; public void setType(int type) &#123; this.type = type; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public String getActivationCode() &#123; return activationCode; &#125; public void setActivationCode(String activationCode) &#123; this.activationCode = activationCode; &#125; public String getHeaderUrl() &#123; return headerUrl; &#125; public void setHeaderUrl(String headerUrl) &#123; this.headerUrl = headerUrl; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", password='" + password + '\'' + ", salt='" + salt + '\'' + ", email='" + email + '\'' + ", type=" + type + ", status=" + status + ", activationCode='" + activationCode + '\'' + ", headerUrl='" + headerUrl + '\'' + ", createTime=" + createTime + '&#125;'; &#125;&#125; 然后再DAO层写一个接口（组件），写一些操作数据的方法的声明 12345678910111213141516171819package com.nowcoder.community.dao;import com.nowcoder.community.entity.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;@Mapperpublic interface UserMapper &#123; User selectById(int id); User selectByName(String username); User selectByEmail(String email); int insertUser(User user); int updateStatus(@Param("id") int id, @Param("status") int status); int updateHeader(@Param("id") int id, @Param("headerUrl") String headerUrl); int updatePassword(@Param("id") int id, @Param("password") String password);&#125; 然后我们就需要去写具体实现数据操作的xml文件了，就去mapper文件夹下面写， 首先你要在&lt;mapper&gt;里面写你写的这个是为哪个Mapper服务的，具体实现的时候就是写sql语句，你需要写id对应着你接口写的那个方法，才能够真正的去实现接口声明的方法才可以。 有个问题就是在接口声明方法的时候是有参数的嘛，你要确定这个是个什么参数，如果是java自带的参数类型就不用去管它，但是如果是复杂的参数比方说是个bean就需要声明另一个参数，具体见insertUser实现的那块，如果有对应到数据表的列名是数据库自己生成的话就不需要传进去需要另外取一个参数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.nowcoder.community.dao.UserMapper"&gt; &lt;sql id="insertFields"&gt; username, password, salt, email, type, status, activation_code, header_url, create_time &lt;/sql&gt; &lt;sql id="selectFields"&gt; id, username, password, salt, email, type, status, activation_code, header_url, create_time &lt;/sql&gt; &lt;select id="selectById" resultType="User"&gt; select &lt;include refid="selectFields"&gt;&lt;/include&gt; from user where id = #&#123;id&#125; &lt;/select&gt; &lt;select id="selectByName" resultType="User"&gt; select &lt;include refid="selectFields"&gt;&lt;/include&gt; from user where username = #&#123;username&#125; &lt;/select&gt; &lt;select id="selectByEmail" resultType="User"&gt; select &lt;include refid="selectFields"&gt;&lt;/include&gt; from user where email = #&#123;email&#125; &lt;/select&gt; &lt;insert id="insertUser" parameterType="User" keyProperty="id"&gt; insert into user (&lt;include refid="insertFields"&gt;&lt;/include&gt;) values(#&#123;username&#125;, #&#123;password&#125;, #&#123;salt&#125;, #&#123;email&#125;, #&#123;type&#125;, #&#123;status&#125;, #&#123;activationCode&#125;, #&#123;headerUrl&#125;, #&#123;createTime&#125;) &lt;/insert&gt; &lt;update id="updateStatus"&gt; update user set status = #&#123;status&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;update id="updateHeader"&gt; update user set header_url = #&#123;headerUrl&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;update id="updatePassword"&gt; update user set password = #&#123;password&#125; where id = #&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 然后写一个测试方法，看我们写的对不对，就去测试类里面实现： MapperTest： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.nowcoder.community;import com.nowcoder.community.dao.DiscussPostMapper;import com.nowcoder.community.dao.UserMapper;import com.nowcoder.community.entity.DiscussPost;import com.nowcoder.community.entity.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringRunner;import java.util.Date;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTest@ContextConfiguration(classes = CommunityApplication.class)public class MapperTest &#123; @Autowired private UserMapper userMapper; @Autowired private DiscussPostMapper discussPostMapper; @Test public void testSelectUser() &#123; User user = userMapper.selectById(101); System.out.println(user); user = userMapper.selectByName("liubei"); System.out.println(user); user = userMapper.selectByEmail("nowcoder101@sina.com"); System.out.println(user); &#125; @Test public void testInsertUser() &#123; User user = new User(); user.setUsername("test"); user.setPassword("123456"); user.setSalt("abc"); user.setEmail("test@qq.com"); user.setHeaderUrl("http://www.nowcoder.com/101.png"); user.setCreateTime(new Date()); int rows = userMapper.insertUser(user); System.out.println(rows); System.out.println(user.getId()); &#125; @Test public void updateUser() &#123; int rows = userMapper.updateStatus(150, 1); System.out.println(rows); rows = userMapper.updateHeader(150, "http://www.nowcoder.com/102.png"); System.out.println(rows); rows = userMapper.updatePassword(150, "hello"); System.out.println(rows); &#125; @Test public void testSelectPosts() &#123; List&lt;DiscussPost&gt; list = discussPostMapper.selectDiscussPosts(149, 0, 10); for(DiscussPost post : list) &#123; System.out.println(post); &#125; System.out.println(discussPostMapper.selectDiscussPostRows(149)); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发三]]></title>
    <url>%2F2019%2F07%2F14%2FSpringBoot%E5%BC%80%E5%8F%91%E4%B8%89%2F</url>
    <content type="text"><![CDATA[需求介绍-SpringMVC理解HTTP； 服务层的三层架构：表现层，业务层，数据层，浏览器访问服务器先访问表现层，期待表现层返回一些数据，表现层呢就访问业务层处理业务，而业务层在处理业务的时候会调用数据层请求数据和处理数据 SpringMVC是一种设计模式，也是分为三层。 使用的核心组件是：DispatcherServlet ViewresResolver：视图解析视图层 HandleMapping：处理映射的一个组件，我们敲一个路径与Controller相匹配。 更细节的可以看： 然后码一个实现的MVC的代码有助理解一下 代码首先要理解怎么获取请求对象和响应对象以及如何确定发送方法： 第一个返回请求对象的结果 使用Post的方法的时候，需要html提交表单，那么对应的网页的数据的名字要和Controller的对应方法获取参数名字要相同 student.html： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;增加学生&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method="post" action="/community/student"&gt; &lt;p&gt; 姓名： &lt;input type="text" name="name"&gt; &lt;/p&gt; &lt;p&gt; 年龄： &lt;input type="text" name="age"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="submit" name="保存"&gt; &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 如果你要返回一个动态的html的话就需要把数据传到模板文件上， 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="https://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Teacher&lt;/title&gt;&lt;/head&gt;&lt;body&gt;// 这里面取到的数据就是在Controller里面的方法传到这里才能正确的取到&lt;p th:text="$&#123;name&#125;"&gt;&lt;/p&gt;&lt;p th:text="$&#123;age&#125;"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 那么对应的方法我们就写到Controller文件里面，具体的实现的代码的方法就如下 AlphaController： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.nowcoder.community.controller;import com.nowcoder.community.service.AlphaService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.*;@Controllerpublic class AlphaController &#123; @Autowired private AlphaService alphaService; @RequestMapping("/hello") @ResponseBody public String sayHello() &#123; return "Hello Spring Boot!"; &#125; @RequestMapping("/data") @ResponseBody public String getData() &#123; return alphaService.find(); &#125; @RequestMapping("/http") public void http(HttpServletRequest request, HttpServletResponse response) &#123; //获取请求 System.out.println(request.getMethod()); System.out.println(request.getServletPath()); //消息头 Enumeration&lt;String&gt; enumeration = request.getHeaderNames(); while (enumeration.hasMoreElements()) &#123; String name = enumeration.nextElement(); String value = request.getHeader(name); System.out.println(name+": "+value); &#125; System.out.println(request.getParameter("code")); //给浏览器返回响应数据 response.setContentType("text/html;charset=utf-8"); try &#123; PrintWriter writer = response.getWriter(); writer.write("&lt;h1&gt;牛客网&lt;/h1&gt;"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(); &#125; //Get请求 // /student?current=1&amp;limit=2 // 看参数可以理解怎么把url后面带的参数给获取到，以及做更详细的说明 @RequestMapping(path = "/students", method = RequestMethod.GET) @ResponseBody public String getStudents(@RequestParam(name = "current", required = false, defaultValue = "1") int current, @RequestParam(name = "limit", required = false, defaultValue = "10") int limit) &#123; System.out.println(current); System.out.println(limit); return "some student"; &#125; // /student/123 @RequestMapping(path = "/student/&#123;id&#125;", method = RequestMethod.GET) @ResponseBody public String getStudent(@PathVariable("id") int id) &#123; System.out.println(id); return "a student"; &#125; //Post请求 @RequestMapping(path = "/student", method = RequestMethod.POST) @ResponseBody public String saveStudent(String name, int age) &#123; System.out.println(name); System.out.println(age); return "success"; &#125; //响应Html数据 @RequestMapping(path = "/teacher", method = RequestMethod.GET) public ModelAndView getTeacher() &#123; ModelAndView modelAndView = new ModelAndView(); // 你要把返回的数据传到ModelAndView上才能被模板正确的获取到 modelAndView.addObject("name","张三"); modelAndView.addObject("age",30); modelAndView.setViewName("/demo/view"); return modelAndView; &#125; // 这个方法返回html的话，最后就需要return路径 @RequestMapping(path = "/school", method = RequestMethod.GET) public String getSchool(Model model) &#123; model.addAttribute("name","背景大学"); model.addAttribute("age",80); return "/demo/view"; &#125; //响应Json数据（异步请求） // Java对象 -&gt; Json对象 -&gt; Js对象 @RequestMapping(path = "/emp", method = RequestMethod.GET) @ResponseBody // 加上返回一个Body否则就返回了一个html public Map&lt;String, Object&gt; getEmp() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("name","张三"); map.put("sal",8000); map.put("age",30); return map; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发二]]></title>
    <url>%2F2019%2F07%2F14%2FSpringBoot%E5%BC%80%E5%8F%91%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[需求介绍-Spring入门主要是理解IOC，理解容器和Bean 代码在Test里面利用getBean方法帮助我们看一下容器的创建： 那我首先要写一个Bean对象，假设是写一个访问数据库类。 AlphaDao（interface）类型： 12345package com.nowcoder.community.dao;public interface AlphaDao &#123; String select();&#125; 然后写两个类实现这个接口体验利用容器好处： AlphaDaoHibernatelmpl： 1234567891011package com.nowcoder.community.dao;import org.springframework.stereotype.Repository;@Repository("alphahibernate")//给bean重命名public class AlphaDaoHibernatelmpl implements AlphaDao &#123; @Override public String select() &#123; return "Hefakajk"; &#125;&#125; AlphaDaoMybatisImpl： 12345678910111213package com.nowcoder.community.dao;import org.springframework.context.annotation.Primary;import org.springframework.stereotype.Repository;@Repository@Primary//具有更高的优先级public class AlphaDaoMybatisImpl implements AlphaDao&#123; @Override public String select() &#123; return "fhakjhgajhga"; &#125;&#125; 这个时候就有两个Bean对象，可以通过容器管理了。 其次呢，Spring容器还可以管理bean的声明周期，实现一些业务逻辑，那我们重新再写一个Bean AlphaService： 123456789101112131415161718192021222324252627282930313233343536package com.nowcoder.community.service;import com.nowcoder.community.dao.AlphaDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Service;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@Service@Scope("prototype")//导致每次getbean都实例化很少会这样去做public class AlphaService &#123; @Autowired private AlphaDao alphaDao; //被Spring容器管理的bean只被实例化一次，因为它是单例的 public AlphaService() &#123; System.out.println("实例化AlphaService"); &#125; @PostConstruct//初始化在构造器之后 public void init() &#123; System.out.println("初始化AlphaService"); &#125; @PreDestroy//销毁之前调用，释放某些资源 public void destroy() &#123; System.out.println("销毁"); &#125; public String find() &#123; return alphaDao.select(); &#125;&#125; 上面我们都是自己写的Bean，但是有的时候我们希望能在容器中加载一个第三方的Bean， 那我们就需要自己写一个配置类，在配置类中通过Bean注解进行申明，那么就开始写一个配置类。 所有第三方的都写在config这个包里面： AlphaConfig： 123456789101112131415package com.nowcoder.community.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.text.SimpleDateFormat;//配置类，加载第三方的bean@Configurationpublic class AlphaConfig &#123; @Bean public SimpleDateFormat simpleDateFormat() &#123;//方法名就是bean的名字 return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); &#125;&#125; 但是这种都是自己去主动去获取，我们其实可以通过依赖注入来实现。 在使用之前进行申明就可以了，使用这个@Autowired注解。 上面都是bean声明，下面就是一个具体的测试的方法了。 CommunityApplicationTests： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.nowcoder.community;import com.nowcoder.community.dao.AlphaDao;import com.nowcoder.community.service.AlphaService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.BeansException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.context.assertj.ApplicationContextAssertProvider;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringRunner;import java.text.SimpleDateFormat;import java.util.Date;@RunWith(SpringRunner.class)@SpringBootTest@ContextConfiguration(classes = CommunityApplication.class)public class CommunityApplicationTests implements ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; @Test public void testApplicationContext() &#123; System.out.println(applicationContext);//获取容器 AlphaDao alphaDao = applicationContext.getBean(AlphaDao.class);//获取bean，通过类型获取bean System.out.println(alphaDao.select()); alphaDao = applicationContext.getBean("alphahibernate",AlphaDao.class); //通过名字强制获取到这个bean，这个函数默认是返回对象，所以要加后面的这个类型，使用强制转换 System.out.println(alphaDao.select()); &#125; @Test public void TestBeanManagement() &#123; AlphaService alphaService = applicationContext.getBean(AlphaService.class); System.out.println(alphaService); alphaService = applicationContext.getBean(AlphaService.class); System.out.println(alphaService); &#125; @Test public void TestBeanConfig() &#123; SimpleDateFormat simpleDateFormat = applicationContext.getBean(SimpleDateFormat.class); System.out.println(simpleDateFormat.format(new Date())); &#125; @Autowired @Qualifier("alphahibernate")//加载我们制定的bean private AlphaDao alphaDao; @Autowired private SimpleDateFormat simpleDateFormat; @Test public void TestDI() &#123; System.out.println(alphaDao.select()); System.out.println(simpleDateFormat); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JD提前批一面]]></title>
    <url>%2F2019%2F07%2F10%2FJD%E6%8F%90%E5%89%8D%E6%89%B9%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[昨天晚上面得JD提前批一面，京东云部门，面试时长35分钟，说下大致流程和面试问题吧。 自我介绍 Java和c++有哪些区别？ 为什么说Java是面向对象的？说一下面向对象的三个基本特征。 什么是多态，然后怎么实现多态的性质的？ 讲一下Java的抽象类，接口，类的区别和联系。说一下类。 说一下进程和线程的区别说道并行和并发，就解释一下并行和并发的概念 说到多线程，问了线程的安全，怎么保证线程安全，有哪些方式？ 说一下锁机制，可重入，公平，可中断锁。 重点解释了可重入锁 问了一下那个可中断锁，就是有两个线程，一个线程正在占用一个锁，另一个线程在等待然后它不想等待了，它自己给自己中断了，那么数据是怎么处理的？是直接扔还是怎么办？ 不知道。。。 说了一些synchronized关键字 说了Spring的注解，@component和@bean，有点囫囵吞枣感觉赶紧扯到了bean的生命周期上 问了@component的作用，然后说了@controller，@service，还有model层的东西，大致说了一些。 这块答的不是很好，因为很久没看了。 问了一下排序算法，问了快排和堆排有什么不同的地方，项目中为什么选择快排。 问了Redis，在项目中用到了Redis的哪些东西。 问了一个Redis和mysql中各自都存放了哪些内容，两者之间是怎么对应的？ 问了Redis碰到断电啊这些特殊情况是怎么处理的？ 如何保证数据一致性？ 最后问了一个算法题：求2的n次方，n非常大，可能都放不进内存。 刚开始我说了一个快速幂和矩阵乘法求幂运算，没注意放不进内存， 然后就说了利用字符串存储答案，然后进行乘法运算一步步的算反正就是暴力的进行运算，没有很好地想法。 然后他问了求2的（-n）次方，差不多一样的回答，没有很好地想法。。。。]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几大排序算法]]></title>
    <url>%2F2019%2F07%2F06%2F%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[插入排序原理算法原理：从整个待排序列中选出一个元素插入到已经有序的子序列中去，得到一个有序的、元素加一的子序列，直到整个序列的待插入元素为0，则整个序列全部有序。 具体的实现的时候，我们一般选择第一个元素作为有序的序列，将后面的元素插入到前面有序的序列直到整个序列有序。 时间复杂度：插入排序在最好情况下，需要比较n-1次，无需交换元素，时间复杂度为O(n);在最坏情况下，时间复杂度为O(n^2) 代码实现123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int len=15;int main()&#123; int a[len]=&#123;1,87,64,19,53,14,57,62,23,37,48,9,91,45,81&#125;; for(int i=1;i&lt;len;i++) &#123; int j=i; int temp=a[i]; while(j&gt;0) &#123; if(a[j-1]&lt;a[i])//找到第一个比它小的数的位置 &#123; for(int k=i;k&gt;j;k--)//比它大的数全部后移 a[k]=a[k-1]; a[j]=temp;//将数值附到该位置上 break; &#125; j--; &#125; &#125; for(int i=0;i&lt;len;i++) printf("%d ",a[i]); printf("\n"); return 0;&#125; 选择排序原理算法原理：为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止 算法步骤： 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 时间复杂度：无论数组原始排列如何，比较次数是不变的；对于交换操作，在最好情况下也就是数组完全有序的时候，无需任何交换移动， 在最差情况下，也就是数组倒序的时候，交换次数为n-1次。综合下来，时间复杂度为O(n^2) 代码实现12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int len=15;int main()&#123; int a[len]=&#123;1,87,64,19,53,14,57,62,23,37,48,9,91,45,81&#125;; for(int i=0;i&lt;len-1;i++) &#123; int temp=i; for(int j=i+1;j&lt;len;j++) &#123; if(a[temp]&gt;a[j]) temp=j; &#125; if(temp!=i) swap(a[temp],a[i]); &#125; for(int i=0;i&lt;len;i++) printf("%d ",a[i]); printf("\n"); return 0;&#125; 冒泡排序原理算法原理：比较相邻的元素。如果第一个比第二个大，就交换他们两个 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度分析：最优时间O(n），最差时间O(n^2)。 代码实现12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int len=15;int main()&#123; int a[len]=&#123;1,87,64,19,53,14,57,62,23,37,48,9,91,45,81&#125;; for(int i=0;i&lt;len-1;i++)//进行几轮比较，确定位置 &#123; bool flag=false;//设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已然完成。 for(int j=0;j&lt;len-1-i;j++) &#123; if(a[j]&gt;a[j+1]) &#123; swap(a[j],a[j+1]); flag=true; &#125; &#125; if(flag==false) break; &#125; for(int i=0;i&lt;len;i++) printf("%d ",a[i]); printf("\n"); return 0;&#125; 归并排序原理算法原理：是利用递归与分治的技术将数据序列划分为越来越小的半子表，再对半子表排序，最后再用递归方法将排好序的半子表合并成越来越大的有序序列。 时间复杂度：O(nlogn） 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int a[20]=&#123;5,6,9,15,4,-1,-9,5,-6,71,5,-36,2,15,48,-15,14,6,9,11&#125;;int l,r;void mergee(int l,int m,int r)&#123; int T[20]; int i=l,j=m+1; int k=0; while(i&lt;=m&amp;&amp;j&lt;=r) &#123; if(a[i]&lt;=a[j]) T[k++]=a[i++]; else T[k++]=a[j++]; &#125; while(i&lt;=m) T[k++]=a[i++]; while(j&lt;=r) T[k++]=a[j++]; for(int i=0;i&lt;k;i++) a[l+i]=T[i];&#125;int mergr_sort(int l,int r)&#123; if(r-l&gt;0) &#123; int mid=(l+r)/2; int p=l,q=mid,i=l; mergr_sort(l,mid); mergr_sort(mid+1,r); mergee(l,mid,r); &#125;&#125;int main()&#123; scanf("%d %d",&amp;l,&amp;r); mergr_sort(l,r); for(int i=0;i&lt;20;i++) printf("%d ",a[i]); printf("\n"); return 0;&#125; 快速排序原理通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。继续递归的对长度较短的序列进行同样的分割，最后到达整体有序。为了实现一次划分，我们可以从数组（假定数据是存在数组中）的两端移动下标，必要时交换记录，直到数组两端的下标相遇为止。为此，我们附设两个指针（下角标）i和j， 通过j 从当前序列的有段向左扫描，越过不小于基准值的记录。当遇到小于基准值的记录时，扫描停止。通过i从当前序列的左端向右扫描，越过小于基准值的记录。当遇到不小于基准值的记录时，扫描停止。交换两个方向扫描停止的记录 a[j] 与 a[i]。 然后，继续扫描，直至 i 与j 相遇为止。它的平均时间复杂度为O(nlogn)。 当我们每次进行分区划分时，如果每次选择的基准元素都是当前序列中最大或最小的记录，这样每次分区的时候只得到了一个新分区，另一个分区为空，并且新分区只是比分区前少一个元素，这是快速排序的最坏情况，时间复杂度上升为O(n^2)。 代码实现1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int len=15;int a[len]=&#123;1,87,64,19,53,14,57,62,23,37,48,9,91,45,81&#125;;void quicksort(int l,int r)&#123; if(l&gt;r) return; int temp=a[l]; int i=l;int j=r; while(i!=j) &#123; while(a[j]&gt;=temp&amp;&amp;i&lt;j) j--;/*为什么要从右边，因为我们选择的基数是从左边开始选择的，开始的方向必须是要从基数的对面开始，如果你要从左边开始找那么选择基数的时候就从右边的数作为基数*/ while(a[i]&lt;=temp&amp;&amp;i&lt;j) i++; if(i&lt;j) swap(a[i],a[j]); &#125; a[l]=a[i]; a[i]=temp; quicksort(l,i-1); quicksort(i+1,r);&#125;int main()&#123; quicksort(0,14); for(int i=0;i&lt;len;i++) printf("%d ",a[i]); printf("\n"); return 0;&#125; 堆排序原理利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。 该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是： 大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2] 小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2] 算法步骤： 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; 将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package sortdemo;import java.util.Arrays;public class HeapSort &#123; public static void main(String []args)&#123; int []arr = &#123;9,8,7,6,5,4,3,2,1&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void sort(int []arr)&#123; //1.构建大顶堆 for(int i=arr.length/2-1;i&gt;=0;i--)&#123; //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(arr,i,arr.length); &#125; //2.调整堆结构+交换堆顶元素与末尾元素 for(int j=arr.length-1;j&gt;0;j--)&#123; swap(arr,0,j);//将堆顶元素与末尾元素进行交换 adjustHeap(arr,0,j);//重新对堆进行调整 &#125; &#125; /** * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上） * @param arr * @param i * @param length */ public static void adjustHeap(int []arr,int i,int length)&#123; int temp = arr[i];//先取出当前元素i for(int k=i*2+1;k&lt;length;k=k*2+1)&#123;//从i结点的左子结点开始，也就是2i+1处开始 if(k+1&lt;length &amp;&amp; arr[k]&lt;arr[k+1])&#123;//如果左子结点小于右子结点，k指向右子结点 k++; &#125; if(arr[k] &gt;temp)&#123;//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换） arr[i] = arr[k]; i = k; &#125;else&#123; break; &#125; &#125; arr[i] = temp;//将temp值放到最终的位置 &#125; /** * 交换元素 */ public static void swap(int []arr,int a ,int b)&#123; int temp=arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125;&#125; 几种排序算法的比较示意图]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql的几种连接和引擎]]></title>
    <url>%2F2019%2F07%2F01%2FMysql%E7%9A%84%E5%87%A0%E7%A7%8D%E9%93%BE%E6%8E%A5%E5%92%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[Mysql的连接内连接结果： 从左表中取出每一条记录，去右表中与所有的记录进行匹配； 匹配必须是某个条件是左表中与右表中相同，才会保留结果，否则不保留； 等值连接：在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复列。 不等值连接：在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。 基本语法：左表[inner] join 右表on左表.字段 = 右表.字段，如下： 1select * from book as a,stu as b where a.sutid = b.stuid 外连接结果：以某张表为主，取出里面的所有记录， 然后每条与另外一张表进行连接， 不管能不能匹配上条件，最终都会保留， 能匹配，正确保留； 不能匹配其他表的字段都置空null 左联接：是以左表为基准，将a.stuid = b.stuid的数据进行连接，然后将左表没有的对应项显示，右表的列为NULL 右连接：是以右表为基准，将a.stuid = b.stuid的数据进行连接，然以将右表没有的对应项显示，左表的列为NULL 基本语法：左表 left/right join右表on 左表.字段 = 右表.字段；——条件必须有，如下： 12select * from book as a right join stu as b on a.sutid = b.stuid （右连接）select * from book as a left join stu as b on a.sutid = b.stuid （左连接） 交叉连接结果：交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。 1select * from book as a cross join stu as b order by a.id 自然连接结果：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。 MySql中主要使用的引擎InnoDB 引擎MySQL 5.5 及以后版本中的默认存储引擎，它的优点如下：灾难恢复性好，支持事务，使用行级锁，支持外键关联，支持热备份。 InnoDB引擎中的表，其数据的物理组织形式是簇表（Cluster Table），主键索引和数据是在一起的，数据按主键的顺序物理分布。实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的获取。 MyISAM引擎它的特性如下：不支持事务；使用表级锁，并发性差；主机宕机后，MyISAM表易损坏，灾难恢复性不佳；可以配合锁，实现操作系统下的复制备份、迁移；只缓存索引，数据的缓存是利用操作系统缓冲区来实现的。可能引发过多的系统调用且效率不佳；数据紧凑存储，因此可获得更小的索引和更快的全表扫描性能。 上面这两个是最常用的Mysql引擎。它们两者的主要区别：InnoDB支持事务，MyISAM不支持；MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用；InnoDB支持外键，MyISAM不支持；清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表；InnoDB支持行锁，MyISAM的全表锁；InnoDB中不保存表的行数，如select count(*) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表。 总之：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持；MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2019%2F07%2F01%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java语言的特点和特性Java语言的主要特点跨平台性所谓的跨平台性，是指软件可以不受计算机硬件和操作系统的约束而在任意计算机环境下正常运行。这是软件发展的趋势和编程人员追求的目标。之所以这样说，是因为计算机硬件的种类繁多，操作系统也各不相同，不同的用户和公司有自己不同的计算机环境偏好，而软件为了能在这些不同的环境里正常运行，就需要独立于这些平台。而在Java语言中，Java自带的虚拟机很好地实现了跨平台性。Java源程序代码经过编译后生成二进制的字节码是与平台无关的，但是可被Java虚拟机识别的一种机器码指令。 Java虚拟机提供了一个字节码到底层硬件平台及操作系统的屏障，使得Java语言具备跨平台性。 Java字节码是Java虚拟机执行的一种指令格式，具体的可以看维基百科 面向对象面向对象是指以对象为基本粒度，其下包含属性和方法。对象的说明用属性表达，而通过使用方法来操作这个对象。面向对象技术使得应用程序的开发变得简单易用，节省代码。Java是一种面向对象的语言，也继承了面向对象的诸多好处，如代码扩展、代码复用等。 安全性安全性可以分为四个层面，即语言级安全性、编译时安全性、运行时安全性、可执行代码安全性。语言级安全性指Java的数据结构是完整的对象，这些封装过的数据类型具有安全性。编译时要进行Java语言和语义的检查，保证每个变量对应一个相应的值，编译后生成Java类。运行时Java类需要类加载器载入www jxzxmr net，并经由字节码校验器校验之后才可以运行。 Java类在网络上使用时，对它的权限进行了设置，保证了被访问用户的安全性。 多线程多线程在操作系统中已得到了最成功的应用。多线程是指允许一个应用程序同时存在两个或两个以上的线程，用于支持事务并发和多任务处理。 Java除了内置的多线程技术之外，还定义了一些类、方法等来建立和管理用户定义的多线程。 简单易用Java源代码的书写不拘泥于特定的环境，可以用记事本、文本编辑器等编辑软件来实现，然后将源文件进行编译，编译通过后可直接运行，通过调试则可得到想要的结果。 Java语言的几大特性封装封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。封装是一种信息隐藏技术，在java中通过关键字private，protected和public实现封装。什么是封装？封装把对象的所有组成部分组合在一起，封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。 适当的封装可以让程式码更容易理解和维护，也加强了程式码的安全性。 继承继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 Java继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。这种技术使得复用以前的代码非常容易，能够大大缩短开发周期，降低开发费用 多态按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作多态的话，我觉得是更好的利用了继承这一特性，然后为什么能实现多态，因为可以重写父类的方法。说重写可能不清楚，具体来说就是子类父类可以存在分别存在名字相同的属性或者方法，然后可视声明的类去调用相应的方法等。 多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作.多态存在的三个必要条件 继承 重写 父类引用指向子类对象 这个时候有个问题子类继承父类，子类的所有构造函数中的第一行，其实都有一条隐身的语句super()；默认调用父类的无参构造函数。若父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数，否则会报错。 多态通常有两种实现方法： 子类继承父类 类实现接口要使用多态，在声明对象时就应该遵循一条法则：声明的总是父类类型或接口类型，创建的是实际类型。多态最大的用途我认为在于对设计和架构的复用更进一步来说，设计模式中提倡的针对接口编程而不是针对实现编程就是充分利用多态的典型例子。定义功能和组件时定义接口，实现可以留到之后的流程中。同时一个接口可以有多个实现，甚至于完全可以在一个设计中同时使用一个接口的多种实现 底层的原理可以看下面的介绍 抽象抽象是通过分析与综合的途径，运用概念在人脑中再现对象的质和本质的方法，我觉得理解成一种方法比较好。就是我们通过对事物的认知，将某一或者一类事物的属性变化成JAVA语言能识别的类。 Java和c++有哪些区别 Java为解释性语言，运行过程为由编译器将Java代码转换为字节码，然后由虚拟机解释执行。C/C++为编译型语言，源代码经过编译和链接生成可执行的二进制代码。因此，Java的执行速度比C/C++慢，但是Java能跨平台，C/C++不行。 Java为纯面向对象语言，所有代码必须在类中实现，C/C++兼具面向对象和面向过程的特点，可以定义全局变量和函数。 与C/C++语言相比，Java语言中没有指针的概念，这有效防止了C/C++语言中操作指针可能引起的系统问题，从而使程序变得安全。 Java没有多重继承，但是Java语言引入了接口的概念，可以同时实现多个接口，达到C++中多重继承的目的。 在C++中，需要开发人员管理对内存的分配（包括申请与释放），而Java语言提供了垃圾回收器来实现垃圾的自动回收。 Java具有平台无关性，C++没有。 还有一些语言特性。包括运算符重载，预处理，默认函数参数，goto语句，自动强制转换等语言本身特性不同。 类，内部类，抽象类，接口类类是一个模板，它描述一类对象的行为和状态。包含局部变量，成员变量，类变量，类方法。 内部类有四种常见的类型：成员内部类、局部内部类、匿名内部类和静态内部类。 成员内部类定义为另一个类的里面 1234567891011class Circle &#123; double radius = 0; public Circle(double radius) &#123; this.radius = radius; &#125; class Point&#123; //内部类 public void DrawPoint() &#123; System.out.println("DrawPoint"); &#125; &#125;&#125; 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。 同时需要注意当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员，如果要访问外部类的同名成员，需要以下面的形式进行访问： 12外部类.this.成员变量外部类.this.成员方法 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 1234567891011121314class People&#123; public People() &#123; &#125;&#125;class Man&#123; public Man()&#123; &#125; public People getWoman()&#123; class Woman extends People&#123; //局部内部类 int age =0; &#125; return new Woman(); &#125;&#125; 局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。 匿名内部类大部分匿名内部类用于接口回调。 静态内部类静态内部类也是定义在另一个类里面的类，但是在类的前面多了一个关键字static。它是不需要不需要依赖于外部类的，它可以因为在没有外部类的对象的情况下，可以创建静态内部类的对象，也因此它不能使用外部类的非static成员变量或者方法。 12345678910111213public class Test &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); &#125;&#125;class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 局部内部类和匿名内部类只能访问局部final变量如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值，这样就会出现数据不一致的情况的发生。 抽象类抽象类是用来捕捉子类的通用特性的 。它不能被实例化。抽象方法可以继承一个类和实现多个接口。子类使用extends关键字来继承抽象类。 接口接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。且接口方法默认修饰符是public。你不可以使用其它修饰符。接口只可以继承一个或多个其它接口。子类使用关键字implements来实现接口。 接口和抽象类的区别 抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现。 抽象类使用extends关键字来继承抽象类，子类使用关键字implements来实现接口 抽象类可以有构造器，而接口不能有构造器 抽象方法可以有public、protected和default这些修饰符，接口方法默认修饰符是public。你不可以使用其它修饰符。 抽象类与普通类的区别 普通类可以去实例化调用；抽象类不能被实例化，因为它是存在于一种概念而不非具体。 普通类和抽象类都可以被继承，但是抽象类被继承后子类必须重写继承的方法，除非自类也是抽象类。 Java访问修饰符 default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 this关键字和super关键字this关键字指向的是当前对象的引用，this();访问本类的构造方法，()中可以有参数的 如果有参数 就是调用指定的有参构造。注意事项：this()不能使用在普通方法中 只能写在构造方法中；必须是构造方法中的第一条语句 super在一个类中用来引用其父类的成员，它是在子类中访问父类成员的一个桥梁，并不是任何一个对象的引用。作用在于当子类中覆盖了父类的某个成员变量，或者重写了父类的某个成员方法时还能够访问到父类的成员变量和成员方法。 super.getClass()和this.getClass()返回的都是new对象时指定的类 Object类Object类是类层次结构的根，Java中所有的类从根本上都继承自这个类。Object类是Java中其他所有类的祖先，位于java.lang包中。 getClass方法getClass方法是一个final方法，不允许子类重写，并且也是一个native方法。 hashCode方法hashCode方法也是一个native方法。该方法返回对象的哈希码，一个对象没有被改变的前提下，无论这个对象被调用多少次，hashCode方法都会返回相同的整数值。 equals方法比较两个对象是否相等。如果重写了equals方法，通常有必要重写hashCode方法。 因为如果2个对象使用equals方法进行比较并且相同的话，那么这2个对象的hashCode方法的值也必须相等。如果2个对象的equals方法相等，那么他们的hashCode值也必须相等，反之，如果2个对象hashCode值相等，但是equals不相等，这样会影响性能，所以还是建议2个方法都一起重写。 toString方法Object对象的默认实现，即输出类的名字@实例的哈希码的16进制。 == 和 equals 的区别是什么？直接使用==操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用equals()。 ==对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了equals方法，比如String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。 若对一个类不重写，它的equals()方法是如何比较的比较是对象的地址 基本数据类型 注意：String 不属于基础类型，它属于对象。 自动装箱和自动拆箱自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把 int 转化成 Integer，double 转化成 Double，等等。反之就是自动拆箱。 StringJava 中String是一个不可变类，即创建一个String对象后，是不能直接改变字符串中的某个字符的。 为什么不可变？好处在哪？因为用于存储String值的仍然是一个char型数组，并且注意到它是final修饰的，不可更改。 效率（因为对象不可变，所以可以使用常量池的方式优化效率；因为对象不可变，所以String对象可以自身缓存HashCode） 安全（String被许多的Java类(库)用来当做参数,例如 网络连接地址URL,文件路径path,还有反射机制所需要的String参数等, 假若String不是固定不变的,将会引起各种安全隐患） String 常量池对于不可变对象使用String常量池，不然修改变量string1的值，string2的值也发生变化了。常量池的存在无疑大大降低了创建、拷贝等操作的时间复杂度和空间复杂度。 12345678String s1="ab"+“cd”;String s2="abc"+"d";System.out.println(s1==s2);//TrueString s3=new String("ab");String s4=new String("ab");System.out.println(s3==s4);//Flase 由答案可以知道：String类确实是不可变类，&quot;ab&quot;+&quot;cd&quot;被当做了新字符串而不是续接&quot;ab&quot;（不然&quot;ab&quot;和&quot;abc&quot;肯定不会地址一样）；常量池确实存在，同是&quot;abcd&quot;，所有对&quot;abcd&quot;的引用都指向同一地址；如果使用new的话就会直接分配新的地址。 String， Stringbuffer， StringBuilder 的区别。 String 字符串常量(final修饰，不可被继承)，线程不安全，String是常量，当创建之后即不能更改。(可以通过StringBuffer和StringBuilder创建String对象(常用的两个字符串操作类)。) StringBuffer 字符串变量（线程安全）其toString方法会进行对象缓存，以减少元素复制开销，支持同步锁。 StringBuilder 字符串变量（非线程安全）其toString的时候，会直接返回一个新对象。 int 和Integer区别 int是一个基本数据类型，而Integer是int的包装类。 Integer 变量必须要实例化之后才能使用。 Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 。 Integer的默认值是null，int的默认值是0。 比较 两个int 的比较，就不用说了，就平常的数值比较即可。 两个new 生成的Integer 比较，由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。调用equals函数返回true。 Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false。调用equals函数返回true。 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） Integer常量池Integer i = value;如果i是在-128到127之间，不会去堆中创建对象，而是直接返回IntegerCache中的值;如果值不在上面范围内则会从堆中创建对象。=走的是valueOf()方法,valueOf(int)会走缓存。Integer i2 = new Integer(xxxx);不管参数的value是多少都会从堆中创建对象，与IntegerCache没关系。 常量池都是放在方法区的。 Static关键字static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途，只要类被加载了，就可以通过类名去进行访问。 static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 Final关键字 修饰类当用final去修饰一个类的时候，表示这个类不能被继承。注意： a. 被final修饰的类，final类中的成员变量可以根据自己的实际需要设计为fianl。 b. final类中的成员方法都会被隐式的指定为final方法。 被final修饰的方法不能被重写： a. 一个类的private方法会隐式的被指定为final方法。 b. 如果父类中有final修饰的方法，那么子类不能去重写。 修饰成员变量，必须要赋初始值，而且是只能初始化一次。 类初始化顺序 非继承关系中的初始化顺序：static静态代码块和静态成员 -&gt; 普通成员 -&gt; 构造函数执行 继承的子类：父类静态代码块和静态成员 -&gt; 子类静态代码块和静态成员 -&gt;父类普通成员和非static块 -&gt; 父类构造函数 -&gt; 子类普通成员和非static块 -&gt; 子类构造函数 。 Java的容器和容器原理以及之间的区别Java容器分为 Collection和 Map 两大类 ArrayList实现原理 ArrayList是List接口的可变数组非同步实现，并允许包括null在内的所有元素。 底层使用数组实现 该集合是可变长度数组，数组扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量增长大约是其容量的1.5倍，这种操作的代价很高。 采用了Fail-Fast机制 remove方法会让下标到数组末尾的元素向前移动一个单位，并把最后一位的值置空，方便GC LinkedList实现原理 LinkedList是List接口的双向链表非同步实现，并允许包括null在内的所有元素。 底层的数据结构是基于双向链表的，该数据结构我们称为节点 双向链表节点对应的类Node的实例，Node中包含成员变量：prev，next，item。其中，prev是该节点的上一个节点，next是该节点的下一个节点，item是该节点所包含的值。 它的查找是分两半查找，先判断index是在链表的哪一半，然后再去对应区域查找，这样最多只要遍历链表的一半节点即可找到 ArrayList 和 LinkedList 区别ArrayList 和 LinkedList 都是实现了 List 接口的容器类，用于存储一系列的对象引用。他们都可以对元素的增删改查进行操作。 ArrayList 是实现了基于动态数组的数据结构，LinkedList 是基于链表结构。 ArrayList 可以以 O(1) 时间复杂度对元素进行随机访，LinkedList 则是 O(n) 的复杂度。 新增和删除操作 add 和 remove，LinkedList 时间复杂度为 O(1)，而 ArrayList 为 O(n)，因为要移动数据。对ArrayList 和 LinkedList 而言，在列表末尾增加一个元素所花的开销都是固定的都是 O(1)。LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 ArrayList 并发 add() 可能出现数组下标越界异常。 ArrayList 和 Vector 的区别 线程安全：Vector ，在add的时候使用了Synchronized来实现线程同步，是线程安全的，而ArrayList是非线程安全的。 性能：ArrayList在性能方面要优于 Vector。 扩容：ArrayList 和Vector都会根据实际的需要动态的调整容量，只不过在Vector 扩容每次会增加 1 倍，而ArrayList 只会增加 50%。 实现数组和 List 之间的转换 数组转 List：使用 Arrays. asList(array) 进行转换。 List 转数组：使用 List自带的 toArray()方法。 三种方式访问集合中的元素传统的for循环遍历123for (int i = 0; i &lt; list.size(); i++) &#123; list.get(i);&#125; 迭代器遍历1234Iterator iterator = list.iterator();while (iterator.hasNext()) &#123; iterator.next();&#125; foreach循环遍历12for (ElementType element : list) &#123;&#125; ArrayList遍历删除会出的问题for循环遍历list：删除某个元素后，list的大小发生了变化，而你的索引也在变化，所以会导致你在遍历的时候漏掉某些元素。比如当你删除第1个元素后，继续根据索引访问第2个元素时，因为删除的关系后面的元素都往前移动了一位，所以实际访问的是第3个元素。因此，这种方式可以用在删除特定的一个元素时使用，但不适合循环删除多个元素时使用。解决方法是从后遍历 foreach循环：删除元素后继续循环会报错误信息ConcurrentModificationException，因为元素在使用的时候发生了并发的修改，导致异常抛出 iterator遍历这种方式可以正常的循环及删除。但要注意的是，使用iterator的remove方法，如果用list的remove方法同样会报上面提到的ConcurrentModificationException错误。 添加也是上面分析情况。 具体原因：http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtyfour.html Map的排序TreeMap：基于红黑树的 NavigableMap 实现，该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的Comparator 进行排序，具体取决于使用的构造方法。 123456789101112131415161718192021222324252627import java.util.Comparator;import java.util.Iterator;import java.util.Map;import java.util.Set;import java.util.TreeMap;public class TreeMapTest &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;( new Comparator&lt;String&gt;() &#123; public int compare(String obj1, String obj2) &#123; // 降序排序 return obj2.compareTo(obj1); &#125; &#125;); map.put("b", "ccccc"); map.put("d", "aaaaa"); map.put("c", "bbbbb"); map.put("a", "ddddd"); Set&lt;String&gt; keySet = map.keySet(); Iterator&lt;String&gt; iter = keySet.iterator(); while (iter.hasNext()) &#123; String key = iter.next(); System.out.println(key + ":" + map.get(key)); &#125; &#125;&#125; 我们需要根据TreeMap的value来进行排序。对value排序我们就需要借助于Collections的sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)方法，该方法根据指定比较器产生的顺序对指定列表进行排序。但是有一个前提条件，那就是所有的元素都必须能够根据所提供的比较器来进行比较。 1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.TreeMap;public class TreeMapTest &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(); map.put("a", "ddddd"); map.put("c", "bbbbb"); map.put("d", "aaaaa"); map.put("b", "ccccc"); //这里将map.entrySet()转换成list List&lt;Map.Entry&lt;String,String&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet()); //然后通过比较器来实现排序 Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() &#123; //升序排序 public int compare(Entry&lt;String, String&gt; o1, Entry&lt;String, String&gt; o2) &#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for(Map.Entry&lt;String,String&gt; mapping:list)&#123; System.out.println(mapping.getKey()+":"+mapping.getValue()); &#125; &#125;&#125; HashMap的值是没有顺序的，他是按照key的HashCode来实现的，那么它排序的方式和TreeMap的Value方式是一样的。 1234567891011121314151617181920212223public class HashMapTest &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("c", "ccccc"); map.put("a", "aaaaa"); map.put("b", "bbbbb"); map.put("d", "ddddd"); List&lt;Map.Entry&lt;String,String&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() &#123; //升序排序 public int compare(Entry&lt;String, String&gt; o1, Entry&lt;String, String&gt; o2) &#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for(Map.Entry&lt;String,String&gt; mapping:list)&#123; System.out.println(mapping.getKey()+":"+mapping.getValue()); &#125; &#125;&#125; Set数据为什么是不重合我们知道常用的Set实现类那就是HashSet了，查看HashSet的源码可以看到内部其实就是一个HashMap，因为HashMap在put一个Key时会判断，将要放进去的Key的hash值与 目前HashMap中定位到的那个Key的hash值比较。如果hash值相当，继续比较 这两个对象的地址或者内容是否相当。如果相当：判断出来要添加的Key与HashMap中的Key重复，把Value的值给替换成最新的。也就是理解的hashcode()和equals()的区别 Iterator和ListIterator的区别Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历List。Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 泛型本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 123456789List arrayList = new ArrayList();arrayList.add("aaaa");arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); Log.d("泛型测试","item = " + item);&#125;// 解决方案List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); 毫无疑问，程序的运行结果会以崩溃结束：ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。 注意：泛型只在编译阶段有效，在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。但是在在return之前，会根据泛型变量进行强转 泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 反射Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。注意：使用反射机制可以打破封装性，导致了java对象的属性不安全。 反射的好处：可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等。 有三种得到class 方式：通过 Class 对象的forName()静态方法来获取；直接通过 类名.class的方式得到,该方法最为安全可靠；通过对象调用 getClass() 方法来获取。注意：一个类在JVM 中只会有一个class 实例，所以三种方法得到的class 的地址到最后都是相等的。 Throwable、error、exception的区别异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用空的引用、数组下标越界、内存溢出错误等。Throwable 类是Java语言中所有错误或异常的超类。有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。4 异常和错误的本质区别：异常能被程序本身处理，而错误无法处理。Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。 怎么catch？catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception及其子类，捕捉的范围更小。 Error：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM出现的问题。 异常的种类主要是分为运行时异常和非运行异常 Checked Exception（非 Runtime Exception） Unchecked Exception（Runtime Exception） Java 中凡是继承自 Exception，而不继承自 RuntimeException 类的异常都是非运行时异常。所有非运行时异常都必须进行处理不然无法通过编译 算术异常类：ArithmeticExecption 空指针异常类：NullPointerException 类型强制转换异常：ClassCastException 数组负下标异常：NegativeArrayException 数组下标越界异常：ArrayIndexOutOfBoundsException 违背安全原则异常：SecturityException 文件已结束异常：EOFException 文件未找到异常：FileNotFoundException 字符串转换为数字异常：NumberFormatException 操作数据库异常：SQLException 输入输出异常：IOException Java反射Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。注意：使用反射机制可以打破封装性，导致了java对象的属性不安全。 好处可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等。 实现方式 通过 Class对象的forName()静态方法来获取； 直接通过 类名.class的方式得到,该方法最为安全可靠； 通过对象调用 getClass() 方法来获取。 注意：一个类在JVM 中只会有一个class 实例，所以三种方法得到的class的地址到最后都是相等的。 常用APIgetName()：获得类的完整名字；getDeclaredFields()：获得类的所有属性。包括private声明的和继承类；getMethods()：获得类的public类型的方法； java创建线程的四种方式继承Thread类创建线程类 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 创建Thread子类的实例，即创建了线程对象。 调用线程对象的start()方法来启动该线程。 12345678910111213141516171819202122232425package com.thread;public class FirstThreadTest extends Thread&#123; int i = 0; //重写run方法，run方法的方法体就是现场执行体 public void run() &#123; for(;i&lt;100;i++)&#123; System.out.println(getName()+" "+i); &#125; &#125; public static void main(String[] args) &#123; for(int i = 0;i&lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+" : "+i); if(i==20) &#123; new FirstThreadTest().start(); new FirstThreadTest().start(); &#125; &#125; &#125;&#125;// Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返回调用该方法的线程的名字。 通过Runnable接口创建线程类 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动该线程。 123456789101112131415161718192021222324package com.thread;public class RunnableThreadTest implements Runnable&#123; private int i; public void run() &#123; for(i = 0;i &lt;100;i++) &#123; System.out.println(Thread.currentThread().getName()+" "+i); &#125; &#125; public static void main(String[] args) &#123; for(int i = 0;i &lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+" "+i); if(i==20) &#123; RunnableThreadTest rtt = new RunnableThreadTest(); new Thread(rtt,"新线程1").start(); new Thread(rtt,"新线程2").start(); &#125; &#125; &#125; 通过Callable和Future创建线程 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值 123456789101112131415161718192021222324252627282930313233343536373839package com.demo;import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class CallableThreadTest implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(ctt); // Thread thread = new Thread(ft,"有返回值的线程");// thread.start(); for(int i = 0;i &lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+" 的循环变量i的值"+i); if(i==20) &#123; new Thread(ft,"有返回值的线程").start(); &#125; &#125; try &#123; System.out.println("子线程的返回值："+ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for(;i&lt;100;i++) &#123; System.out.println(Thread.currentThread().getName()+" "+i); &#125; return i; &#125; &#125; 通过线程池创建线程线程实现callable接口和runnable接口的区别 Callable规定的方法是call(),Runnable规定的方法是run() Callable有返回值，Runnable没有返回值 Runnable没有容错机制，意味着如果出现异常必须立即处理；Callable有容错机制，意味着出现异常之后可以向上抛出 Runnable可以通过Thread来启动，也可以通过线程池的execute、submit来处理；Callable线程只能通过线程池的submit来处理 Java实现多线程就是利用上面的四种方式实现多线程 线程中start和run的区别总结一下： start()可以启动一个新线程，run()不能 start()不能被重复调用，run()可以 start()中的run代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用run方法必须等待其代码全部执行完才能继续执行下面的代码。 start() 实现了多线程，run()没有实现多线程。 start() :它的作用是启动一个新线程。通过start()方法来启动的新线程，处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行相应线程的run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止。start()不能被重复调用。用start方法来启动线程，真正实现了多线程运行，即无需等待某个线程的run方法体代码执行完毕就直接继续执行下面的代码。这里无需等待run方法执行完毕，即可继续执行下面的代码，即进行了线程切换。 run() :run()就和普通的成员方法一样，可以被重复调用。如果直接调用run方法，并不会启动新线程！程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。 四种方式哪种更好一点实现 Runnalbe 接口更好，使用实现 Runnable 接口的方式创建的线程可以处理同一资源，从而实现资源的共享。 sleep()，wait()，yield()和join()方法sleep()sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。 wait()wait()方法需要和notify()及notifyAll()两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，它们都是Object类的方法，而不是Thread类的方法。 那如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTrantLock.newCondition()获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面的三个方法。 yield()yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。 join()join()方法会使当前线程等待调用join()方法的线程结束后才能继续执行。join()无参形式等价于join(0)，wait()类似。 sleep()与wait()的区别 这两个方法来自不同的类，sleep 是 Thread 类的方法，而 wait 是 Object 类的方法； 执行sleep方法后不会释放锁，而执行 wait 方法后会释放锁； wait，notify 和 notifyAll 只能在同步方法或同步代码块中调用，而sleep可以在任何地方调用； sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常。（如果不是在同步方法或同步代码块中调用wait() 方法，则抛出 IllegalMOnitorStateException，它是 RuntimeException 的一个子类，因此，不需要 try-catch 语句进行捕捉异常） 需要注意以下几点： 在执行 notify() 或 notifyAll() 方法后，当前线程不会马上释放该对象锁，需要等到 notify() 或 notifyAll() 方法所在的同步方法或同步代码块执行完成，当前线程才会释放锁。 在 sleep() 状态下 interrupt() 中断线程，会进入 catch 语句，并且清除停止状态值，使之变成 false。 wait(long) 方法：如果线程在指定时间内未被唤醒，则自动唤醒。wait(0) 等价于 wait()。 Thread.Sleep(0) 的作用是“触发操作系统立刻重新进行一次 CPU 竞争。 sleep()与 yield()的区别 sleep()方法给其他线程运行机会时不考虑其他线程的优先级，因此会给低优先级的线程运行的机会；yield()方法只会给相同优先级或更高优先级的线程运行的机会。 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态。 sleep()方法声明抛出InterruptedException异常，而yield()方法没有声明任何异常。 sleep()方法比yield()方法具有更好的可移植性（跟操作系统CPU调度相关）。 sleep方法需要参数，而yield方法不需要参数。 wait 方法底层原理输入一个URL回车之后的过程是什么，涉及到了哪些协议个人感觉涉及到的协议有：HTTP，TCP，DNS，ARP这四个协议 DNS域名解析：我们在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器IP地址这项工作，是由DNS服务器来完成的。客户端收到你输入的域名地址后，它首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找DNS服务器。一般用户很少去编辑修改hosts文件。浏览器客户端向本地DNS服务器发送一个含有域名www.cnblogs.com的DNS查询报文。本地DNS服务器把查询报文转发到根DNS服务器，根DNS服务器注意到其com后缀，于是向本地DNS服务器返回comDNS服务器的IP地址。本地DNS服务器再次向comDNS服务器发送查询请求，comDNS服务器注意到其www.cnblogs.com后缀并用负责该域名的权威DNS服务器的IP地址作为回应。最后，本地DNS服务器将含有www.cnblogs.com的IP地址的响应报文发送给客户端。从客户端到本地服务器属于递归查询，而DNS服务器之间的交互属于迭代查询。正常情况下，本地DNS服务器的缓存中已有comDNS服务器的地址，因此请求根域名服务器这一步不是必需的 建立TCP连接； 发送HTTP请求； 服务器处理请求； 返回响应结果； 关闭TCP连接； 浏览器解析HTML； 浏览器布局渲染； Java是值传递还是引用传递首先按值调用是表示方法接收的是调用者提供的值。而按引用调用表示方法接收的是调用者提供的变量地址。 java 里对象传递的时候，传递的都是引用（也就是对象的地址），这比传递整个对象高效的多。而基础类型，int，double 等传递的才是值。 但是当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。 Java的null类型理解一下null12345678public class NULL &#123; private static void haha() &#123; System.out.println("Haha"); &#125; public static void main(String[] args) &#123; ((NULL)null).haha(); &#125;&#125; 输出应该为 ：haha，因为null是可以强转为任何类类型的，所以前面（（NULL）null）是合法的，但是null强转以后是无效对象，其返回值为null 而haha方法是静态方法，静态方法使用静态绑定，不会抛出空指针异常。如果把haha()函数变为非静态之后将会抛出空指针异常。 Java语言中有两种类型，一种是基本类型还有一种是引用类型。还有一个特殊的null类型即表达式null的类型。null既不是对象也不是一种类型也不是java.lang.Object的实例，它仅仅是一个特殊的值。 因为null类型没有名字，所以不可能声明为null类型的变量或者转换为null类型。null引用是null类型表达式唯一可能的值。null引用可以转换为任意引用类型。 java创建对象时，new 出一个对象 和 = null的区别看个例子解释： (new ArrayList&lt;String&gt;).add(new String(&quot;hello&quot;))，jvm只是把new String(&quot;hello&quot;)的地址存入到了列表list里面。String str = new String(&quot;Test&quot;)，是开辟内存放入了对象，并把它的引用赋给str。同理，BookInfo bookinfo=null与BookInfo bookinfo=new BookInfo()：前者，是声明了一个对象（的引用），jvm并没有开辟内存放入一个对象；而后者，在声明了一个对象的引用后，又把新开辟的没有存储任何有效值的对象的地址赋给了他。bookinfo=test.getinfo()，又把它指向了另一个地址= =也就是说原来开辟的内存并没有用，那就没有意义。但是java虚拟机自动垃圾回收机制会判断并回收内存的。 所以如果你的类在创建后，要自己读写数据，那就必须初始化；如果像Bookinfo那样，完全是为了从其他地方接收引用，也完全可以省了new吧。 空串与null串空串””是长度为0的字符串它是一个java对象，有自己的串长度(0)和内容(空)。null串表示一个特殊的String变量，它表示目前没有任何对象与该变量关联。 System.out.println原理System是java.lang包中的一个类，里面封装了一些系统相关的重要函数与变量。它其中类中的所有成员都是静态的，out是一个PrintStream类(java.io.PrintStream类)的对象 System.out.println性能并不好。当我们深入分析时，其调用顺序如下println - &gt; print - &gt; write（）+ newLine（）。这个顺序流是Sun / Oracle JDK的实现。write（）和newLine（）都包含synchronized块。同步有一点开销，但更多的是添加字符到缓冲区和打印的开销更大。所以一般都用日志。 一般打印对象的时候都会调用对象的toString()方法打印出这个函数的返回值，但是我们一般重写对象的toString()方法，按照自己的想法输出。 Java多态的底层原理多态分为两种情况：编译时多态和运行时多态。如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态。可以看这个博客，上面的示例很清楚： https://blog.csdn.net/why_still_confused/article/details/51295707 多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。动态绑定涉及很多JVM 的细节。JVM 的方法调用指令有五个，分别是： invokestatic：调用静态方法； invokespecial：调用实例构造器&lt;init&gt;方法、私有方法和父类方法； invokevirtual：调用虚方法； invokeinterface：调用接口方法，运行时确定具体实现； invokedynamic：运行时动态解析所引用的方法，然后再执行，用于支持动态类型语言。 其中，invokestatic 和invokespecial用于静态绑定，invokevirtual和invokeinterface 用于动态绑定。可以看出，动态绑定主要应用于虚方法和接口方法。 多态的实现过程，就是方法调用动态分派的过程，通过栈帧的信息去找到被调用方法的具体实现，然后使用这个具体实现的直接引用完成方法调用。 以 invokevirtual 指令为例，在执行时，大致可以分为以下几步： 先从操作栈中找到对象的实际类型 class； 找到 class 中与被调用方法签名相同的方法，如果有访问权限就返回这个方法的直接引用，如果没有访问权限就报错java.lang.IllegalAccessError ； 如果第 2 步找不到相符的方法，就去搜索 class 的父类，按照继承关系自下而上依次执行第 2 步的操作； 如果第 3 步找不到相符的方法，就报错java.lang.AbstractMethodError Java中创建对象的5种方式 使用new关键字 } → 调用了构造函数 使用Class类的newInstance方法 } → 调用了构造函数 使用Constructor类的newInstance方法 } → 调用了构造函数 使用clone方法 } → 没有调用构造函数 使用反序列化 } → 没有调用构造函数 使用new关键字通过这种方式，我们可以调用任意的构造函数(无参的和带参数的) 使用Class类的newInstance方法这个newInstance方法调用无参的构造函数创建对象 使用Constructor类的newInstance方法和Class类的newInstance方法很像，java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象。我们可以通过这个newInstance方法调用有参数的和私有的构造函数。这两种newInstance方法就是大家所说的反射。 使用clone方法无论何时我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。 要使用clone方法，我们需要先实现Cloneable接口并实现其定义的clone方法。 使用反序列化当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口 方法覆盖和方法重载Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。 为什么会出现 4.0-3.6=0.40000001 这种现象简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。 十进制的数在内存中是怎么存的补码的形式]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot的一些面试题]]></title>
    <url>%2F2019%2F06%2F30%2FSpringBoot%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[SpringBoot的启动和运行原理SpringBoot的启动流程首先是@SpringBootApplication 注解，@SpringBootApplication 注解实际上是 SpringBoot 提供的一个复合注解：@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan @SpringBootConfiguration 也是来源于 @Configuration，二者功能都是将当前类标注为配置类，并将当前类里以 @Bean 注解标记的方法的实例注入到srping容器中 @EnableAutoConfiguration 注解启用自动配置其可以帮助 SpringBoot 应用将所有符合条件的 @Configuration 配置都加载到当前 IoC 容器之中 @ComponentScan：@ComponentScan 对应于XML配置形式中的 context:component-scan，用于将一些标注了特定注解的bean定义批量采集注册到Spring的IoC容器之中，这些特定的注解大致包括：@Controller @Entity @Component @Service @Repository 其次是SpringApplication 以及 run() 方法（也就是自动加载的原理） 流程看一下：run 方法中去创建了一个 SpringApplication 实例，调用了一个初始化的 initialize 方法，为 SpringApplication 对象赋一些初值、在调用 loadFactoryNames 方法其作用是把 /spring.factories 文件中的配置类转化为对象创建了应用的监听器 SpringApplicationRunListeners 并开始监听 SpringBoot的IOC和AOPIOC它是一个容器的感觉,听过最多的一个词：控制反转，它表示让容器管理对象，不用每次都自己取new对象。使用@Service和@Autowired提供和使用服务。spring 是一种基于IOC容器编程的框架。 spring 把每一个需要管理的对象称为spring bean，spring管理这些bean 被我们称之为spring ioc容器。IOC容器具备两个基本功能： 通过描述管理（发布，获取）bean 通过描述完成 bean之间的依赖关系 一个对象的实例和字段的值被一个特殊的对象从外部注入，这个特殊的对象就是IOC。 IOC容器包含了所有的Spring Beans。 由此我们可以看书IOC的目的无外乎三种： Resource定位，也就我们所说的配置文件（Xml），配置类（JavaConfig）。必须先找到描述bean对象的文件，才好完成后面对象创建与管理。 BeanDefinition的解析和注册，承继上面的找到bean对象描述信息之后，我们需要在内存中用命为BeanDefinition的对象去封装它。何谓注册？顾名思义，注册就是为了后面的查询服务的，我们前文不是提及过希望有一个“容器”去管理它们吗。所以注册就是以beanName 为key，beanDefinition为value注册到一个concurrentHashMap中去。 Ioc的依赖注入，通过getbean()的方式获取bean对象，而依赖注入就是在这个方法内部完成的，内部是以递归的方式完成的。所以当我们在开发时候碰到空指针异常的时候，大多数时候是因为我们Spring 配置文件处理不当，bean与bean之间的依赖关系没处理好。 那么我们平时初始化的时候做的事情： 初始化一个beanfactory，beanfactory是一个接口，主要是实现getbean()方法和维护一个concurrentHashMap 将上一步生成的beanfactory让beanDefinitionReader来回调，因为Reader类封装完bean要扔到我们的concurrentHashMap中。 完成bean的注册和解析，既然有spring.xml的路径，那我就可以获取该文件的文件流，解析其中的标签，然后用beanDefinition对象封装，最后扔到beanfactory的concurrentHashMap中。 那么beanDefinition是干啥的呢： 以上完成了beanDefinition的解析和注册，下面我们来看看它是如何完成依赖注入的，上文已经解释过bean的实例化和依赖注入是在getBean()的过程中完成的。 AOP切面监控，面向切面编程，可以监控任何文件，目前普遍用于日志。这是基本的，它是基于代理模式实现的。 这张图反映了参与到AOP过程中的几个关键组件(以@Before Advice为例)： 调用者Beans- 即调用发起者，它只知道目标方法所在Bean，并不清楚代理以及Advice的存在 目标方法所在Bean - 被调用的目标方法 生成的代理 - 由Spring AOP为目标方法所在Bean生成的一个代理对象 Advice - 切面的执行逻辑 代理模式定义：为其他对象提供一种代理以控制对这个对象的访问。这段话比较官方，但我更倾向于用自己的语言理解：比如A对象要做一件事情，在没有代理前，自己来做，在对A代理后，由A的代理类B来做。代理其实是在原实例前后加了一层处理，这也是AOP的初级轮廓。 代理的话又分为： 静态代理模式：静态代理说白了就是在程序运行前就已经存在代理类的字节码文件，代理类和原始类的关系在运行前就已经确定，保证了业务类只需关注逻辑本身，但是如果要代理的方法很多，代码就很复杂了。 动态代理模式:动态代理类的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是运行时才确定的。 动态代理又有两种方法： 使用jdk生成的动态代理的前提是目标类必须有实现的接口。但这里又引入一个问题,如果某个类没有实现接口,就不能使用jdk动态代理。 Cglib是以动态生成的子类继承目标的方式实现，在运行期动态的在内存中构建一个子类，Cglib使用的前提是目标类不能为final修饰。因为final修饰的类不能被继承。 我们在使用Spring AOP的时候，一般是不需要选择具体的实现方式的。Spring AOP能根据上下文环境帮助我们选择一种合适的。但是也不是每次都能很正确的选择出来，比方说定义了一个接口，这个接口中并没有定义任何方法，这个时候利用jdk创建代理对象就会有问题需要强制使用CGLIB来避免这个问题 12345// 向@EnableAspectJAutoProxy注解中添加属性proxyTargetClass = true即可。 @Configuration@EnableAspectJAutoProxy(proxyTargetClass = true)@ComponentScan(basePackages = "com.destiny1020")public class CommonConfiguration &#123;&#125; Spring生成代理对象Spring如何使用JDK来生成代理对象，具体的生成代码放在JdkDynamicAopProxy这个类中，具体步骤 获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false) 检查上面得到的接口中有没有定义equals或者hashcode的接口 调用Proxy.newProxyInstance创建代理对象 对象生成后：InvocationHandler是JDK动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法，通过这个方法织入切面 Spring如何使用CGLIB来生成代理对象：通过动态地对目标对象进行子类化 BeanFactory 和 FactoryBean 的区别BeanFactory 是 IOC 最基本的容器，负责生产和管理 bean，它为其他具体的 IOC 容器提供了最基本的规范，例如 DefaultListableBeanFactory。 FactoryBean 是一个接口，当在 IOC 容器中的 Bean 实现了 FactoryBean 后，通过 getBean(String BeanName)获取到的 Bean 对象并不是 FactoryBean 的实现类对象，而是这个实现类中的 getObject() 方法返回的对象。 BeanFactory 和 FactoryBean 其实没有什么比较性的，只是两者的名称特别接近 注解的原理注解相当于一种标记，在程序中加入注解就等于为程序打上某种标记在此以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种标记，看你的程序有什么标记，就去干相应的事情，标记(注解)可以加在包、类，属性、方法，方法的参数以及局部变量上。springboot 注解主要用来配置 bean，切面相关配置。 元注解和组合注解 元注解：注解的最小单位，有 4 个分别为 @Retention @Target @Document @Inherited 组合注解：由元注解组合而成的注解，比如@Controller、@Override、@Component等我们平常用的所有注解都是由这 4 个注解所组成的 @Retention有三种取值 123456@Retention(RetentionPolicy.SOURCE) //注解仅存在于源码中，在class字节码文件中不包含，对应Java源文件(.java文件)@Retention(RetentionPolicy.CLASS) // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得 ，对应.class文件，@Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到, 对应内存中的字节码 首先要明确生命周期长度 SOURCE &lt; CLASS &lt; RUNTIME，当在 Java 源程序上加了一个注解，这个 Java 源程序要由 javac 去编译 @Target123456789101112@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125;@Target(ElementType.TYPE) //接口、类、枚举、注解@Target(ElementType.FIELD) //字段、枚举的常量@Target(ElementType.METHOD) //方法@Target(ElementType.PARAMETER) //方法参数@Target(ElementType.CONSTRUCTOR) //构造函数@Target(ElementType.LOCAL_VARIABLE)//局部变量@Target(ElementType.ANNOTATION_TYPE)//注解@Target(ElementType.PACKAGE) ///包 @Documented说明该注解将被包含在 javadoc 中 @Inherited说明子类能够继承父类的的该注解，就是当一个类 A 使用了改注解，一个类 B 继承这个类 A,则类 B 也拥有类 A 的所有注解 注解的作用@SpringBootApplication表示这是一个配置文件，点击进去可以看到这些配置文件 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration //配置文件@EnableAutoConfiguration //自动配置@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)// 组件扫描，扫描配置类和子包下的bean @Component泛指组件，把普通pojo实例化到spring容器中，相当于配置文件中的 &lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;。 因为在持久层、业务层和控制层中，分别采用@Repository、@Service和@Controller对分层中的类进行凝视，而用@Component对那些比较中立的类进行凝视。 @Controller由@Retention @Target @Document 和 @Component 这几个注解组成 用于标注控制层，相当于struts中的action层 @Autowired用来做依赖注入的，直接生成就不用new对象了。 @Service用于标注服务层，主要用来进行业务的逻辑处理 @PostConstruct修饰的方法在构造器之后被调用 @PreDestroy修饰的方法在销毁之前调用，释放某些资源 @Repository用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件. @Configuration@Configuration定义配置类，被注解的类内部包含有一个或多个被@Bean注解的方法,这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。 @Bean@Bean注解注册bean,同时可以指定初始化和销毁方法 @Scope(“prototype”)这个注解导致每次调用getbean方法时都实例化bean，但是实际上很少会这样去做。记住被Spring容器管理的Bean只被实例化一次，因为它是单例的。 @Autowired 与@Resource的区别@Autowired 与 @Resource 都可以用来装配 bean. 都可以写在字段上，但是 @Autowired 默认按类型装配，@Resource 是 JDK1.6 支持的注解，默认按照名称进行装配 @Autowired与@Override的区别@Autowired 注解的作用是解决对类成员变量、方法及构造函数进行标注，完成自动装配的工作， @Override 是伪代码,表示重写(当然不写也可以)可以当注释用,可以给你验证 @Override 下面的方法名是否是你父类中所有的，如果没有则报错 有关注解的一个问题一个 controller 分别调用两个 Service 再调用两个 Dao 时，注解加在什么层，如何实现事务？ 应该加在 Service 层吧，配置一下 spring 的事务传播，创建两个事务。 那如果那两个Service强相关呢？ Dao 层中的方法更多的是一种对数据库的增删改查的原子性操作，而 Service 层中的方法相当于对这些原子性的操作做一个组合，这里要同时操作 TeacherDao、StudentDao 中的 insert 方法所以新建一个接口，添加 @Service注解。@Transactional 注解开启事务管理，利用事务管理器加入。 哪些bean会被扫描被@controller 、@service、@repository 、@component注解的类，都会把这些类纳入进spring容器中进行管理 Spring容器管理Bean容器实现了IOC， Bean的实例化；Bean的命名；Bean的作用域；Bean的生命周期回调；Bean延迟实例化；指定Bean依赖关系。 Bean的生命周期Spring IOC容器对Bean的生命周期进行管理的过程如下： 通过构造器或工厂方法创建Bean实例 为Bean的属性设置值和对其它Bean的引用 调用Bean的初始化方法 Bean可以使用了 当容器关闭时，调用Bean的销毁方法 Spring Boot 需要独立的容器运行吗？可以不需要，内置了 Tomcat/ Jetty等容器。 Spring事务管理事务原理Spring 事务的本质其实就是数据库对事务的支持：加上了 @EnableTransctionManagement注解就表示使用Spring 事务机制来进行事务管理。 配置文件开启注解驱动，在相关的类和方法上通过注解 @Transactional 标识。 spring 在启动的时候会去解析生成相关的 bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据 @Transaction 的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。 真正的数据库层的事务提交和回滚是通过bin log或者redo log实现的。 具体的事务的概念可以看https://xiaorui2.github.io/2019/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/ Spring 事务支持编程式事务管理和声明式事务管理两种。 Spring事务管理接口 PlatformTransactionManager：（平台）事务管理器 TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则) TransactionStatus：事务运行状态 PlatformTransactionManagerTransactionTemplate 或者直接使用底层的 PlatformTransactionManager 对于编程式事务管理，spring 推荐使用 TransactionTemplate。Spring 并不直接管理事务，而是提供了多种事务管理器，通过PlatformTransactionManager 接口来实现。PlatformTransactionManager 接口中定义了三个方法： 12345678Public interface PlatformTransactionManager()...&#123; // Return a currently active transaction or create a new one, according to the specified propagation behavior（根据指定的传播行为，返回当前活动的事务或创建一个新事务。） TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; // Commit the given transaction, with regard to its status（使用事务目前的状态提交事务） Void commit(TransactionStatus status) throws TransactionException; // Perform a rollback of the given transaction（对执行的事务进行回滚） Void rollback(TransactionStatus status) throws TransactionException; &#125; 事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到一个事务，这个方法里面的参数是 TransactionDefinition类，这个类就定义了一些基本的事务属性（事务的一些基本配置，描述了事务策略如何应用到方法上）。 事务属性包含了5个方面： TransactionDefinitionTransactionDefinition中定义了5个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。 123456789101112public interface TransactionDefinition &#123; // 返回事务的传播行为 int getPropagationBehavior(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据 int getIsolationLevel(); // 返回事务必须在多少秒内完成 //返回事务的名字 String getName()； int getTimeout(); // 返回是否优化为只读事务。 boolean isReadOnly();&#125; TransactionDefinition接口中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysq 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别. TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 在TransactionDefinition定义中包括了如下几个表示传播行为的常量： 支持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性） 不支持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 其他情况： TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。 事务超时属性(一个事务允许执行的最长时间)所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在TransactionDefinition 中以int的值来表示超时时间，其单位是秒。 事务只读属性事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在 TransactionDefinition 中以boolean类型来表示该事务是否只读。 TransactionStatus它用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息. 实现方式Spring提供了对编程式事务和声明式事务的支持，编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于AOP）有助于用户将操作与事务规则进行解耦。 编程式事务Spring提供两种方式的编程式事务管理，分别是：使用TransactionTemplate和直接使用PlatformTransactionManager。 声明式事务不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。 SpringMVC的流程 发起请求到前端控制器(DispatcherServlet) 前端控制器请求 HandlerMapping 查找 Handler （可以根据xml配置、注解进行查找） 处理器映射器 HandlerMapping 向前端控制器返回 Handler，HandlerMapping 会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象，多个 HandlerInterceptor对象），通过这种策略模式，很容易添加新的映射策略 前端控制器调用处理器适配器去执行 Handler 处理器适配器 HandlerAdapter 将会根据适配的结果去执行 Handler Handler 执行完成给适配器返回 ModelAndView 处理器适配器向前端控制器返回 ModelAndView （ModelAndView 是 springmvc 框架的一个底层对象，包括 Model 和 view） 前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可 视图解析器向前端控制器返回 View 前端控制器进行视图渲染 （视图渲染将模型数据(在 ModelAndView 对象中)填充到 request 域） 前端控制器向用户响应结果]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode字节跳动专题]]></title>
    <url>%2F2019%2F06%2F30%2FLeetCode%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[挑战字符串无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解法首先是子串，所以连续的。一个滑动窗口，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，窗口的右边界就相当于遍历到的字符的位置。为了求出窗口的大小，我们需要一个变量left来指向滑动窗口左边界，一个变量记录窗口的右边界如果该字符没有出现过就右边界增加，否则就移动左边界直到重复的字符去掉。为了判断字符是否出现过把出现过的字符都放入set中，遇到set中没有的字符就加入set中并更新结果res，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止。 AC代码12345678910111213141516171819class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; set&lt;char&gt;ss; int ans=0; int l=0,r=0; while(r&lt;s.size()) &#123; if(!ss.count(s[r])) &#123; ss.insert(s[r++]); ans=max(ans,(int)ss.size()); &#125; else ss.erase(s[l++]); &#125; return ans; &#125;&#125;; 最长公共前缀最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解法按照题匹配就可以了。 AC代码12345678910111213141516171819class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string ans; if(strs.empty()) return ans; for(int i=0;i&lt;strs[0].size();i++) &#123; char c=strs[0][i]; for(int j=1;j&lt;strs.size();j++) &#123; if(i&gt;=strs[j].size() || strs[j][i]!=c) return ans; &#125; ans+=c; &#125; return ans; &#125;&#125;; 字符串的排列给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 示例1: 123输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;). 示例2: 12输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False 说明： 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 解法开始想跑dfs 跑全排列，然后用KMP 去匹配，但是后来想了一下，不用那么复杂，因为全是小写字母，所以只需要s2 和s1 这段字符串的字符数量一样就可以了，因为s1 的子串可以重新组合，必然能和s2 匹配成功 AC代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool check(int a[]) &#123; for(int i=0;i&lt;26;i++) &#123; if(a[i]!=0) return false; &#125; return true; &#125; bool checkInclusion(string s1, string s2) &#123; int len1=s1.length();int len2=s2.length(); if(len1&gt;len2 || len1==0 || len2==0) &#123; return false; &#125; else &#123; int a[26]=&#123;0&#125;; for(int i=0;i&lt;len1;i++) &#123; a[s1[i]-'a']--; a[s2[i]-'a']++; &#125; for(int j=len1;j&lt;len2;j++) &#123; if(check(a)) &#123; return true; &#125; a[s2[j-len1]-'a']--; a[s2[j]-'a']++; &#125; return check(a); &#125; &#125;&#125;; 字符串相乘给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 12输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot; 示例 2: 12输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot; 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 解法模拟数字乘法。参照这个图理解一下代码就可以 AC代码1234567891011121314151617181920212223242526272829class Solution &#123;public: string multiply(string num1, string num2) &#123; if(num1=="0" || num2=="0") return "0"; int len1=num1.length();int len2=num2.length(); int a[len1+len2]; memset(a,0,sizeof(a)); int flag=0;int t=len1+len2-2; for(int i=0;i&lt;len1;i++) for(int j=0;j&lt;len2;j++) a[t-i-j]+=((num1[i]-'0')*(num2[j]-'0')); for(int i=0;i&lt;len1+len2;i++) &#123; a[i]+=flag; flag=a[i]/10; a[i]%=10; &#125; int i=len1+len2-1; while(a[i]==0) i--; string ans; if(i&lt;0) return "0"; while(i&gt;=0) ans+=(a[i--]+'0'); return ans; &#125;&#125;; 翻转字符串里的单词给定一个字符串，逐个翻转字符串中的每个单词。 示例 1 12输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot; 示例 2： 123输入: &quot; hello world! &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 123输入: &quot;a good example&quot;输出: &quot;example good a&quot;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 解法遍历这个字符串，按照题意我们采用stack 来存储这些字符串然后输出即可。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string reverseWords(string s) &#123; stack&lt;string&gt; str; string s0 = ""; if(s.empty()) &#123; s = ""; return s; &#125; for(int i=0;i&lt;s.length();i++) &#123; if(s[i]!=' ') &#123; s0+=s[i]; continue; &#125; //得到字符组成字符串。 else if(!s0.empty()) &#123; str.push(s0); s0=""; &#125; &#125; if(!s0.empty()) &#123; str.push(s0); s0=""; &#125; while(!str.empty()) &#123; s0+=str.top(); str.pop(); s0+=" "; &#125; if(s0.empty()) &#123; s = ""; return s; &#125; s0.erase(s0.end()-1); s = s0; return s; &#125;&#125;; 简化路径以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 示例 1： 123输入：&quot;/home/&quot;输出：&quot;/home&quot;解释：注意，最后一个目录名后面没有斜杠。 示例 2： 123输入：&quot;/../&quot;输出：&quot;/&quot;解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。 示例 3： 123输入：&quot;/home//foo/&quot;输出：&quot;/home/foo&quot;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 示例 4： 12输入：&quot;/a/./b/../../c/&quot;输出：&quot;/c&quot; 示例 5： 12输入：&quot;/a/../../b/../c//.//&quot;输出：&quot;/c&quot; 解法模拟题，注意细节。 AC代码1234567891011121314151617181920212223242526class Solution &#123;public: string simplifyPath(string path) &#123; vector&lt;string&gt; v; int i = 0; while (i &lt; path.size()) &#123; while (path[i] == '/' &amp;&amp; i &lt; path.size()) ++i; if (i == path.size()) break; int start = i; while (path[i] != '/' &amp;&amp; i &lt; path.size()) ++i; int end = i - 1; string s = path.substr(start, end - start + 1); if (s == "..") &#123; if (!v.empty()) v.pop_back(); &#125; else if (s != ".") &#123; v.push_back(s); &#125; &#125; if (v.empty()) return "/"; string res; for (int i = 0; i &lt; v.size(); ++i) &#123; res += '/' + v[i]; &#125; return res; &#125;&#125;; 复原IP地址给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例： 12输入: &quot;25525511135&quot;输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 解法分为四个数字，每个数字最多三位。 遍历出所有的情况可能，看是否满足需求。 AC代码1234567891011121314151617181920public class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); for (int a = 1; a &lt; 4; ++a) for (int b = 1; b &lt; 4; ++b) for (int c = 1; c &lt; 4; ++c) for (int d = 1; d &lt; 4; ++d) if (a + b + c + d == s.length()) &#123; int A = Integer.parseInt(s.substring(0, a)); int B = Integer.parseInt(s.substring(a, a + b)); int C = Integer.parseInt(s.substring(a + b, a + b + c)); int D = Integer.parseInt(s.substring(a + b + c)); if (A &lt;= 255 &amp;&amp; B &lt;= 255 &amp;&amp; C &lt;= 255 &amp;&amp; D &lt;= 255) &#123; String t = String.valueOf(A) + "." + String.valueOf(B) + "." + String.valueOf(C) + "." + String.valueOf(D); if (t.length() == s.length() + 3) res.add(t); &#125; &#125; return res; &#125;&#125; 数组和排序三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解法先将数组排序，使用i，j，k三个指针。i指向最小的数可能的位置，k指向最大的数的位置，j指向中间的数可能的位置。遍历原理核心为每次遍历会遇到得三种情况： 1.nums[i]+nums[j]==-nums[k]，此时说明刚好三数加一起等于0，于是此时要把j向右拨一位，但此时nums[i]+nums[j]变大了(nums[j]变大的情况下)，所以同时也要把k向左拨。也即此时i++，k--; 2.nums[i]+nums[j]&gt;-nums[k]，此时说明nums[i]+nums[j]+nums[k]&gt;0，所以k要向左拨，k--; 3.nums[i]+nums[j]&lt;-nums[k]，此时说明nums[i]+nums[j]+nums[k]&lt;0，所以j要向右拨，j++; 当然，遍历的时候肯定会考虑重复等一些的情况，所以要加上邻位判断。比如在遍历第一种情况时，如果nums[j]==nums[j-1]，说明此时j已经考虑过了，直接j++即可。AC代码123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); if (nums.empty() || nums.back() &lt; 0 || nums.front() &gt; 0) return &#123;&#125;; for (int k = 0; k &lt; nums.size(); ++k) &#123; if (nums[k] &gt; 0) break; if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) continue; int target = 0 - nums[k]; int i = k + 1, j = nums.size() - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] == target) &#123; res.push_back(&#123;nums[k], nums[i], nums[j]&#125;); while (i &lt; j &amp;&amp; nums[i] == nums[i + 1]) ++i; while (i &lt; j &amp;&amp; nums[j] == nums[j - 1]) --j; ++i; --j; &#125; else if (nums[i] + nums[j] &lt; target) ++i; else --j; &#125; &#125; return res; &#125;&#125;; 岛屿的最大面积给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: 12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: 1[[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 解法bfs或者dfs均可，这种就是那种油田问题，但是这个只写函数感觉很难受写的。但是要注意n==0 的情况，这样算法题一定要注意判断边界。 AC代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int ii,int j) &#123; int n=grid.size();int m=grid[0].size(); int dx[4]=&#123;0,0,1,-1&#125;; int dy[4]=&#123;1,-1,0,0&#125;; grid[ii][j]=0; int sum=1; for(int i=0;i&lt;4;i++) &#123; int x=ii+dx[i]; int y=j+dy[i]; if(x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m&amp;&amp;grid[x][y]==1) sum+=dfs(grid,x,y); &#125; return sum; &#125; int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n=grid.size();int m=grid[0].size(); if(n==0) return 0; int ans=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; if(grid[i][j]==1) &#123; ans=max(dfs(grid,i,j),ans); &#125; &#125; &#125; return ans; &#125;&#125;; 搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2: 12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解法二分搜索法的关键在于获得了中间数后，判断下面要搜索左半段还是右半段，多画几个示意图可以发现如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了。 AC代码12345678910111213141516171819class Solution &#123;public: int search(int A[], int n, int target) &#123; if (n == 0) return -1; int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (A[mid] == target) return mid; else if (A[mid] &lt; A[right]) &#123; if (A[mid] &lt; target &amp;&amp; A[right] &gt;= target) left = mid + 1; else right = mid - 1; &#125; else &#123; if (A[left] &lt;= target &amp;&amp; A[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; &#125; return -1; &#125;&#125;; 最长连续递增序列给定一个未经排序的整数数组，找到最长且连续的的递增序列。 示例 1: 1234输入: [1,3,5,4,7]输出: 3解释: 最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 示例 2: 123输入: [2,2,2,2,2]输出: 1解释: 最长连续递增序列是 [2], 长度为1。 注意：数组长度不会超过10000。 解法最长连续递增序列是 [1,3,5], 长度为3。尽管[1,3,5,7]也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 最长连续递增子序列，解法就直接模拟，从1-n，要是a[i]&lt;a[i+1],长度加一，碰到a[i]&gt;=a[i+1]就更新最长的递增序列长度 AC代码12345678910111213141516171819202122class Solution &#123;public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); if(n==0) return 0; int ans=0; int tempans=1; for(int i=0;i&lt;n-1;i++) &#123; if(nums[i]&lt;nums[i+1]) tempans++; else &#123; if(tempans&gt;ans) ans=tempans; tempans=1; &#125; &#125; return max(ans,tempans); &#125;&#125;; 数组中的第K个最大元素在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解法维持一个长度为k 的优先队列即可。 AC代码1234567891011121314class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q; int si=nums.size(); for(int i=0;i&lt;si;i++) &#123; q.push(nums[i]); if(q.size()&gt;k) q.pop(); &#125; return q.top(); &#125;&#125;; 最长连续序列给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例: 123输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4 解法先排序，然后一遍循环找到最长连续的序列的长度 AC代码123456789101112131415161718192021222324class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; int si=nums.size(); if(si==0) return 0; if(si==1) return 1; sort(nums.begin(),nums.end()); nums.erase(unique(nums.begin(),nums.end()),nums.end()); int ans=1,temp=1; for(int i=1;i&lt;si;i++) &#123; while(i&lt;si&amp;&amp;nums[i]==nums[i-1]+1) &#123; temp++; i++; &#125; ans=ans&lt;temp?temp:ans; temp=1; &#125; return ans; &#125;&#125;; 第k个排列给出集合 [1,2,3,…,*n*]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： &quot;123&quot; &quot;132&quot; &quot;213&quot; &quot;231&quot; &quot;312&quot; &quot;321&quot; 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例 1: 12输入: n = 3, k = 3输出: &quot;213&quot; 示例 2: 12输入: n = 4, k = 9输出: &quot;2314&quot; 解法先排序，然后一遍循环找到最长连续的序列的长度 AC代码12345678910111213141516171819class Solution &#123;public: string getPermutation(int n, int k) &#123; string ans; string num="123456789"; vector&lt;int&gt;f(n, 1); for (int i = 1; i&lt;n;++i) f[i]=f[i-1] * i; --k; for (int i = n; i &gt;= 1; --i) &#123; int j = k / f[i - 1]; k %= f[i - 1]; ans.push_back(num[j]); num.erase(j, 1); &#125; return ans; &#125;&#125;; 朋友圈班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1: 1234567输入: [[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。 示例 2: 123456输入: [[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 注意： N在[1,200]的范围内。 对于所有学生，有M[i][i]= 1。 如果有M[i][j] = 1，则有M[j][i]= 1。 解法第一反应 并查集，但是也可以直接dfs，维持一个vis数组，对于走过的不再遍历，对于未走过的按照给定的ma[][]进行深度搜索。 AC代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; M,vector&lt;bool&gt;&amp; vis,int i) &#123; int n=M.size(); for(int j=0;j&lt;n;j++) &#123; if(M[i][j]==1&amp;&amp;!vis[j]) &#123; vis[j]=true; dfs(M,vis,j); &#125; &#125; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; int ans=0; int n=M.size(); if(n==0) return 0; vector&lt;bool&gt;vis(n,false); for(int i=0;i&lt;n;i++) &#123; if(!vis[i]) &#123; dfs(M,vis,i); ans++; &#125; &#125; return ans; &#125;&#125;; 合并区间给出一个区间的集合，请合并所有重叠的区间。 示例 1: 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解法我们首先想到的做法是先将输入的区间按照第一个元素排序。然后我们建立一个result用来存储最后的结果。我们现将第一个区间放入result中，然后对于后面输入的区间的item.start和result[-1].end比，如果result[-1].end &lt; item.start，我们就将item加入到result，否则话说明要放入的区间和result[-1]有重叠，那么我们取result[-1].end = max(result[-1].end, item.end)。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; sort(intervals.begin(),intervals.end(),cmp); int si=intervals.size(); if(si==1) return intervals; vector&lt;Interval&gt;ans; int i=0; Interval temp; while(i&lt;si) &#123; int s=intervals[i].start,e=intervals[i].end; int j=i+1; while(j&lt;si &amp;&amp; intervals[j].start&lt;=e) &#123; if(e&lt;intervals[j].end) e=intervals[j].end; j++; &#125; temp.start=s;temp.end=e; ans.push_back(temp); i=j; &#125; return ans; &#125; static bool cmp(Interval a,Interval b) &#123; if(a.start==b.start) return a.end&lt;b.end; else return a.start&lt;b.start; &#125;&#125;; 接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 解法找到最高的那个柱子，把数组分成两部分，对于两部分都已经确定了一个边界高度了，所以对剩余的每个柱子至于确定一边的边界高度值，就可以直接计算出能接的雨水了 AC代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n=height.size(); if(n&lt;=2) return 0; int maxx=-1;int id; for(int i=0;i&lt;n;i++) &#123; if(height[i]&gt;maxx) &#123; maxx=height[i]; id=i; &#125; &#125; int ans=0;int t=height[0]; for(int i=0;i&lt;id;i++) &#123; if(t&lt;height[i]) t=height[i]; else ans+=(t-height[i]); &#125; t=height[n-1]; for(int i=n-1;i&gt;id;i--) &#123; if(t&lt;height[i]) t=height[i]; else ans+=(t-height[i]); &#125; return ans; &#125;&#125;; 链表和树合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解法同上两种思路一个是递归，一个是遍历。分别用Java和c++写的。 递归：新建个链表，每次两个链表当中选一个小值复制过去，那么现在是不是就是合并两个链表（其中有一个已经赋值过去了，就是之前的.next，然后递归就可以了。 遍历： 新建一个链表，我们先把第一个值复制过去，然后当两个链表都存在的时候，谁值小就把谁链接到新链表后面然后后移一个，直到两个当中某一个为空了，最后把两个链表剩余的直接链接上去就可以了。 可以看剑指Offer解答，更全一点，这里只有c++版本的。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* pHead1, ListNode* pHead2) &#123; ListNode *pHead = new ListNode(0); ListNode *p = pHead; while(pHead1 != NULL &amp;&amp; pHead2 != NULL) &#123; if(pHead1-&gt;val &lt; pHead2-&gt;val) &#123; p-&gt;next = pHead1; pHead1 = pHead1-&gt;next; &#125; else &#123; p-&gt;next = pHead2; pHead2 = pHead2-&gt;next; &#125; p = p-&gt;next; &#125; if(pHead1 != NULL) &#123; p-&gt;next = pHead1; pHead1=pHead1-&gt;next; p=p-&gt;next; &#125; if(pHead2 != NULL) &#123; p-&gt;next = pHead2; pHead2=pHead2-&gt;next; p=p-&gt;next; &#125; return pHead-&gt;next; &#125;&#125;; 反转链表反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解法递归，先反转从第二个结点到最后一个结点的链表，然后再将头结点放到已反转链表的最后，函数返回新链表的头结点。 AC代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *ans=NULL; ListNode *pre=NULL; ListNode *temp=head; // 不断取出和向后移动头节点 // 并将头节点连接到新头节点后面 while(temp!=NULL) &#123; ListNode *nextt=temp-&gt;next; if(nextt==NULL) ans=temp; temp-&gt;next=pre; pre=temp; temp=nextt; &#125; return ans; &#125;&#125;; 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解法按我们的正常的加法来进行运算，但是要保存进位。 AC代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode l3 = new ListNode(0); ListNode res = l3; int value = 0; int flag = 0; while (l1 != null || l2 != null || flag == 1) &#123; int sum = flag; sum += (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0); l1 = (l1 != null ? l1.next : null); l2 = (l2 != null ? l2.next : null); l3.next = new ListNode(sum % 10); flag = sum / 10; l3 = l3.next; &#125; return res.next; &#125;&#125; 排序链表在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解法利用之前学习的排序算法来写即可 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; return mergeSort(head);//去掉链表尾端的寻找 &#125; ListNode* mergeSort(ListNode* head) &#123; if (head == NULL || head -&gt;next == NULL) &#123;//这段链表只有一个节点 return head; &#125; //快慢指针，定位链表中间 ListNode *slowPtr = head, *fastPtr = head-&gt;next; while (fastPtr != NULL &amp;&amp; fastPtr-&gt;next != NULL) &#123; slowPtr = slowPtr-&gt;next;//慢指针走一步 fastPtr = fastPtr-&gt;next;//快指针走两步 if (fastPtr != NULL &amp;&amp; fastPtr-&gt;next != NULL) &#123; fastPtr = fastPtr-&gt;next;//快指针走两步 &#125; &#125; //第一步 递归，排序右半 ListNode * rightList = mergeSort(slowPtr-&gt;next); slowPtr-&gt;next = NULL;//将左右两部分切开 //第二步 递归，排序左半 ListNode * leftList = mergeSort(head); //第三步 合并 ListNode *pHead = NULL, *pEnd = NULL;//合并链表的头、尾 if (rightList == NULL) &#123; return leftList; &#125; //初始化头结点、尾节点 if (rightList-&gt;val &gt; leftList-&gt;val) &#123; pEnd = pHead = leftList; leftList = leftList-&gt;next; &#125; else &#123; pEnd = pHead = rightList; rightList = rightList-&gt;next; &#125; //合并，每次将较小值放入新链表 while (rightList &amp;&amp; leftList) &#123; if (rightList-&gt;val &gt; leftList-&gt;val) &#123; pEnd-&gt;next = leftList; pEnd = pEnd-&gt;next; leftList = leftList-&gt;next; &#125; else &#123; pEnd-&gt;next = rightList; pEnd = pEnd-&gt;next; rightList = rightList-&gt;next; &#125; &#125; //可能某个链表有剩余 if (rightList == NULL) &#123; pEnd-&gt;next = leftList; &#125; else &#123; pEnd-&gt;next = rightList; &#125; return pHead; &#125;&#125;; 环形链表 II给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 解法快慢指针，出现重复之后，慢指针返回到头结点，快指针继续，两者每次都走一步，直到相遇 AC代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head == nullptr) return nullptr; ListNode * slow = head; ListNode * fast = head; ListNode * temp = nullptr; int node = 1; while(fast -&gt; next != nullptr)&#123; slow = slow -&gt; next; fast = fast -&gt; next; if(fast -&gt; next != nullptr) fast = fast -&gt; next; else return nullptr; if(slow == fast)&#123; temp = slow; break; &#125; &#125; if(temp != nullptr)&#123; slow = head; while(slow != fast)&#123; slow = slow -&gt; next; fast = fast -&gt; next; &#125; return slow; &#125; else return nullptr; &#125;&#125;; 相交链表编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 解法同时遍历两个链表到尾部，同时记录两个链表的长度。若两个链表最后的一个节点相同，则两个链表相交。有两个链表的长度后，我们就可以知道哪个链表长，设较长的链表长度为len1,短的链表长度为len2。 则先让较长的链表向后移动(len1-len2)个长度。然后开始从当前位置同时遍历两个链表，当遍历到的链表的节点相同时，则这个节点就是第一个相交的节点。 AC代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if(headA==NULL || headB==NULL) return NULL; ListNode *ans1=headA,*ans2=headB; while(ans1!=ans2) &#123; if(ans1==NULL) ans1=headB; else ans1=ans1-&gt;next; if(ans2==NULL) ans2=headA; else ans2=ans2-&gt;next; &#125; return ans1; &#125;&#125;; 合并K个排序链表合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 解法因为已经做过合并两个有序链表的，所以我们就需要两个两个的合并，直到合并到一个链表中去。 AC代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if (lists.empty()) return NULL; int n = lists.size(); while (n &gt; 1) &#123; int k = (n + 1) / 2; for (int i = 0; i &lt; n / 2; ++i) &#123; lists[i] = mergeTwoLists(lists[i], lists[i + k]); &#125; n = k; &#125; return lists[0]; &#125; ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *dummy = new ListNode(-1), *cur = dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; cur = cur-&gt;next; &#125; if (l1) cur-&gt;next = l1; if (l2) cur-&gt;next = l2; return dummy-&gt;next; &#125;&#125;; 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 示例 1: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 解法第一种情况：左子树和右子树均找没有p结点或者q结点；（这里特别需要注意，虽然题目上说了p结点和q结点必定都存在，但是递归的时候必须把所有情况都考虑进去，因为题目给的条件是针对于整棵树，而递归会到局部，不一定都满足整体条件） 第二种情况：左子树上能找到，但是右子树上找不到，此时就应当直接返回左子树的查找结果； 第三种情况：右子树上能找到，但是左子树上找不到，此时就应当直接返回右子树的查找结果； 第四种情况：左右子树上均能找到，说明此时的p结点和q结点分居root结点两侧，此时就应当直接返回root结点 AC代码123456789101112131415161718192021 * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root==NULL) return root; if(root==p||root==q) return root; TreeNode *left=lowestCommonAncestor(root-&gt;left,p,q); TreeNode *right=lowestCommonAncestor(root-&gt;right,p,q); if(left!=NULL&amp;&amp;right!=NULL) return root;//如果p,q刚好在左右两个子树上 if(left==NULL) return right;//仅在右子树 if(right==NULL) return left;//仅在左子树 &#125;&#125;; 二叉树的锯齿形层次遍历给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回锯齿形层次遍历如下： 12345[ [3], [20,9], [15,7]] 解法其实就是层次遍历，只不过相邻每两层之间输出的顺序相反，所以就设置一个bool型的变量，每次判断是该从左往右，还是从右往在即可。然后每遍历一层，对这个bool型变量取反。 AC代码12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; data = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; if(root == null)&#123; return data; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); int level = 1; while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; size; i++)&#123; TreeNode node = queue.poll(); list.add(node.val); if(node.left != null)&#123; queue.offer(node.left); &#125; if(node.right != null)&#123; queue.offer(node.right); &#125; &#125; if(level % 2 != 0)&#123; data.add(list); &#125;else&#123; Collections.reverse(list); data.add(list); &#125; level++; &#125; return data; &#125;&#125; 动态或贪心买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解法因为只能交易一次，所以要找出差值最大的那个。 AC代码12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int si=prices.size(); if(si==0) return 0; int ans=0; int minn=prices[0]; for(int i=1;i&lt;si;i++)&#123; minn=min(minn,prices[i]); ans=max(ans,prices[i]-minn); &#125; return ans; &#125;&#125;; 买卖股票的最佳时机II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 解法因为不限交易次数，那么遍历数组，只要隔天买卖能赚差价，就可以购买。 AC代码123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int si=prices.size(); if(si==0 || si==1) return 0; int ans=0; for(int i=0;i&lt;si-1;i++) &#123; if(prices[i+1]-prices[i]&gt;0) ans+=prices[i+1]-prices[i]; &#125; return ans; &#125;&#125;; 最大正方形在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 解法判断以某个点为正方形右下角时最大的正方形时，那它的上方，左方和左上方三个点也一定是某个正方形的右下角，否则该点为右下角的正方形最大就是它自己了。我们知道，该点为右下角的正方形的最大边长，最多比它的上方，左方和左上方为右下角的正方形的边长多1，最好的情况是是它的上方，左方和左上方为右下角的正方形的大小都一样的，这样加上该点就可以构成一个更大的正方形。但如果它的上方，左方和左上方为右下角的正方形的大小不一样，合起来就会缺了某个角落，这时候只能取那三个正方形中最小的正方形的边长加1了。 AC代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return 0; int n=matrix.size(),m=matrix[0].size(); int ans=0; int dp[n][m]; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;n;i++) &#123; if(matrix[i][0]=='1') &#123; dp[i][0]=1;ans=1; &#125; &#125; for(int i=0;i&lt;m;i++) &#123; if(matrix[0][i]=='1') &#123; dp[0][i]=1;ans=1; &#125; &#125; for(int i=1;i&lt;n;i++) &#123; for(int j=1;j&lt;m;j++) &#123; if(matrix[i][j]=='1') dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1; ans=max(ans,dp[i][j]); &#125; &#125; return ans*ans; &#125;&#125;; 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解法一个最大的子序和，我们从中间将这个序列分开，那么这个最大值有三种可能，这个最大值出现在左半边，或者出现在右半边，或者横跨中间。因此我们根据这个思想，在这个三个当中求解出最大值就可以了，同理对于左半边和右半边的最大值我们也是这么求解的。O(n）的解法可以去看我的剑指Offer：https://xiaorui2.github.io/2019/06/24/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/#more AC代码123456789101112131415161718192021222324class Solution &#123;public: int maxsum(int l,int r,vector&lt;int&gt;&amp; nums) &#123; int ans; if(r==l) return nums[l]; int mid=(l+r)/2; ans=max(maxsum(l,mid,nums),maxsum(mid+1,r,nums)); int templ=nums[mid],t=0; for(int i=mid;i&gt;=l;i--) templ=max(templ,t+=nums[i]); int tempr=nums[mid+1];t=0; for(int i=mid+1;i&lt;=r;i++) tempr=max(tempr,t+=nums[i]); return max(ans,templ+tempr); &#125; int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int si=nums.size(); if(si==0) return 0; return maxsum(0,si-1,nums); &#125;&#125;; 三角形最小路径和给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 解法基础dp，倒推。 AC代码123456789101112131415161718class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int n=triangle.size(); if(n==0) return 0; int dp[n]; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;n;i++) dp[i]=triangle[n-1][i]; for(int i=n-2;i&gt;=0;i--) &#123; for(int j=0;j&lt;=i;j++) dp[j]=triangle[i][j]+min(dp[j],dp[j+1]); &#125; return dp[0]; &#125;&#125;; 俄罗斯套娃信封问题给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 说明:不允许旋转信封。 示例: 123输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]输出: 3 解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。 解法先按要求排好序吗，然后就是最长上升子序列的问题。 AC代码1234567891011121314151617class Solution &#123;public: int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123; int res = 0, n = envelopes.size(); vector&lt;int&gt; dp(n, 1); sort(envelopes.begin(), envelopes.end()); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (envelopes[i].first &gt; envelopes[j].first &amp;&amp; envelopes[i].second &gt; envelopes[j].second) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; res = max(res, dp[i]); &#125; return res; &#125;&#125;; 数据结构最小栈设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 示例: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 解法两个栈，一个正常存储，一个存储最小值，和剑指offer上的是一样的，更细节的可以去看一下。 AC代码1234567891011121314151617181920212223242526class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123;&#125; void push(int x) &#123; s1.push(x); if (s2.empty() || x &lt;= s2.top()) s2.push(x); &#125; void pop() &#123; if (s1.top() == s2.top()) s2.pop(); s1.pop(); &#125; int top() &#123; return s1.top(); &#125; int getMin() &#123; return s2.top(); &#125; private: stack&lt;int&gt; s1, s2;&#125;; LRU缓存机制运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例: 12345678910LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4 解法按题意的来嘛，用Map加Stack就可以解决了。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */class LRUCache &#123; Map&lt;Integer,Integer&gt; map ; Stack&lt;Integer&gt; stack; int size; public LRUCache(int capacity) &#123; stack = new Stack&lt;&gt;(); map = new HashMap&lt;&gt;(capacity); size = capacity; &#125; public int get(int key) &#123; if(!stack.contains(key))&#123; return -1; &#125; boolean flag = stack.remove(Integer.valueOf(key)); stack.push(key); return map.get(key); &#125; public void put(int key, int value) &#123; if(stack.contains(key))&#123; stack.remove(Integer.valueOf(key)); &#125;else&#123; if(stack.size() == size)&#123; int count = stack.remove(0); map.remove(count); &#125; &#125; stack.push(key); map.put(key,value); &#125;&#125; 全 O(1) 的数据结构实现一个数据结构支持以下操作： Inc(key) - 插入一个新的值为 1 的 key。或者使一个存在的 key 增加一，保证 key 不为空字符串。 Dec(key) - 如果这个 key 的值是 1，那么把他从数据结构中移除掉。否者使一个存在的 key 值减一。如果这个 key 不存在，这个函数不做任何事情。key 保证不为空字符串。 GetMaxKey() - 返回 key 中值最大的任意一个。如果没有元素存在，返回一个空字符串&quot;&quot;。 GetMinKey() - 返回 key 中值最小的任意一个。如果没有元素存在，返回一个空字符串&quot;&quot;。 挑战：以 O(1) 的时间复杂度实现所有操作。 解法待补]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务和隔离级别]]></title>
    <url>%2F2019%2F06%2F29%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[事务在计算机语言中，一般指访问并更新数据库中的一个程序执行单元。 事务具有的四个特点，称为ACID。在数据库的并发访问中，为了保证数据的读取正确性，设置的事务的隔离级别。 事务的四个特点 原子性：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性：一致性是指事务必须使数据库从一个一致性状态 变换到 另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 持久性：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 多事务产生的问题脏读A读取B事务尚未提交的事务，并修改了B的数据，然后B对事务执行回滚，那么A读取到的数据为脏读。 不可重复读事务A读取数据，然后事务B对事务A的数据进行了修改，此后，事务A再次读取数据，这时为不可重复读，最后A提交事务。所以在A的一次事务中，两次读取到的数据不一致。 幻读事务A查询数据，查询一切符合查询条件的行，这时B新增加一个行数据，A事务再次查询时，发现与第一次查询相比，新增加了一行。 更新丢失当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更 新覆盖了由其他事务所做的更新。 四种隔离级别 Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 Repeatable read(可重复读)：可避免脏读、不可重复读的发生。 Read committed(读已提交)：可避免脏读的发生。 Read uncommitted(读未提交)：最低级别，任何情况都无法保证。 以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。 在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>事务和隔离</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发一]]></title>
    <url>%2F2019%2F06%2F29%2FSpringBoot%E5%BC%80%E5%8F%91%E4%B8%80%2F</url>
    <content type="text"><![CDATA[项目介绍牛客高级项目课，主要是完成牛客网的讨论社区的搭建。 涉及到的技术架构： Spring，SpringBoot，SpringMVC，MyBatis，Redis，Kafka（消息队列服务器），Elasticsearch（搜索引擎），SpringSecurity（管理系统的权限），SpringActuator（对系统进行全面的监控）。 创建项目流程主要还是利用 Spring Initializr来帮助我们创建，它的底层还是应用了Maven来帮我们管理jar包，通常我们会需要这些：AOP，WEB，DevTools，thymeleaf。现在它上面已经不能直接引入AOP了，我们需要手动引入即可。创建好项目，来写一个简单的Hello SpringBoot!页面。 代码创建一个controller包，在包里面写页面入口。 1234567891011121314package com.nowcoder.community.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class AlphaController &#123; @RequestMapping("/hello") @ResponseBody public String sayHello() &#123; return "Hello Spring Boot!"; &#125;&#125; 这个时候在浏览器输入： 1http://localhost:8080/hello 就可以看到： 注意默认的端口是：8080，但是有时候这个端口可能被别的软件占用所以呢可以在application.properties这个文件里进行配置。 12server.port=8080server.servlet.context-path=/community 可以设置端口和页面前缀这些东西，加上后：]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI参考模型和数据交换]]></title>
    <url>%2F2019%2F06%2F29%2FOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[OSI参考模型 OSI参考模型图： OSI参考模型数据封装与通信过程：在各个层加上头，只有数据链路层会加尾，进行数据封装。 为什么要加数据封装？ 增加控制信息：构造协议数据单元（PDU） 控制信息包括：地址（标志发送端 / 接收端）；差错检测编码（用于差错检测或纠正）；协议控制（实现协议功能的附加信息如：优先级，服务质量和安全控制） OSI模型各层实现的功能物理层提供一个可靠的通信线路，关注的是一条线路上传输原始比特 定义和规范一些接口特性（机械特性，电气特性，功能特性，规程特性） 比特编码（什么表示比特1，比特0） 数据率 比特同步 传输模式（按什么样的方式传输：主要有单工（只能A—&gt;B），半双工（可以双向通信，但是只能一个方向进行），全双工（双向通信）） 数据链路层将一个原始的传输设施转变为没有漏检传输错误的线路 负责结点—结点数据传输，将从网络层发送来的数据加上头加上尾拆分为数据帧，组帧的目的在收到 比特流的时候能够识别这个数据帧，并且能够提取出其中的数据。 物理寻址（并不是在物理层寻址）：在帧头中增加发送发送端或接收端的物理信息。 流量控制，避免淹没接收端 差错控制，检测并重传损坏或丢失帧，避免重复帧。 访问控制，在任一给定时刻决定哪个设备拥有链路控制使用权。 网络层控制子网的运行 负责源主机到目的主机数据分组的交付，由于可能跨越多个网络，物理地址可能不能准确找到，就有这个逻辑寻址，如IP地址。 路由功能：路由器互联网络，路径选择 分组转发 传输层接收来自上一层的数据，负责源—目的（端到端）完整的报文传输。 分段和重组。 SAP寻址。（保证将完整报文提交给正确进程如端口号） 连接控制（逻辑连接）， 流量控制 ， 差错控制 会话层对话控制（建立，维护），对话同步（在数据流中插入同步点） 表示层处理两个系统间交换信息的语法和语义问题：数据表示转化，加密和解密，压缩和解压缩。 应用层支持用户通过用户代理（如流量器）或网络接口使用网络。典型的应用层服务：文件传输（FTP），电子邮件（SMTP），Web（HTTP） 每层涉及到的协议]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F06%2F29%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP协议是啥？在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP协议。 HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式。绝大多数Web开发都是建立在HTTP协议之上的Web应用。HTTP URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下： 1http://host[&quot;:&quot;port][abs_path] host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出。 什么是无状态，什么是有状态每个请求都是完全独立的，每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，多个实例对于同一个请求响应的结果是完全一致的，因为服务器不知道客户端是什么状态。即我们给服务器发送HTTP请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。 有状态就是无状态的对立，服务的实例可以将一部分数据随时进行备，服务器进行交流的时候知道这个是谁，会对请求进行记录。 HTTP就是无状态的，TCP就是有状态的，当然HTTP可以通过Cookie和Session来变成有状态的。 HTTP协议的请求 请求有三部分组成：请求行、消息报头、请求正文。 请求行组成：请求方法+统一资源标识符+HTTP协议版本（Method + Request-URI + HTTP-Version） 一般请求方法有：GET 请求获取Request-URI所标识的资源；POST 在Request-URI所标识的资源后附加新的数据。 HTTP的八种请求方式： GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 HTTP协议的响应 服务器向浏览器返回HTTP响应，响应包括： 响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误； 响应类型：由Content-Type指定 以及其他相关的Header；通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。 一些常见的状态码：200 OK //客户端请求成功；400 Bad Request //客户端请求有语法错误，不能被服务器所理解；401 Unauthorized //请求未经授权； 403 Forbidden //服务器收到请求，但是拒绝提供服；404 Not Found //请求资源不存在；500 Internal Server Error //服务器发生不可预期的错误； 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常。 注意一下：Body的数据类型由Content-Type头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。浏览器就是依靠Content-Type来判断响应的内容是网页还是图片，是视频还是音乐。浏览器并不靠URL来判断响应的内容，所以，即使URL是http://example.com/abc.jpg，它也不一定就是图片。 HTTP和HTTPS HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTPS的工作流程： HTTP的SSL加密摘自：https://blog.csdn.net/shw372029857/article/details/52687906 假设A与B通信，A是SSL客户端，B是SSL服务器端，加密后的消息放在方括号[]里，以突出明文消息的区别。双方的处理动作的说明用圆括号（）括起。 A：我想和你安全的通话，我这里的对称加密算法有DES,RC5,密钥交换算法有RSA和DH，摘要算法有MD5和SHA。 B：我们用DES－RSA－SHA这对组合好了。 这是我的证书，里面有我的名字和公钥，你拿去验证一下我的身份（把证书发给A）。 A：（查看证书上B的名字是否无误，并通过手头早已有的数字的证书验证了B的证书的真实性，如果其中一项有误，发出警告并断开连接，这一步保证了B的公钥的真实性） （产生一份秘密消息，这份秘密消息处理后将用作对称加密密钥，加密初始化向量和hmac的密钥。将这份秘密消息-协议中称为per_master_secret-用B的公钥加密，封装成称作ClientKeyExchange的消息。由于用了B的公钥，保证了第三方无法窃听） 我生成了一份秘密消息，并用你的公钥加密了，给你（把ClientKeyExchange发给B） 注意，下面我就要用加密的办法给你发消息了！ （将秘密消息进行处理，生成加密密钥，加密初始化向量和hmac的密钥） [我说完了] B：（用自己的私钥将ClientKeyExchange中的秘密消息解密出来，然后将秘密消息进行处理，生成加密密钥，加密初始化向量和hmac的密钥，这时双方已经安全的协商出一套加密办法了） 注意，我也要开始用加密的办法给你发消息了！ [我说完了] A: [我的秘密是…] B: [其它人不会听到的…] 补充： 对称密码算法：是指加密和解密使用相同的密钥，典型的有DES、RC5、IDEA（分组加密），RC4（序列加密）； 非对称密码算法：又称为公钥加密算法，是指加密和解密使用不同的密钥（公开的公钥用于加密，私有的私钥用于解密）。比如A发送，B接收，A想确保消息只有B看到，需要B生成一对公私钥，并拿到B的公钥。于是A用这个公钥加密消息，B收到密文后用自己的与之匹配的私钥解密即可。反过来也可以用私钥加密公钥解密。也就是说对于给定的公钥有且只有与之匹配的私钥可以解密，对于给定的私钥，有且只有与之匹配的公钥可以解密。典型的算法有RSA，DSA，DH； 散列算法：散列变换是指把文件内容通过某种公开的算法，变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变换是不可逆的，也就是说不能从散列值变成原文。因此，散列变换通常用于验证原文是否被篡改。典型的算法有：MD5，SHA，Base64，CRC等。 HTTP 和 HTTPS 建立连接后哪个性能低个人理解应该是 HTTP 性能更好一些，因为 HTTPS 对两个方面产生影响：协议交互所增加的网络 RTT 还有加解密相关的计算耗时。 GET和POST的区别 GET是幂等性的，POST不是，因此可以对GET请求的数据做缓存，但是POST请求不能做缓存 携带的数据格式也有区别GET上要在url之外带一些参数，POST请求都来自表单提交，粗略的说GET请求没有body，只有url，请求数据放在url的querystring中；POST请求的数据在body中，也导致GET对数据长度有限制(URL 的长度是受限制的，它的最大长度是 2048 个字符），但是POST无限制。因为GET用url传输，更加容易看到所以POST的安全性要比GET的安全性高，从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是明文协议。每个HTTP请求和返回的每个byte都会在网络上传播，不管是url，header还是body。这完全不是一个“是否容易在浏览器地址栏上看到“的问题。为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。业界的通行做法就是https，利用SSL加密。 GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。 HTTP的长连接和短连接首先 HTTP 协议是无状态的，7也就是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系 在 HTTP/1.0 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，但任务结束就中断连接。浏览器每遇到这样一个 Web 资源，就会建立一个 HTTP 会话。从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头有加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件中设定这个时间。实现长连接要客户端和服务端都支持长连接。 HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，而像 WEB 网站的 http 服务一般都用短链接，因为这么频繁的连接更省资源 TCP 为什么能进行长连接TCP 有一个保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。比方说如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段查看客户主机 WebSocket 和 socket、HTTP 的区别和联系WebSocket 是 HTML5 规范提出的一种协议，也是基于 TCP 协议的，和 HTTP 协议是并存的两种应用层协议。 而 Socket 其实并不是一个协议，而是为了方便使用 TCP 或 UDP 而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。当两台主机通信时，必须通过 Socket 连接 WebSocket 与 HTTP 的关系都是一样基于TCP的，都是可靠性传输协议。 都是应用层协议。 WebSocket 是双向通信协议，可以双向发送或接受信息。HTTP 是单向的。 WebSocket 是需要浏览器和服务器握手进行建立连接的。而 HTTP 是浏览器发起向服务器的连接，服务器预先并不知道这个连接。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ping命令的执行过程和应用协议以及ARP协议]]></title>
    <url>%2F2019%2F06%2F28%2FPing%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%92%8C%E5%BA%94%E7%94%A8%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[ICMP协议ICMP是“Internet Control Message Ptotocol”的缩写。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。在网络中经常会使用到ICMP协议。例如经常用于检查网络不通的ping命令，这个ping的过程实际上就是ICMP协议工作的过程。还有跟踪路由的trancert命令也是基于ICMP协议的。 Ping命令ping.exe的原理向指定的IP地址发送一定长度的数据包，按照约定，若指定IP地址存在的话，会返回同样大小的数据包，当然，若在特定时间内没有返回，就是“超时”，会被认为指定的IP地址不存在。由于ping使用的是ICMP协议，有些防火墙软件会屏蔽ICMP协议，所以有时候ping的结果只能作为参考，ping不通并不一定说明对方IP不存在。 Ping命令过程机器A ping 机器B 同一网段 ping通知系统建立一个固定格式的ICMP请求数据包 ICMP协议打包这个数据包和机器B的IP地址转交给IP协议层（一组后台运行的进程，与ICMP类似） IP层协议将以机器B的IP地址为目的地址，本机IP地址为源地址，加上一些其他的控制信息，构建一个IP数据包 获取机器B的MAC地址 IP层协议通过机器B的IP地址和自己的子网掩码，发现它跟自己属同一网络，就直接在本网络查找这台机器的MAC。 若两台机器之前有过通信，在机器A的ARP缓存表应该有B机IP与其MAC的映射关系；若没有，则发送ARP请求广播，得到机器B的MAC地址，一并交给数据链路层 数据链路层构建一个数据帧，目的地址是IP层传过来的MAC地址，源地址是本机的MAC地址，再附加一些控制信息，依据以太网的介质访问规则，将他们传送出去机器B收到这个数据帧后，先检查目的地址，和本机MAC地址对比 符合，接收。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP协议层协议。IP层检查后，将有用的信息提取交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到主机B类似（这时候主机B已经知道了主机A的MAC地址，不需再发ARP`请求）；不符合，丢弃。 不同网段 ping通知系统建立一个固定格式的ICMP请求数据包 ICMP协议打包这个数据包和机器B的IP地址转交给IP协议层（一组后台运行的进程，与ICMP类似） IP层协议将以机器B的IP地址为目的地址，本机IP地址为源地址，加上一些其他的控制信息，构建一个IP数据包 获取主机B的MAC地址 IP协议通过计算发现主机B与自己不在同一网段内，就直接交给路由处理，就是将路由的MAC取过来，至于怎么得到路由的MAC地址，和之前一样，先在ARP缓存表中寻找，找不到可以利用广播。路由得到这个数据帧之后，再跟主机B联系，若找不到，就向主机A返回一个超时信息。 Ping结果 Request timed out：对方与自己不在同一网段内，通过路由也无法到达；对方已关机，或者网络上没有这个地址；对方存在，不过设置了ICMP数据包过滤；错误设置IP地址 Destination host Unreachable：自己未设定默认路由，对方跟自己不在同已网段。 Bad ip address：没有连接到DNS服务器，无法解析IP，也可能是IP不存在 Source quench received：对方或中途服务器繁忙而无法应答 Ping 127.0.0.1：如果ping不通，则表明本地址TCP/IP协议不能正常工作 ARP协议什么是ARP协议？网络层以上的协议用IP地址来标识网络接口，但以太数据帧传输时，以物理地址来标识网络接口。因此我们需要进行IP地址与物理地址之间的转化。对于IPv4来说，我们使用ARP地址解析协议来完成IP地址与物理地址的转化（IPv6使用邻居发现协议进行IP地址与物理地址的转化，它包含在ICMPv6中）.ARP协议提供了网络层地址（IP地址）到物理地址（mac地址）之间的动态映射。ARP协议 是地址解析的通用协议。 工作流程 每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址（以太网地址）之间的对应关系。 主机（网络接口）新加入网络时（也可能只是MAC 地址发生变化，接口重启等）， 会发送免费ARP报文把自己IP地址与Mac地址的映射关系广播给其他主机。 网络上的主机接收到免费ARP报文时，会更新自己的ARP缓冲区。将新的映射关系更新到自己的ARP表中。 某个主机需要发送报文时，首先检查 ARP 列表中是否有对应 IP 地址的目的主机的 MAC 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 ARP 数据包，该数据包包括的内容有：源主机 IP 地址，源主机 MAC 地址，目的主机的 IP 地址等。 当本网络的所有主机收到该 ARP 数据包时： ​ 首先检查数据包中的IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包。 ​ 如果是，则首先从数据包中取出源主机的 IP和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖。 ​ 然后将自己的 MAC地址写入ARP响应包中告诉源主机自己是它想要找的MAC地址。 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP查询失败。 获取目的端的MAC地址(在一个以太网中)步骤 发送ARP请求的以太网数据帧给以太网上的每个主机，即广播(以太网源地址填全1)。ARP请求帧中包含了目的主机的IP地址。 目的主机收到了该ARP请求之后，会发送一个ARP应答，里面包含了目的主机的MAC地址。 报文格式]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Ping</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F06%2F27%2FRedis%2F</url>
    <content type="text"><![CDATA[Redis是什么，用在哪Redis 是一个使用 C 语言写成的，开源的 key-value 数据库，和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string (字符串)、list (链表)、set (集合)、zset ( sorted set –有序集合)和 hash（哈希类型）。与memcached 一样，为了保证效率，数据都是缓存在内存中。区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave(主从)同步。 Redis 使用场景： 记录帖子点赞数、点击数、评论数； 缓存近期热帖； 缓存文章详情信息； 记录用户会话信息。 个人感觉Redis有2个作用，一个是缓存的作用，就是db中的热点数据缓存在其中。第二是对于那些数据结构简单，性能要求高、一致性要求低的数据，直接存入Redis，它也会持久化的。 Redis 的缺点是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。Redis 不具备自动容错和恢复功能 Redis是单线程的为什么速度那么快 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是 O(1)； 数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的； 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 使用多路 I/O 复用模型，非阻塞 IO； 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； 那么为什么 Redis 是单线程？ 因为 Redis 是基于内存的操作，CPU不是Redis的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。多线程的话还需要考虑切换线程的损失，线程安全这些问题。 Redis功能 数据缓存功能 分布式锁的功能 支持数据持久化 支持事务 支持消息队列 Redis和memcache有什么区别 存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。 数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。 使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 value 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。 Redis和MySql的区别 类型上：从类型上来说，mysql是关系型数据库，redis是缓存数据库 作用上：mysql用于持久化的存储数据到硬盘，功能强大，但是每次请求访问数据库时，都存在着I/O操作，如果反复频繁的访问数据库会在反复链接数据库上花费大量时间，从而导致运行效率过慢并且也会导致数据库的负载过高，那么此时缓存的概念就衍生了出来；redis用于存储使用较为频繁的数据到缓存中，读取速度快 需求上：mysql和redis因为需求的不同，一般都是配合使用 Redis 支持的数据类型有哪些？用在什么场景？StringString数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。 HashHash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。 Listlist就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，最新消息排行等功能都可以用Redis的list结构来实现。 Set当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择。在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同喜好、二度好友等功能。 Sorted Set和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用Redis中的SortedSet结构进行存储。 Redis底层的数据结构MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略： volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集中任意选择数据淘汰 allkeys-lru：从数据集中挑选最近最少使用的数据淘汰 allkeys-random：从数据集中任意选择数据淘汰 no-enviction：禁止驱逐数据 Redis采用的内存回收算法：引用计数法或者LRU算法。 Redis的并发竞争问题如何解决?Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法： 客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。 服务器角度，利用setnx实现锁。 Redis缓存穿透，缓存雪崩，缓存击穿Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。除此之外一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。 缓存穿透缓存穿透，是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。 解决方案有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被 这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟 缓存雪崩在某一个时间段，缓存集中过期失效。特别是电商中。 解决方案缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 缓存击穿缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。 解决方案使用互斥锁 (mutex key)，简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX 或者 Memcache 的 ADD）去set一个mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法。 怎么保证缓存和数据库数据的一致性 合理设置缓存的过期时间。 新增、更改、删除数据库操作时同步更新 Redis，可以使用事务机制来保证数据的一致性。 缓存技术Redis持久化方式Redis 有两种持久化的方式：快照（RDB 文件）和追加式文件（AOF 文件） RDB 持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。 AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存。 Redis 的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。 两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。 RDB工作原理： Redis 调用 fork() ，产生一个子进程。 子进程把数据写到一个临时的 RDB 文件。 当子进程写完新的 RDB 文件后，把旧的 RDB 文件替换掉。 优点： RDB 文件是一个很简洁的单文件，它保存了某个时间点的 Redis 数据，很适合用于做备份。你可以设定一个时间点对 RDB 文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本。 基于上面所描述的特性，RDB 很适合用于灾备。单文件很方便就能传输到远程的服务器上。 RDB 的性能很好，需要进行持久化时，主进程会 fork 一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的 I/O 操作。 比起 AOF，在数据量比较大的情况下，RDB 的启动速度更快。 缺点： RDB 容易造成数据的丢失。假设每 5 分钟保存一次快照，如果 Redis 因为某些原因不能正常工作，那么从上次产生快照到 Redis 出现问题这段时间的数据就会丢失了。 RDB 使用 fork() 产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成 Redis 停止服务几毫秒。如果数据量很大且 CPU 性能不是很好的时候，停止服务的时间甚至会到 1 秒。 AOF快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。而 AOF 文件则提供了一种更为可靠的持久化方式。每当 Redis 接受到会修改数据集的命令时，就会把命令追加到 AOF 文件里，当你重启 Redis 时，AOF里的命令会被重新执行一次，重建数据。 优点： 比 RDB 可靠。 当 AOF 文件太大时，Redis 会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时Redis 会继续往旧的文件追加数据。 AOF 把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。 缺点 在相同的数据集下，AOF 文件的大小一般会比 RDB 文件大。 在某些 fsync 策略下，AOF 的速度会比 RDB 慢。通常 fsync 设置为每秒一次就能获得比较高的性能，而在禁止fsync 的情况下速度可以达到 RDB 的水平。 在过去曾经发现一些很罕见的 BUG 导致使用 AOF 重建的数据跟原数据不一致的问题。 Redis集群，持久化方式事务Redis实现PV，UV]]></content>
      <categories>
        <category>SpringBoot项目</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习二（知识点总结）]]></title>
    <url>%2F2019%2F06%2F27%2FReact%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[React组件&amp;propsReact编写组件主要是有两种方式：函数组件和class组件。一般声明组件的时候都会申明为首字母大写。 定义组件最简单的方式就是编写JavaScript函数： 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 还可以使用ES6的 class来定义组件： 12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 注意有一点：React是一个直接操作数据的声名式框架，它不会直接操作DOM，它是通过虚拟DOM来实现最后的渲染的，会帮我们节约掉大量操作DOM的代码。 子组件和父组件的通信方式父组件想传递信息到子组件是利用props，state属性来实现 子组件想传递给父组件信息的话是通过调用父组件传递给子组件的方法间接的传递信息 子组件和父组件之间通信是单向数据流这个也就是为什么组件无论是使用函数声明还是通过class声明，都决不能修改自身的props。因为这个属性是父组件传递给子组件的。这是为了保证当数据出现错误的时候能很容易的找到出错的地方在哪。 React虚拟DOM在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。 虚拟DOM是React的一大亮点，具有batching(批处理)和高效的Diff算法。 这个批处理优化基于：setState是异步的，当多个变化很相近的时候就放到一起来去生成虚拟DOM。 它也是使得跨端应用得到实现的重要原因。 React修改数据之后的流程 state数据 JSX模板 数据+模板生成虚拟DOM（损耗了性能）：[&#39;div&#39;,{id: &#39;abc&#39;},&#39;hello world!&#39;] 用虚拟DOM的结构生成真实DOM来显示：&lt;div id=&#39;abc&#39;&gt;&#39;hello world!&#39;&lt;/div&gt; state发生改变 数据+模板生成新的虚拟DOM 比较原始虚拟DOM和新的虚拟DOM的区别 直接操作DOM，更改内容 JSX模板变成真实DOM的过程：JSX -&gt; React.createElement -&gt; js对象 -&gt; 真实的DOM。 DIFF算法 两个树的完全的diff算法是一个时间复杂度为 O(n3)的问题。 但是在前端中，你会很少跨层地移动DOM元素，所以真实的DOM算法会对同一个层级的元素进行对比。 div只会和同一层级的div对比，第二层级的只会和第二层级对比。 这样算法复杂度就可以达到O(n). 利用深度优先遍历，记录差异然后把差异引用到真正的DOM树上。 React的生命周期函数React的生命周期分为三个阶段： 挂载阶段 更新阶段 卸载阶段 constructor（组件构造函数）如果没有显示定义它，我们会拥有一个默认的构造函数。在构造函数里面我们一般会做两件事： 初始化state对象 给自定义方法绑定this renderReact中最核心的方法，一个组件中必须要有这个方法 返回的类型有以下几种： 原生的DOM，如div React组件 Fragment（片段） Portals（插槽） 字符串和数字，被渲染成text节点 Boolean和null，不会渲染任何东西 componentDidMount组件装载之后调用，此时我们可以获取到DOM节点并操作，，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅 shouldComponentUpdate函数原型shouldComponentUpdate(nextProps, nextState)，有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true。 componentDidUpdate组件改变之后调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的。在这个函数里我们可以操作DOM，和发起服务器请求，还可以setState，但是注意一定要用if语句控制，否则会导致无限循环 componentWillUnmount当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作 注意不要在这个函数里去调用setState，因为组件不会重新渲染了。 之前还有componentWillMount()和componentDidMount()是组件即将被渲染到页面之前触发和组件已经被渲染到页面中后触发，这个在现在的版本已经被去除了。使用HOOK能很方便的代替生命周期函数。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash冲突的几种解决方法]]></title>
    <url>%2F2019%2F06%2F25%2FHash%E5%86%B2%E7%AA%81%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[开放定值法： 也叫再散列法，当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi，将相应元素存入其中。 通常都是用以下公式计算：Hi=（H（key）+di）% m i=1，2，…，n 其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有三种：线性探测再散列（冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表），二次探测再散列（冲突发生时，在表的左右进行跳跃式探测，直到找到空单元），伪随机探测再散列。 链地址法： 这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。像之前看到的HashMap就是利用这种方法解决Hash冲突的。 再哈希法： 多写几个哈希函数，算出来一个hashcode重复的就用另一个哈希函数算，直到算出来不一样。 建立一个公共溢出区域，就是把冲突的都放在另一个地方，不在表里面。]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
      <tags>
        <tag>Hash冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volatile关键字]]></title>
    <url>%2F2019%2F06%2F25%2FVolatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[为什么会有这个关键字？计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，会涉及到数据的读取和写入，但由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。 也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。这样的操作在单线程中不会出现什么问题，但是在多线程中运行就可能会出现问题，会出现缓存不一致问题。所以在多线程的时候就需要加锁了，我们知道的在CourrentHashMap中是通过分段锁和CAS来实现线程安全的，这里面就涉及到了Volatile关键字。 并发编程的的三个概念（特性）原子性原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 12345//线程1执行的代码int i = 0;i = 10;//线程2执行的代码j = i; 假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 有序性有序性：即程序执行的顺序按照代码的先后顺序执行。 1234int i = 0; boolean flag = false;i = 1; //语句1 flag = true; //语句2 一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。所以JVM在真正执行这段代码的时候不会保证语句1一定会在语句2前面执行。 指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 volatile关键字的两层语义一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的内存可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 它能保证程序的可见性，一定程度的有序性，但是不能保证原子性（可以采用synchronized）。 使用volatile必须具备以下2个条件： 对变量的写操作不依赖于当前值 该变量没有包含在具有其他变量的不变式中 Volatile底层原理如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。 lock前缀指令实际相当于一个内存屏障（由于现代操作系统都是多处理器操作系统，每个处理器都会有自己的缓存，可能存再不同处理器缓存不一致的问题，而且由于操作系统可能存在重排序，导致读取到错误的数据，因此，操作系统提供了一些内存屏障以解决这种问题），它提供以下功能： 重排序时不能把后面的指令重排序到内存屏障之前的位置 使得本CPU的Cache写入内存 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。 这样的话两个线程改变内容的时候就是这样的 写两条线程Thread-A与Threab-B同时操作主存中的一个volatile变量i时，Thread-A写了变量i，那么： Thread-A发出LOCK#指令 发出的LOCK#指令锁总线（或锁缓存行），同时让Thread-B高速缓存中的缓存行内容失效 Thread-A向主存回写最新修改的i Thread-B读取变量i，那么： Thread-B发现对应地址的缓存行被锁了，等待锁的释放，缓存一致性协议会保证它读取到最新的值 由此可以看出，volatile关键字的读和普通变量的读取相比基本没差别，差别主要还是在变量的写操作上。]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap,HashTable，CourrentHashMap]]></title>
    <url>%2F2019%2F06%2F24%2FHashMap-HashTable-CourrentHashMap%2F</url>
    <content type="text"><![CDATA[HashMap我们知道Map是一个key-val的集合，HashMap是基于Hash表的Map接口的非同步实现。HashMap的基本数据结构是数组和链表。 HashMap原理基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，返回的hashCode用于找到bucket位置来储存Entry对象。如果该位置已经有元素了,调用equals方法判断是否相等,相等的话就进行替换值,不相等的话,放在链表里面. 当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象 HashMap的存储原理和存储过程声明一个下标范围比较大的数组来存储元素，另外设计一个哈希函数获得每一个元素的Key（关键字）的函数值（即数组下标，hash值）相对应，数组存储的元素是一个Entry类，这个类有三个数据域，key、value（键值对），next(指向下一个Entry)。 当两个key通过哈希函数计算相同时，则发生了hash冲突(碰撞)，HashMap解决hash冲突的方式是用链表。 例如， 第一个键值对A进来。通过计算其key的hash得到的index=0。记做:Entry[0] = A。 第二个键值对B，通过计算其index也等于0， HashMap会将B.next =A,Entry[0] =B, 第三个键值对 C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方事实上存取了A,B,C三个键值对,它们通过next这个属性链接在一起。所以当hash冲突很多时，HashMap退化成链表。 put过程： 先判断键值对数组table[i] 是否为空否则进行扩容操作（resize（））； 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加到最后一步，如果table[i]不为空进行下一步； 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则进行下一步，这里的相同指的是hashCode以及equals； 判断table[i]是否为treeNode，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则进行下一步； 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 get过程： 先通过key值进行哈哈希函数的运算得到hash值； 调用getNode()，得到桶号； 在桶里面找元素和key值相等的即可，未找到返回空。 hashmap的负载因子HashMap的初始化容量为什么为2的次幂？因为在get（）方法中，获得元素的位置是通过(length- 1) &amp; h来得到的，其中h:为插入元素的hashcode length:为map的容量大小。如果length为2的次幂 则length-1 转化为二进制必定是11111……的形式，在于h的二进制与操作效率会非常的快，而且空间不浪费。如果是其他的话，空间不够，碰撞的几率变大，查询变慢，空间会浪费。 为什么HashMap是非线程安全的？首先我们知道为了减少冲突，我们需要时刻留意当前的size是否太大，检查是否需要扩容，一旦超过设定的threshold，那么就要重新增大数组尺寸，此时所有元素都需要重新计算应该放置的下标。同时HashMap在扩容的时候，是通过重新创建一个新的hash表，把原来旧数组中的Entry一个个迁移到新数组的，注意一点就是计算在newTable中的位置，原来在同一条链上的元素可能被分配到不同的位置，看下面的源码。每次会扩容长度为以前的2倍，原因看上面。 1234567891011121314151617181920void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; //将每条链中的元素迁移过去 for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; //遍历第j条链 do &#123; Entry&lt;K,V&gt; next = e.next; // 计算在newTable中的位置，原来在同一条链上的元素可能被分配到不同的位置 int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125; &#125; 单线程的情况resize（）是没有问题的，但是多线程的时候就可能会出现形成环形链表的情况，导致扩容失败。具体详细的图可以看https://blog.csdn.net/andy_budd/article/details/81413464 HashMap和HashTable的区别：HashTable 是不能接受NULL，NULL值组合的，而HashMap可以。（因为HashMap做了对应的NULL值处理，会把NULL值的键值对放到hashcode为0的链表里面）。 HashTable是线程安全的，HashMap是线程非安全的。因为HashTable是synchronized，要想是HashMap线程安全Map m = Collections.synchronizeMap(hashMap). HashMap和TreeMap比较 HashMap适用于在Map中插入、删除和定位元素。 Treemap适用于按自然顺序或自定义顺序遍历键（key）。 HashMap通常比TreeMap快一点（树和哈希表的数据结构使然），建议多使用HashMap,在需要排序的Map时候才用TreeMap。TreeMap的底层是红黑树。 HashMap非线程安全 TreeMap非线程安全 HashMap的结果是没有排序的，而TreeMap输出的结果是排好序的。 为什么HashMap长度大于8才转换为红黑树，而不是6红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。中间有个差值7可以防止链表和树之间频繁的转换。 这个只是简单的说法个人感觉，正确的说话应该是理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，据概率统计决定的。 CourrentHashMapJava 7中的ConcurrentHashMap的底层数据结构仍然是数组和链表。与HashMap不同的是，ConcurrentHashMap最外层不是一个大的数组，而是一个Segment的数组。每个Segment包含一个与HashMap数据结构差不多的链表数组。整体数据结构如下图所示。 get过程 在读写某个Key时，先取该Key的哈希值。并将哈希值的高N位对Segment个数取模从而得到该Key应该属于哪个Segment，接着如同操作HashMap一样操作这个Segment。为了保证不同的值均匀分布到不同的Segment，需要通过如下方法计算哈希值。 Segment继承自ReentrantLock，使用分段锁的机制。 对于写操作，并不要求同时获取所有Segment的锁，因为那样相当于锁住了整个Map。它会先获取该Key-Value对所在的Segment的锁，获取成功后就可以像操作一个普通的HashMap一样操作该Segment，并保证该Segment的安全性。同时由于其它Segment的锁并未被获取，因此理论上可支持concurrencyLevel（等于Segment的个数）个线程安全的并发读写。 对于读操作，获取Key所在的Segment时，需要保证可见性，ConcurrentHashMap并没有通过锁或者volatile关键字，而是通过以下方式。 1Segment&lt;K,V&gt; s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u) Java 8为进一步提高并发性，摒弃了分段锁的方案，而是直接使用一个大的数组。同时为了提高哈希碰撞下的寻址性能，Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))）。其数据结构如下图所示： 这个版本，是通过大量的volatile关键字以及CAS操作来实现线程安全的。 对于put操作，如果Key对应的数组元素为null，则通过CAS操作将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果该put操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。 对于读操作，由于数组被volatile关键字修饰，因此不用担心数组的可见性问题。同时每个元素是一个Node实例（Java 7中每个元素是一个HashEntry），它的Key值和hash值都由final修饰，不可变更，无须关心它们被修改后的可见性问题。而其Value及对下一个元素的引用由volatile修饰，可见性也有保障。 HashMap,HashTable,CourrentHashMap的key和value是否可为nullHashMap对象的key、value值均可为null。 ConcurrentHashMap，HahTable对象的key、value值均不可为null。 HashMap在put的时候会调用hash()方法来计算key的hashcode值，可以从hash算法中看出当key==null时返回的值为0。因此key为null时，hash算法返回值为0，不会调用key的hashcode方法。但是HashTable存入的value为null时，抛出NullPointerException异常。如果value不为null，而key为空，在执行到int hash = key.hashCode()时同样会抛出NullPointerException异常。 那为什么这么设计？ ConcurrentHashmap和Hashtable都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。HashMap是非并发的，可以通过contains(key)来做这个判断。 对于TreeMap的话value是可以为null的，对于key的话未实现 Comparator 接口时，key 不可以为null，否则抛 NullPointerException 异常；当实现Comparator接口时，若未对null情况进行判断，则可能抛 NullPointerException 异常。如果针对null情况实现了，可以存入，但是却不能正常使用get()访问，只能通过遍历去访问。]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css盒模型，布局以及定位]]></title>
    <url>%2F2019%2F06%2F24%2FCss%E7%9B%92%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8A%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[盒模型什么是盒模型CSS盒模型是网页布局的基础 ——每个元素被表示为一个矩形的方框，框的内容、内边距、边界和外边距像洋葱的膜那样，一层包着一层构建起来。浏览器渲染网页布局时，它会算出每个框的内容要用什么样式，周围的洋葱层有多大，以及框相对于其它框放在哪里。 盒模型的属性文档的每个元素被构造成文档布局内的一个矩形框，框每层的大小都可以使用一些特定的CSS属性调整。相关属性如下: width 和 heightwidth和 height设置内容框（content box）的宽度和高度。内容框是框内容显示的区域——包括框内的文本内容，以及表示嵌套子元素的其它框。 还以为设置设置大小约束而不是绝对的大小。这些属性包括min-width，max-width，min-height，max-height。 paddingpadding 表示一个 CSS 框的内边距——这一层位于内容框的外边缘与边界的内边缘之间。该层的大小可以通过简写属性padding一次设置所有四个边，或者通过padding-top，padding-right，padding-left，padding-bottom属性一次设置一个边。 borderborder是一个分隔层，位于内边距的外边缘以及外边距的内边缘之间。边界的默认大小为0——从而让它不可见——不过我们可以设置边界的厚度、风格和颜色让它出现。 border简写属性可以一次设置四个边例如 border: 1px solid black;但这个简写可以被各种普通书写的更详细的属性所覆盖. margin外边距（margin）代表 CSS 框周围的外部区域，称为外边距，它在布局中推开其它 CSS 框。其表现与 padding 很相似；简写属性为margin，单个属性margin-top，margin-right，margin-left，margin-bottom。 外边距有一个特别的行为被称作：外边距塌陷，当两个框彼此接触时，它们的间距将取两个相邻外边界的最大值，而非两者的总和。 溢流当你使用绝对的值设置了一个框的大小（如，固定像素的宽/高），允许的大小可能不适合放置内容，这种情况下内容会从盒子溢流。我们使用overflow属性来控制这种情况的发生。它有一些可能的值，但是最常用的是： auto: 当内容过多，溢流的内容被隐藏，然后出现滚动条来让我们滚动查看所有的内容。 hidden: 当内容过多，溢流的内容被隐藏。 visible: 当内容过多，溢流的内容被显示在盒子的外边（这个是默认的行为） 背景裁剪框的背景是由颜色和图片组成的，它们堆叠在一起（background-color, background-image）。 它们被应用到一个盒子里，然后被画在盒子的下面。默认情况下，背景延伸到了边界外沿。这通常是OK的，但是在一些情况下假使你有一个平铺的背景图，你只想要它延伸到内容的边沿会怎么做？该行为可以通过设置盒子的background-clip属性来调整。 盒类型 块框（ block box）是定义为堆放在其他框上的框（例如：其内容会独占一行），而且可以设置它的宽高，之前所有对于框模型的应用适用于块框 （ block box） 行内框（ inline box）与块框是相反的，它随着文档的文字流动（例如：它将会和周围的文字和其他行内元素出现在同一行，而且它的内容会像一段中的文字一样随着文字部分的流动而打乱），对行内盒设置宽高无效，设置padding, margin 和 border都会更新周围文字的位置，但是对于周围的的块框（ block box）不会有影响。 行内块状框（inline-block box） 像是上述两种的集合：它不会重新另起一行但会像行内框（ inline box）一样随着周围文字而流动，而且他能够设置宽高，并且像块框一样保持了其块特性的完整性，它不会在段落行中断开。 默认状态下display属性值，块级元素display: block ，行内元素display: inline 布局CSS页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口/窗口的位置。会涉及到浮动，定位，css表格，弹性盒子，网格等。 浮动浮动技术允许元素浮动到另外一个元素的左侧或右侧，而不是默认的一个堆叠另一个。float 的主要用途是布置出多个列并且浮动文字以环绕图片。 float属性有四个可能的值： left — 将元素浮动到左侧。 right — 将元素浮动到右侧。 none — 默认值, 不浮动。 inherit — 继承父元素的浮动属性。 清除浮动：clear可以取三个值： left：停止任何活动的左浮动 right：停止任何活动的右浮动 both：停止任何活动的左右浮动 定位定位允许我们将一个元素从它在页面的原始位置准确地移动到另外一个位置。有四种主要的定位类型需要我们了解： 静态定位是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。 相对定位允许我们相对元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计非常有用。 绝对定位将元素完全从页面的正常布局流中移出，类似将它单独放在一个图层中. 我们可以将元素相对于页面的 &lt;html&gt; 元素边缘固定，或者相对于离元素最近的被定位的祖先元素。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板. 固定定位与绝对定位非常类似，除了它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。 在创建类似页面滚动总是处于页面上方的导航菜单时非常有用。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM知识点]]></title>
    <url>%2F2019%2F06%2F24%2FJVM%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[三个比较容易混淆的概念Java内存模型共享内存模型。线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本 JVM内存结构就是我们接下来要介绍的JVM的内存划分 Java对象结构对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充，可以参考对象在内存中的布局。 JAVA虚拟机JAVA跨平台我们都知道JAVA是一个可以跨平台的语言，那么它为什么可以跨平台？ Java不只是一种编程语言，还是一个完整的操作平台。Java之所以可以跨平台，这离不开JVM虚拟机。JVM是一个软件，在不同的平台上，JVM有不同的版本。Java在编译之后会生成一种.class文件，这种文件成为字节码文件。JVM虚拟机就是将Java编译后的.class文件翻译成特定平台下的机器码，然后运行。也就是说，在不同平台上装上平台对应的JVM虚拟机后，就可以将Java字节码文件转换，然后运行我们的Java程序。 Java编译后的结果是生成字节码，而不是机器码。字节码是不可以直接运行的，必须通过JVM再次翻译成机器码才可以运行。即使是将Java程序打包成可执行文件，也仍然需要JVM的支持才可以运行。跨平台的是Java程序，而不是JVM。JVM是用C/C++开发的，不能平台，不同的平台下JVM的版本是不同的。 JAVA虚拟机内存划分在Java中，程序员把内存控制权利交给 Java 虚拟机而不用像c++为一个 new 操作去写对应的 delete/free 操作，因此不是很容易出现内存泄露和溢出的问题。 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域： 其中线程私有的有：虚拟机栈，本地方法栈，程序计数器；线程共共享的有堆，方法区，直接内存。 JAVA堆Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。同时它也是是垃圾收集器管理的主要区域，因此也被称作GC堆，Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。(分代的唯一理由就是优化GC性能) 新生代分为：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1。我们通过图再看一下： 因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 一般情况下，新创建的对象都会被分配到Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。(一些大对象特殊处理：大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝新生代采用复制算法收集内存),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到老年代中。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 新生代和老年代的一些区别：新生代和老年代是针对于分代收集算法来定义的，新生代又分为Eden和Survivor两个区。加上老年代就这三个区。数据会首先分配到Eden区 当中（当然也有特殊情况，如果是大对象那么会直接放入到老年代（大对象是指需要大量连续内存空间的java对象）。），当Eden没有足够空间的时候就会 触发jvm发起一次Minor GC。如果对象经过一次Minor GC还存活，并且又能被Survivor空间接受，那么将被移动到Survivor空 间当中。并将其年龄设为1，对象在Survivor每熬过一次Minor GC，年龄就加1，当年龄达到一定的程度（默认为15）时，就会被晋升到老年代 中了，当然晋升老年代的年龄是可以设置的。其实新生代和老年代就是针对于对象做分区存储，更便于回收等等 有关年轻代的几个参数： 1.XX:NewSize和-XX:MaxNewSize 用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。 2.XX:SurvivorRatio 用于设置Eden和其中一个Survivor的比值，这个值也比较重要。默认8:1； 3.XX:+PrintTenuringDistribution 这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。 4-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold 用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。 这上面的也是 JVM 的参数，除了这个以外还有很多，列几个 -Xms 初始堆大小 -Xmn 年轻代大小 -XX:PermSize 设置持久代初始值 -Xss 每个线程的堆栈大小 程序计数器程序计数器的作用：字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，从而实现代码的流程控制；在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 注意：程序计数器是唯不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 JAVA虚拟机栈Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有局部变量表、操作数栈、动态链接、方法出口信息。每个方法从被调用，直到被执行完。对应着一个栈帧在虚拟机中从入栈到出栈的过程 Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。第一个是如果线程请求的栈深度大于虚拟机所允许的深度抛出的错误，第二个则是虚拟机在动态扩展栈时无法申请到足够的内存空间抛出的异常。 通常说的栈就是指局部变量表部分，存放编译期间可知的8种基本数据类型，及对象引用和指令地址。局部变量表是在编译期间完成分配，当进入一个方法时，这个栈中的局部变量分配内存大小是确定的。 jvm 的局部变量表是做什么的？ 存储局部变量、函数调用时传递参数，很多字节码指令都是对局部变量表和操作数栈进行操作的。 本地方法栈该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务，和平台有关的方法。 方法区它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，它有一个别名叫做 Non-Heap（非堆）也常称为永久代，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。 类加载什么是类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 类加载的过程类加载主要分为以下五个步骤：加载，验证，准备，解析，初始化。 加载：程序运行之前jvm会把编译完成的.class二进制文件加载到内存，供程序使用，用到的就是类加载器classLoader。 验证：保证类加载的准确性，看是否是javac 编译的class 文件。 准备：为类的静态变量分配内存，将其初始化为默认值。 解析：把类中的符号引用转化为直接引用。 初始化：为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值。 类加载基于的机制Java类加载器基于三个机制：委托、可见性和单一性。委托就是将加载一个类的请求交给父类加载器，如果没有父类加载器或者父类加载器不给它加载再加载它，可见性是父类加载器不能看到子类的加载的类，但是子类的加载能看到父类的加载的类。单一性是指仅加载一个类一次，这是由委托机制确保子类加载器不会再次加载父类加载器加载过的类。 为什么要双亲委派？ 保证 java 类库中的类不受用户类影响，防止用户自定义一个类库中的同名类，引起问题。除此之外还有安全性考虑，系统定义的类只能由顶层类加载器加载 我们常见的有三种加载器：Bootstrap 类加载器（加载 java 核心类库，JVM 自身需要的类）、Extension 类加载器（加载 Java 的扩展库）和 System 类加载器（Java 应用的类路径来加载 Java 类） 注意：使用不同的类加载器，你可以从不同的源地址加载同一个类，它们被视为不同的类。 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误 几个类加载器的层次关系： 如何自定义自己的类加载器继承 ClassLoader，重写 findClass 方法，实现加载自定义路径下 class 文件的逻辑。 自己写个String能加载吗加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是说当发现这个类没有的时候会先去让自己的父类去加载，父类没有再让儿子去加载，那么在这个例子中我们自己写的String应该是被Bootstrap ClassLoader加载了，所以App ClassLoader就不会再去加载我们写的String类了，导致我们写的String类是没有被加载的。但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载 jre.jar 包中的那个 java.lang.String。双亲委派机制是可以打破的， 所以，这些类都是可以重写的。 但是JVM出于安全的考虑， 你自己写的类 ， 不能用java.* 开头， 否则都不会被加载。 懂了吧， 总结一下就是： 可以写， 但是包名要改。 类初始化时机只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如 Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类 Java虚拟机结束生命周期在如下几种情况下，Java虚拟机将结束生命周期： 执行了 System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 JVM初始化步骤 假如这个类还没有被加载和连接，则程序先加载并连接该类 假如该类的直接父类还没有被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 对象的创建对象的创建的过程： 类加载检查—&gt;分配内存—&gt;初始化零值—&gt;设置对象头—&gt;执行 init 。 类加载检查： 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存：类加载检查通过后，接下来虚拟机将为新生对象分配内存。分配方式有：指针碰撞 和 空闲列表两种。在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的。 初始化零值：虚拟机将分配到的内存空间都初始化为零值。 设置对象头：虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 执行 init ：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，所以要执行程序写的 init 方法。 GC算法与垃圾回收为什么需要垃圾回收以及什么时候GC首先因为内存是有限的，在不断的分配内存空间而不回收的话内存迟早都会被消耗完，所以垃圾回收是必须的。 触发 GC 的条件： 1.GC 在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用。 2.Java 堆内存不足时，GC 会被调用。 触发 Full GC：调用 Sytem.GC()；老年代空间不足时；GC 担保失败。 GC涉及到的内存部分主要是堆，还包括方法区（针对常量池的内存回收和对已加载类的卸载） 对象存活判断判断对象是否存活一般有两种方式： 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。能够作为GC Roots对象的有：虚拟机栈中引用的对象，方法区中的类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象。 GC算法 标记—清除：程序暂停运行，启动GC，GC从堆或静态存储区开始遍历所有对象，判断对象是否“活”的对象，如果是活不删除，反之删除。判断是否“活”就是判断该对象是否有被其他对象引用，从链上去查找。当是活对象时，会给对象给个标记符号，死对象则不标记，遍历完后，第二次遍历时，只保留标记的对象，把所有没标记的对象都删除。 停止—复制：程序暂停运行，启动GC，GC从堆或静态存储区开始遍历所有对象，判断对象是否“活”的对象，如果是活不删除，反之删除。判断是否“活”就是判断该对象是否有被其他对象引用，从链上去查找。当是活对象时，GC会从另外堆里开避一个大空间，然后将活对象复制一份到新空间里，在复制时按着紧密排列，同时更新所有引用地址为新的地址，不活对象原封不动。遍历完后，再遍历一次，这次是将不活的对象彻底给删除。 优点：所有对象能够重新紧密排列，不会出现内存碎片，这对以后创建对象能提供更快的效率。 缺点：占用的内存空间大，要原对象的2倍空间；这种模式无论如何所有活的对象都要复制一份，假设遍历到最后，对象很稳定，只出现少量垃圾对象或者根本没垃圾对象，这时已经做了复制工作，浪费了资源。 标记—整理：标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。 分代收集：根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。 复制整理和标记回收有有什么优劣 复制整理不涉及到对象的删除，只是把可用的对象从一个地方拷贝到另一个地方，因此适合大量对象回收的场景，比如新生代的回收 标记回收：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续，适用于低频操作、数量少，大对象回收，如老年代，但会增加停顿时间 垃圾收集器 CMS 垃圾收集器：获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法。 初始标记(标记GCRoots能直接关联到的对象，时间很短)-&gt; 并发标记(进行可达性分析过程，时间很长)-&gt; 重新标记-&gt;并发清除(回收内存空间，时间很长) G1收集器 并行和并发：使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行 分代收集：独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果 空间整合：基于标记 - 整理算法，无内存碎片产生。 Java变量申明后存放的区域 寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制. 栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（ new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。） 堆：存放所有 new 出来的对象。 静态域：存放静态成员（ static 定义的） 常量池：存放字符串常量和基本类型常量（ public static final ）。 栈和常量池中的数据是可以共享的，但是堆的数据是不可以共享的。 打个比方像 String 的变量申明之后，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new 出来的）才能确定的就存储在堆中。 java中new对象干的几件事例如：User u = new User(); 在堆空间里以 User 为模板创造了一个 类对象，然后立刻调用 User 类的构造函数给这个类对象初始化 创造了一个 User 的引用对象，类似 c++ 中的指针，指向这个刚刚创建好的对象。这个引用对象是放在栈里面的（垃圾回收会自动回收） 什么时候一个对象会被GC比方说我们使用的判断一个对象是否存活的方式是可达性分析，即使在可达性分析算法中不可达的对象，也不是一定会死亡的，要真正宣告一个对象“死亡”，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finaliza() 方法。当对象没有覆盖 finaliza( ) 方法，或者 finaliza( ) 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，否则此对象将会放置在一个叫做 F-Queue 的队列中，最后在 finaliza( ) 方法调用中如果这个对象重新 一个对象从创建到销毁都是怎么在这些部分里存活和转移的？对象的创建 定位到方法区常量池的类，检查类是否已经被加载、验证、准备、解析。 检查类是否已经进行过初始化。 在内存中分配空间 设置对象的默认初始值(0,false,null) 执行()方法(类变量的赋值和静态代码块) 执行构造 在线程栈中设置对象引用 对象在内存中的布局对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充。 对象头：每一个堆中的对象在 HosPost 虚拟机中都有一个对象头，对象头里存储两部分信息：一部分是运行时对象自身的哈希码值 (HashCode)、GC 分代年龄 (Generational GC Age)、锁标志位（占用 2 个 bit 的位置）等信息，另一部分是指向方法去中的类型信息的指针。如果是数组对象的话，还会有额外一部分用来存储数组长度。 实例数据：是程序代码中定义的各种类型的字段内容。 对齐填充：并不是必然存在的，仅仅在对象的大小不是8字节的整数倍时起占位符的作用。 对象的访问方式 句柄：java 堆中划出一块空间单独存放句柄池，java 栈中的 reference 指向句柄池中的某个句柄，句柄包含两部分信息：堆中实例对象地址和方法区中对象类型信息。 直接指针：java 栈中的 reference 指向 java 堆中的实例对象，每个实例对象上有一部分信息是用来指向该对象在方法区中的类型信息。 句柄的优势：当对象发生改变时，reference 的值不用变，只需要改变句柄的实例指针，reference 自身不需要改变。直接指针的优势：节省了一次指针定位的开销，速度更快。HosPot 虚拟机采用第二种方式。 销毁对象完成使命后，等待 GC 进行垃圾回收。销毁对象即清理对象所占用的内存空间，会调用对象的 finalize( ) 方法。]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer刷题（持续更新）]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目一 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路首先我们知道了最小数是第一行第一个，最大数是最后一行的最后一个，每一行最大的一个数是每一行的最后一个，每一行最小一个数是每一行的第一个。 所以先从第一行的最后一个数设为J开始比较，如果目标大于J，则与下一行的最后一个数比较，如此循环，直到目标比J小 当目标比J小时，我们就能确定是哪一行然后往该行的前面递减。 AC代码c++版： 123456789101112131415161718192021222324class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int n = array.size(); if(n == 0) return false; int m = array[0].size(); int i = 0; int j = m-1; while(i&lt;n &amp;&amp; j&gt;=0)&#123; int temp = array[i][j]; if(target &lt; temp)&#123; j--; &#125; else if(target &gt; temp)&#123; i++; &#125; else&#123; return true; &#125; &#125; return false; &#125;&#125;; Java版： 123456789101112131415161718192021222324public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array == null)&#123; return false; &#125; int n = array.length; int m = array[0].length; int i = 0; int j = m-1; while(i&lt;n &amp;&amp; j&gt;=0)&#123; int temp = array[i][j]; if(target &lt; temp)&#123; j--; &#125; else if(target &gt; temp)&#123; i++; &#125; else&#123; return true; &#125; &#125; return false; &#125;&#125; 题目二 替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路第一个想法肯定就是从头开始找到一个空格就替换，但是这样的时间复杂度是O(n^2)的，因为你要写两重循环，我们可以降低时间复杂度，先预处理出来空格的个数，然后从后往前碰到空格进行替换，最后得到结果。当然这题用Java就巨简单了，Java提供替代函数。 AC代码c++版： 123456789101112131415161718192021222324252627class Solution &#123;public: void replaceSpace(char *str,int length) &#123; int blankNumber = 0; int oldstringLen; for (oldstringLen = 0; str[oldstringLen] != '\0'; oldstringLen++)&#123; if (str[oldstringLen] == ' ') blankNumber++; &#125; int newstringLen = oldstringLen + blankNumber * 2; if (newstringLen&gt;length) return; str[newstringLen] = '\0'; int point1 = oldstringLen - 1, point2 = newstringLen - 1; while (point1 &gt;= 0 &amp;&amp; point2&gt;point1)&#123;//两指针相同时，跳出循环 if (str[point1] == ' ')&#123; str[point2--] = '0'; str[point2--] = '2'; str[point2--] = '%'; &#125; else str[point2--] = str[point1]; point1--; &#125; &#125;&#125;; Java版： 12345public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replaceAll("\\s", "%20"); &#125;&#125; 题目三 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 思路因为链表是从头到尾，但是要从尾到头，所以很自然的就想到用Stack先存储对应的值，然后取出来放到ArrayList中。 AC代码c++版： 12345678910111213141516171819202122232425262728/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; ListNode *q=head; stack&lt;int&gt;s; vector&lt;int&gt;a; while(q!=NULL) &#123; s.push(q-&gt;val); q=q-&gt;next; &#125; while(!s.empty()) &#123; a.push_back(s.top()); s.pop(); &#125; return a; &#125;&#125;; Java版： 1234567891011121314151617181920212223242526272829/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); Stack&lt;Integer&gt; temp = new Stack&lt;Integer&gt;(); ListNode head = listNode; while(head!=null)&#123; temp.push(head.val); head=head.next; &#125; while(temp.size()!=0)&#123; ans.add(temp.peek()); temp.pop(); &#125; return ans; &#125;&#125; 题目四 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路之前写过这样的思路，就是根据前序和中序排列的特性找到root，不断进行递归就可以了。c++版是直接拿了别人的，个人不建议这么写，可以看Java版的会容易理解一点 AC代码c++版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: struct TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; in) &#123; if (pre.size() == 0 || pre.size() != in.size()) &#123; return NULL; &#125; vector&lt;int&gt; pre_left; vector&lt;int&gt; pre_right; vector&lt;int&gt; in_left; vector&lt;int&gt; in_right; TreeNode *root = new TreeNode(pre.at(0)); // 查找根在中序数组中的位置 int rootIndex = 0; for (int i = 0; i &lt; in.size(); ++i) &#123; if (in.at(i) == pre.at(0)) &#123; rootIndex = i; break; &#125; &#125; // 左子树部分 for (int i = 0; i &lt; rootIndex; ++i) &#123; in_left.push_back(in.at(i)); if (i + 1 &lt; pre.size()) &#123; pre_left.push_back(pre.at(i + 1)); &#125; &#125; // 右子树部分 for (int i = rootIndex + 1; i &lt; in.size(); ++i) &#123; in_right.push_back(in.at(i)); pre_right.push_back(pre.at(i)); &#125; root-&gt;left = reConstructBinaryTree(pre_left, in_left); root-&gt;right = reConstructBinaryTree(pre_right, in_right); return root; &#125;&#125;; Java版： 1234567891011121314151617181920212223242526272829/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root = funre(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; public TreeNode funre(int[] pre,int startPre,int endPre,int[] in,int startIn,int endIn)&#123; if(startPre&gt;endPre||startIn&gt;endIn)&#123; return null; &#125; TreeNode root = new TreeNode(pre[startPre]); for(int i=startIn;i&lt;=endIn;i++)&#123; if(in[i] == pre[startPre])&#123; root.left = funre(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); root.right = funre(pre,startPre+i-startIn+1,endPre,in,i+1,endIn); &#125; &#125; return root; &#125;&#125; 题目五 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路一个栈存储放进来的值，一个栈用来pop，看下代码就知道了。 AC代码c++版： 123456789101112131415161718192021222324class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; int result; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.top()); stack1.pop(); &#125; &#125; result = stack2.top(); stack2.pop(); return result; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; Java版： 12345678910111213141516171819202122import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(stack2.size()==0)&#123; while(stack1.size()!=0)&#123; stack2.push(stack1.peek()); stack1.pop(); &#125; &#125; int temp=stack2.peek(); stack2.pop(); return temp; &#125;&#125; 题目六 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路就是找到这个数组的最小值。 AC代码c++版： 123456789101112131415class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; v) &#123; int len=v.size(); if(len==0)&#123; return 0; &#125; int ans=v[0]; for(int i=1;i&lt;len;i++)&#123; if(v[i]&lt;ans) ans=v[i]; &#125; return ans; &#125;&#125;; Java版： 12345678910111213141516import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if(array==null)&#123; return 0; &#125; int len=array.length; int ans=array[0]; for(int i=1;i&lt;len;i++)&#123; if(array[i]&lt;ans)&#123; ans=array[i]; &#125; &#125; return ans; &#125;&#125; 题目七 斐波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39 思路经典斐波那契数列求值。 AC代码c++版： 1234567891011class Solution &#123;public: int Fibonacci(int n) &#123; int a[45]; a[0] = 0; a[1] = 1; for(int i = 2; i &lt;= n; i++) a[i] = a[i-1] + a[i-2]; return a[n]; &#125;&#125;; Java版： 12345678910public class Solution &#123; public int Fibonacci(int n) &#123; int[] a = new int[45]; a[0]=0; a[1]=1; for(int i=2;i&lt;=n;i++) a[i]=a[i-1]+a[i-2]; return a[n]; &#125;&#125; 题目八 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路每层台阶可由下一层或者下两层跳上来，就是斐波那契数列递归求解即可。 AC代码c++版： 1234567891011class Solution &#123;public: int jumpFloor(int number) &#123; if(number == 1) return 1; else if(number == 2) return 2; else return jumpFloor(number-1)+jumpFloor(number-2); &#125;&#125;; Java版： 12345678910public class Solution &#123; public int JumpFloor(int target) &#123; if(target == 1) return 1; else if(target == 2) return 2; else return JumpFloor(target-1)+JumpFloor(target-2); &#125;&#125; 题目九 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路和斐波那契数列推导一样，这个推一下吧。 用Fib(n)表示青蛙跳上n阶台阶的跳法数，青蛙一次性跳上n阶台阶的跳法数1(n阶跳)，设定Fib(0) = 1； 当n = 1 时，只有一种跳法，即1阶跳：Fib(1) = 1; 当n = 2 时，有两种跳的方式，一阶跳和二阶跳：Fib(2) = Fib(1) + Fib(0) = 2; 当n = 3 时，有三种跳的方式，第一次跳出一阶后，后面还有Fib(3-1)中跳法；第一次跳出二阶后，后面还有Fib(3-2)中跳法；第一次跳出三阶后，后面还有Fib(3-3)中跳法 当n = n 时，共有n种跳的方式，第一次跳出一阶后，后面还有Fib(n-1)中跳法；第一次跳出二阶后，后面还有Fib(n-2)中跳法…第一次跳出n阶后，后面还有 Fib(n-n)中跳法. Fib(n) = Fib(n-1)+Fib(n-2)+Fib(n-3)+……….+Fib(n-n)=Fib(0)+Fib(1)+Fib(2)+…….+Fib(n-1)又因为Fib(n-1)=Fib(0)+Fib(1)+Fib(2)+…….+Fib(n-2) 两式相减得：Fib(n) = 2*Fib(n-1) n &gt;= 2 AC代码c++版： 1234567891011class Solution &#123;public: int jumpFloorII(int number) &#123; if(number==0) return 0; else if(number==1) return 1; else return 2*jumpFloorII(number-1); &#125;&#125;; Java版： 12345678910public class Solution &#123; public int JumpFloorII(int target) &#123; if(target == 0) return 0; else if(target == 1) return 1; else return 2*JumpFloorII(target-1); &#125;&#125; 题目十 矩形覆盖题目描述我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 思路n=1 ：只有横放一个矩形一种解决办法n=2 ：有横放一个矩形，竖放两个矩形两种解决办法n=3 ：n=2的基础上加1个横向，n=1的基础上加2个竖向n=4：n=3的基础上加1个横向，n=2的基础上加2个竖向 ... n=n ：n = f(n-1) + f(n-2) AC代码c++版： 1234567891011class Solution &#123;public: int jumpFloorII(int number) &#123; if(number==0) return 0; else if(number==1) return 1; else return 2*jumpFloorII(number-1); &#125;&#125;; Java版： 12345678910public class Solution &#123; public int JumpFloorII(int target) &#123; if(target == 0) return 0; else if(target == 1) return 1; else return 2*JumpFloorII(target-1); &#125;&#125; 题目十一 二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路把一个整数减去1，再和原整数做与运算，会把该整数最右边的一个1变成0.那么一个整数的二进制表示中有多少个1，就可以进行多少次运算 AC代码c++版： 1234567891011class Solution &#123;public: int NumberOf1(int n) &#123; int ans=0; while(n)&#123; n&amp;=(n-1); ans++; &#125; return ans; &#125;&#125;; Java版： 12345678910public class Solution &#123; public int NumberOf1(int n) &#123; int ans=0; while(n!=0)&#123; n&amp;=(n-1); ans++; &#125; return ans; &#125;&#125; 题目十二 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 思路就是简单地整数次方，但是要考虑正负数和0。 AC代码c++版： 12345678910111213141516171819class Solution &#123;public: double Power(double a, int b) &#123; double ans = 1.0; if (b &gt; 0) &#123; for (int i = 1; i &lt;= b; i++) &#123; ans = ans * a; &#125; &#125; else if (b &lt; 0) &#123; b = -b; for (int i = 1; i &lt;= b; i++) &#123; ans = ans / a; &#125; &#125; else &#123; return 1.0; &#125; return ans; &#125;&#125;; Java版： 1234567891011121314151617181920public class Solution &#123; public double Power(double a, int b) &#123; double ans = 1.0; if (b &gt; 0) &#123; for (int i = 1; i &lt;= b; i++) &#123; System.out.println(ans); ans = ans * a; &#125; &#125; else if (b &lt; 0) &#123; b = -b; for (int i = 1; i &lt;= b; i++) &#123; ans = ans / a; //System.out.println(ans); &#125; &#125; else &#123; return 1.0; &#125; return ans; &#125;&#125; 题目十三 调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路两种做法： c++用空间换时间，直接把所有的值存到两个数组里面然后重新按顺序填一下就好了很简单。 Java就是用两个变量标注奇数和偶数的位置i标示奇数，j表示偶数，当出现i和j不同的时候就把所有的奇数往前移保证奇数都在前面然后把这个偶数放在这个位置，然后继续往前找。可以画图理解一下。 AC代码c++版： 1234567891011121314151617181920class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; vector&lt;int&gt; t1,t2; int i,j; for(i=0;i&lt;array.size();i++)&#123; if(array[i]%2!=0)&#123; t1.push_back(array[i]); &#125;else&#123; t2.push_back(array[i]); &#125; &#125; for(i=0;i&lt;t1.size();i++)&#123; array[i]=t1[i]; &#125; for(j=0;j&lt;t2.size()&amp;&amp;i&lt;array.size();j++,i++)&#123; array[i]=t2[j]; &#125; &#125;&#125;; Java版： 1234567891011121314151617181920public class Solution &#123; public void reOrderArray(int[] array) &#123; int j = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] % 2 == 1) &#123; //如果是奇数的话 if (i != j) &#123; int temp = array[i]; int k = i; for (k = i; k &gt; j; k--) &#123; array[k] = array[k - 1]; &#125; array[k] = temp; &#125; j++; &#125; &#125; &#125;&#125; 题目十四 链表中倒数第k个结点题目描述输入一个链表，输出该链表中倒数第k个结点。 思路解题思路就和给你一个有环的链表让你找入口，我们选择用两个指针，两个一个走快一点一个走慢一点然后它必会重合就是那个入口，这个也一样，这里使用两个指针实现一次遍历，第一个指针先走k-1步，第二个指针一直不动；然后两个指针同时移动，知道第一个指针遍历完成。因为两个指针间隔为k-1，所以第二个指针指向的节点即为倒数第k个节点。 同样的题还有求链表的中间节点，我们也可以定义两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针一次走两步。当走得快的指针走到链表的末尾时，走得慢的指针正好在链表的中间。 AC代码c++版： 1234567891011121314151617181920212223242526/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; ListNode* p=pListHead; ListNode* q=pListHead; int i=0; for(;p!=NULL;i++) &#123; if(i&gt;=k) q=q-&gt;next; p=p-&gt;next; &#125; if(i&lt;k) return NULL; else return q; &#125;&#125;; Java版： 1234567891011121314151617181920212223242526/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode p=head; ListNode q=head; int i=0; for(;p!=null;i++) &#123; if(i&gt;=k) q=q.next; p=p.next; &#125; if(i&lt;k) return null; else return q; &#125;&#125; 题目十五 反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 思路两种思路一个是递归，一个是遍历。分别用c++和Java写的。 递归：我们使其先走到链表的末尾，确保每次回溯时都返回最后一个节点的指针。同时从倒数第二个结点开始反序。head.next.next = head;是指使当前节点的下一个节点指向自己head.next = null断开与下一个节点的联系，完成真正的反序操作。 遍历： 一遍遍历，保存三个指针，pre，now，aft，用aft保存下一个节点，防止链表断开后，无法继续后移然后每次now的next指向pre实现反序，然后now和pre同时后移一步即可，直到now指向空为止，说明链表已完成反序操作。 AC代码c++版： 1234567891011121314151617181920/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; if(pHead == NULL || pHead-&gt;next == NULL)&#123; return pHead; &#125; ListNode *reverseHead = ReverseList(pHead-&gt;next); pHead-&gt;next-&gt;next = pHead; pHead-&gt;next = NULL; return reverseHead; &#125;&#125;; Java版： 1234567891011121314151617181920212223/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode pre = null; ListNode now = head; ListNode aft = null; while(now != null)&#123; aft = now.next; now.next=pre; pre = now; now = aft; &#125; return pre; &#125;&#125; 题目十六 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路同上两种思路一个是递归，一个是遍历。分别用Java和c++写的。 递归：新建个链表，每次两个链表当中选一个小值复制过去，那么现在是不是就是合并两个链表（其中有一个已经赋值过去了，就是之前的.next，然后递归就可以了。 遍历： 新建一个链表，我们先把第一个值复制过去，然后当两个链表都存在的时候，谁值小就把谁链接到新链表后面然后后移一个，直到两个当中某一个为空了，最后把两个链表剩余的直接链接上去就可以了。 AC代码c++版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* p1, ListNode* p2)&#123; if(p1 == NULL) return p2; if(p2 == NULL) return p1; ListNode *ans = new ListNode(0); ListNode *temp = NULL; if(p1-&gt;val &lt;= p2-&gt;val)&#123; ans-&gt;next = p1; p1 = p1-&gt;next; &#125;else&#123; ans-&gt;next = p2; p2 = p2-&gt;next; &#125; temp = ans-&gt;next; while(p1 != NULL &amp;&amp; p2 != NULL)&#123; if(p1-&gt;val &lt;= p2-&gt;val)&#123; temp-&gt;next = p1; temp = p1; p1 = p1-&gt;next; &#125;else&#123; temp-&gt;next = p2; temp = p2; p2 = p2-&gt;next; &#125; &#125; if(p1 != NULL)&#123; temp-&gt;next = p1; &#125; if(p2 != NULL)&#123; temp-&gt;next = p2; &#125; return ans-&gt;next; &#125;&#125;; Java版： 12345678910111213141516171819202122232425/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode l1,ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; ListNode head = null; if (l1.val &lt;= l2.val)&#123; head = l1; head.next = Merge(l1.next, l2); &#125; else &#123; head = l2; head.next = Merge(l1, l2.next); &#125; return head; &#125;&#125; 题目十八 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像 思路递归。 先把特殊情况去了，然后对于每个节点，把左右节点调换一下，然后子节点递归调用即可。 递归：新建个链表，每次两个链表当中选一个小值复制过去，那么现在是不是就是合并两个链表（其中有一个已经赋值过去了，就是之前的.next，然后递归就可以了。 遍历： 新建一个链表，我们先把第一个值复制过去，然后当两个链表都存在的时候，谁值小就把谁链接到新链表后面然后后移一个，直到两个当中某一个为空了，最后把两个链表剩余的直接链接上去就可以了。 AC代码c++版： 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if((pRoot==NULL) || (pRoot-&gt;left == NULL &amp;&amp; pRoot-&gt;right == NULL))&#123; return ; &#125; TreeNode *temp = NULL; temp = pRoot-&gt;right; pRoot-&gt;right = pRoot-&gt;left; pRoot-&gt;left = temp; if(pRoot-&gt;left)&#123; Mirror(pRoot-&gt;left); &#125; if(pRoot-&gt;right)&#123; Mirror(pRoot-&gt;right); &#125; &#125;&#125;; Java版： 123456789101112131415161718192021222324252627282930/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode pRoot) &#123; if((pRoot == null) || (pRoot.left == null &amp;&amp; pRoot.right == null))&#123; return ; &#125; TreeNode temp = null; temp = pRoot.right; pRoot.right = pRoot.left; pRoot.left = temp; if(pRoot.left != null)&#123; Mirror(pRoot.left); &#125; if(pRoot.right != null)&#123; Mirror(pRoot.right); &#125; &#125;&#125; 题目十九 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 思路画下图就知道，因为每次起点都是在（a,a）点，所以保证每次n &gt; flag\*2 &amp;&amp; m &gt; flag\*2，然后就是四次循环跑就可以了。 AC代码c++版： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; int n = matrix.size(); vector&lt;int&gt; ans; if(n == 0) &#123; return ans; &#125; int m = matrix[0].size(); int flag = 0; while(n &gt; flag*2 &amp;&amp; m &gt; flag*2) &#123; int endX = m-flag-1; int endY = n-flag-1; for(int i=flag;i&lt;=endX;i++) &#123; ans.push_back(matrix[flag][i]); &#125; if(flag &lt; endY) &#123; for (int i=flag+1;i&lt;=endY;i++) &#123; ans.push_back(matrix[i][endX]); &#125; &#125; if(flag &lt; endX &amp;&amp; flag &lt; endY) &#123; for (int i=endX-1;i&gt;=flag;i--) &#123; ans.push_back(matrix[endY][i]); &#125; &#125; if(flag &lt; endX &amp;&amp; flag &lt; endY-1) &#123; for (int i=endY-1;i&gt;=flag+1;i--) &#123; ans.push_back(matrix[i][flag]); &#125; &#125; flag++; &#125; return ans; &#125;&#125;; Java版： 123456789101112131415161718192021222324252627282930313233343536import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; int n = matrix.length; ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); if(n == 0) &#123; return ans; &#125; int m = matrix[0].length; int flag = 0; while(n &gt; flag*2 &amp;&amp; m &gt; flag*2) &#123; int endX = m-flag-1; int endY = n-flag-1; for(int i=flag;i&lt;=endX;i++) &#123; ans.add(matrix[flag][i]); &#125; if(flag &lt; endY) &#123; for (int i=flag+1;i&lt;=endY;i++) &#123; ans.add(matrix[i][endX]); &#125; &#125; if(flag &lt; endX &amp;&amp; flag &lt; endY) &#123; for (int i=endX-1;i&gt;=flag;i--) &#123; ans.add(matrix[endY][i]); &#125; &#125; if(flag &lt; endX &amp;&amp; flag &lt; endY-1) &#123; for (int i=endY-1;i&gt;=flag+1;i--) &#123; ans.add(matrix[i][flag]); &#125; &#125; flag++; &#125; return ans; &#125;&#125; 题目二十 包含min函数的栈题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 思路两个栈维护，一个维护正常的栈元素，一个维护min值栈， 那什么时候放到min值栈呢？ 第一个是min值栈为空必须要放 第二个就是我现在放进来的值比我所有的元素值也就是min值栈的首元素。 当然了在pop的时候如果把最小值pop了，min值栈也要进行对应的pop操作 先把特殊情况去了，然后对于每个节点，把左右节点调换一下，然后子节点递归调用即可。 AC代码c++版： 1234567891011121314151617181920212223class Solution &#123;public: stack&lt;int&gt;s1;//存储元素 stack&lt;int&gt;s2;//存储最小值 void push(int value) &#123; s1.push(value); if(s2.empty()) s2.push(value); else if(value &lt; s2.top()) s2.push(value); &#125; void pop() &#123; if(s1.top() == s2.top()) s2.pop(); s1.pop(); &#125; int top() &#123; return s1.top(); &#125; int min() &#123; return s2.top(); &#125;&#125;; Java版： 12345678910111213141516171819202122232425262728import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; s1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; s2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; s1.push(node); if(s2.empty()) s2.push(node); else if(node &lt; s2.peek()) s2.push(node); &#125; public void pop() &#123; if(s1.peek() == s2.peek()) s2.pop(); s1.pop(); &#125; public int top() &#123; return s1.peek(); &#125; public int min() &#123; return s2.peek(); &#125;&#125; 题目二十一 栈的压入、弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路这个比较简单，就是模拟一次就行，按放进的顺序往里放元素，然后碰到出栈元素就执行pop，注意这里一个while循环，因为可能pop了下一个还是出栈元素 ，到最后看这个栈是不是空的就行了。 那什么时候放到min值栈呢？ 第一个是min值栈为空必须要放 第二个就是我现在放进来的值比我所有的元素值也就是min值栈的首元素。 当然了在pop的时候如果把最小值pop了，min值栈也要进行对应的pop操作 先把特殊情况去了，然后对于每个节点，把左右节点调换一下，然后子节点递归调用即可。 AC代码c++版： 1234567891011121314151617181920212223class Solution &#123;public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; stack&lt;int&gt; s; int len1 = pushV.size(); int len2 = popV.size(); int i = 0; int j = 0; while(i &lt; len1 &amp;&amp; j &lt; len2) &#123; s.push(pushV[i]); i++; while(!s.empty() &amp;&amp; s.top() == popV[j]) &#123; s.pop(); j++; &#125; &#125; if(s.empty()) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;; Java版： 123456789101112131415161718192021222324import java.util.Stack;public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; Stack&lt;Integer&gt; s = new Stack(); int len1 = pushA.length; int len2 = popA.length; int i = 0; int j = 0; while(i &lt; len1 &amp;&amp; j &lt; len2) &#123; s.push(pushA[i]); i++; while(!s.empty() &amp;&amp; s.peek() == popA[j]) &#123; s.pop(); j++; &#125; &#125; if(s.empty()) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 题目二十二 从上往下打印二叉树题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路二叉树的层次遍历 AC代码c++版： 1234567891011121314151617181920212223242526272829/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; vector&lt;int&gt; ans; queue&lt;TreeNode*&gt; q; if(root ==NULL) return ans; q.push(root); while(!q.empty())&#123; TreeNode* tempNode = q.front(); q.pop(); ans.push_back(tempNode-&gt;val); if (tempNode-&gt;left!=NULL) q.push(tempNode-&gt;left); if (tempNode-&gt;right!=NULL) q.push(tempNode-&gt;right); &#125; return ans; &#125;&#125;; Java版： 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Queue;import java.util.LinkedList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); Queue&lt;TreeNode&gt; myQueue = new LinkedList&lt;&gt;(); if(root == null) return ans; myQueue.offer(root); while(!myQueue.isEmpty())&#123; TreeNode tempNode = myQueue.poll(); ans.add(tempNode.val); if (tempNode.left!=null) myQueue.offer(tempNode.left); if (tempNode.right!=null) myQueue.offer(tempNode.right); &#125; return ans; &#125;&#125; 题目二十三 二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路如果一个数组是一个二叉搜索树的后序遍历结果，那么这个数组有以下特征：数组的最后一个元素是（子）树的根节点，前面的部分可以分为两个部分，前一部分的元素都小于最后一个元素值，后一部分都大于数组最后一个元素值，我们首先需要找到这个临界值，在判断前一部分的元素是否都小于数组末尾的值，接着分别对数组前两部分处理，（递归定义）。 AC代码c++版： 1234567891011121314151617181920212223242526class Solution &#123; bool judge(vector&lt;int&gt; &amp;sequence, int l, int r) &#123; if (l &gt;= r) &#123; return true; &#125; int i = r - 1; while (i &gt;= l &amp;&amp; sequence[i] &gt; sequence[r]) &#123; i--; &#125; for (int j = i; j &gt;= l; j--) &#123; if (sequence[j] &gt; sequence[r]) &#123; return false; &#125; &#125; return judge(sequence, l, i) &amp;&amp; judge(sequence, i + 1, r - 1); &#125;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; int len = sequence.size(); if (len == 0) &#123; return false; &#125; else &#123; return judge(sequence, 0, len - 1); &#125; &#125;&#125;; Java版： 1234567891011121314151617181920212223242526public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if (sequence == null || sequence.length &lt;= 0) &#123; return false; &#125; return verifySequenceOfBST(sequence, 0, sequence.length - 1); &#125; public static boolean verifySequenceOfBST(int[] sequence, int start, int end) &#123; if (start &gt;= end) &#123; return true; &#125; int index = start; while (index &lt; end - 1 &amp;&amp; sequence[index] &lt; sequence[end]) &#123; index++; &#125; int right = index; while (index &lt; end - 1 &amp;&amp; sequence[index] &gt; sequence[end]) &#123; index++; &#125; if (index != end - 1) &#123; return false; &#125; index = right; return verifySequenceOfBST(sequence, start, index - 1) &amp;&amp; verifySequenceOfBST(sequence, index, end - 1); &#125;&#125; 题目二十四 二叉树中和为某一值的路径题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 思路首先我们知道这题肯定要用dfs，当一次遍历完成后，如果输入整数值恰好等于节点值之和，则输出这条路径并且回退一个节点；如果不等于则直接回退一个节点，即回退到当前节点的父节点，如果该父节点有右孩子，则继续遍历，否则继续回退。考虑回退到根节点，此时如果它有右孩子，则继续遍历，否则整个DFS结束。需要注意的是不论路径的值是否等于输入整数值，都要回退，也就是使用remove函数移除路径上的最后一个节点。 AC代码c++版： 123456789101112131415161718192021222324252627282930313233/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt;result; vector&lt;int&gt; ans; void dfs(TreeNode* root,int expectNumber) &#123; ans.push_back(root-&gt;val); if(root-&gt;val == expectNumber &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123; result.push_back(ans); &#125; else &#123; if(root-&gt;left) dfs(root-&gt;left, expectNumber-root-&gt;val); if(root-&gt;right) dfs(root-&gt;right, expectNumber-root-&gt;val); &#125; ans.pop_back(); &#125; vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123; if(root != NULL)&#123; dfs(root, expectNumber); &#125; return result; &#125;&#125;; Java版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();; ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();; /*public dfs(TreeNode root,int expectNumber) &#123; ans.add(root.val); if(root.val == expectNumber &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123; result.add(ans); &#125; else &#123; if(root.left != null) dfs(root.left, expectNumber-root.val); if(root.right != null) dfs(root.right, expectNumber-root.val); &#125; ans.remove(ans.size()-1); &#125;*/ public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root != null)&#123; ans.add(root.val); if(root.val == target &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123; result.add(new ArrayList&lt;Integer&gt;(ans)); &#125; else &#123; if(root.left != null) FindPath(root.left, target-root.val); if(root.right != null) FindPath(root.right, target-root.val); &#125; ans.remove(ans.size()-1); &#125; return result; &#125;&#125; # 题目二十八 数组中出现次数超过一半的数字题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路有两种想法，一次遍历找到出现次数最多的那个数字，再遍历一下找到这个数出现的次数看是否满足。 或者一次遍历，用map存储对应的数字出现的次数，然后判断这个值是否满足题意。 AC代码c++版： 1234567891011121314151617181920212223242526272829/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; vector&lt;int&gt; ans; queue&lt;TreeNode*&gt; q; if(root ==NULL) return ans; q.push(root); while(!q.empty())&#123; TreeNode* tempNode = q.front(); q.pop(); ans.push_back(tempNode-&gt;val); if (tempNode-&gt;left!=NULL) q.push(tempNode-&gt;left); if (tempNode-&gt;right!=NULL) q.push(tempNode-&gt;right); &#125; return ans; &#125;&#125;; Java版： 1234567891011121314151617181920212223import java.util.HashMap;public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if (array == null || array.length == 0) return 0; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int count; int len = array.length; for (int i = 0;i &lt; len;i++) &#123; if (!map.containsKey(array[i])) &#123; map.put(array[i], 1); &#125; else &#123; count = map.get(array[i]); map.put(array[i], ++count); &#125; if (map.get(array[i]) &gt; array.length / 2) &#123; return array[i]; &#125; &#125; return 0; &#125;&#125; 题目二十九 最小的K个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 思路有两种想法，直接sort一遍，取前k个数即可。 或者呢可以用冒泡排序的思想，我么知道冒泡排序是一个O(n^2)的算法，它是每次把一个数排序到最前面保证前面数有序，然后一直到整个数组有序，那么我们只需要循环k次就行了在这里面，保证前k个数最小的就满足题意了。 AC代码c++版： 123456789101112131415class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt; v; if(k&lt;=0 || input.size()&lt;=0 || k&gt;input.size()) return v; sort(input.begin(), input.end()); int i = 0; while(i &lt; k) &#123; v.push_back(input[i]); i++; &#125; return v; &#125;&#125;; Java版： 12345678910111213141516171819202122import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; if(input == null) return null; ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); if(k &gt; input.length) return ans; int temp; for(int i = 0; i &lt; k; i++)&#123; for(int j = i + 1; j &lt; input.length; j++)&#123; if(input[i] &gt; input[j])&#123; temp = input[i]; input[i] = input[j]; input[j] = temp; &#125; &#125; ans.add(input[i]); &#125; return ans; &#125;&#125; 题目三十 连续子数组的最大和题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 思路可以用递归去做，可以看我的LeetCode字节跳动专题有一样的。 这个是O(n)的解法，思路是对于一个数组中的一个数x，若是x的左边的数加起来非负，那么加上x能使得值变大，这样我们认为x之前的数的和对整体和是有贡献的。如果前几项加起来是负数，则认为有害于总和。我们用cur记录当前值, 用max记录最大值，如果cur&lt;0,则舍弃之前的数，让cur等于当前的数字，否则，cur = cur+当前的数字。若cur和大于max更新max。 AC代码c++版： 1234567891011121314class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if(array.size() == 0) return 0; int cur = array[0], max = array[0]; for(int i=1; i&lt;array.size(); i++)&#123; cur = cur &gt; 0 ? cur + array[i] : array[i]; if(max &lt; cur) max = cur; &#125; return max; &#125;&#125;; Java版： 12345678910111213public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; if(array.length == 0) return 0; int cur = array[0], max = array[0]; for(int i=1; i&lt;array.length; i++)&#123; cur = cur &gt; 0 ? cur + array[i] : array[i]; if(max &lt; cur) max = cur; &#125; return max; &#125;&#125; 题目三十一 整数中1出现的次数（从1到n整数中1出现的次数）题目描述求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 思路暴力循环一下，对于每个数都判断一下，应该有更好的解法，暂时没想到。 AC代码c++版： 12345678910111213141516class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n)&#123; int count = 0; for(int i=0; i&lt;=n; i++)&#123; int temp = i; while(temp != 0)&#123; if(temp%10 == 1)&#123; count++; &#125; temp /= 10; &#125; &#125; return count; &#125;&#125;; Java版： 123456789101112131415public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; for(int i=0; i&lt;=n; i++)&#123; int temp = i; while(temp != 0)&#123; if(temp%10 == 1)&#123; count++; &#125; temp /= 10; &#125; &#125; return count; &#125;&#125; 题目三十三 丑数题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路某个丑数肯定是前面丑数的2,3,5倍数。只需要从前往后生成即可。 AC代码c++版： 123456789101112131415161718192021222324252627class Solution &#123;public: int min(int a,int b,int c)&#123; int minn=(a&lt;b)?a:b; return (minn&lt;c)?minn:c; &#125; int GetUglyNumber_Solution(int index) &#123; if(index&lt;=0) return 0; int a[index]; a[0]=1; int cnt1=0; int cnt2=0; int cnt3=0; for(int i=1;i&lt;index;i++)&#123; int minn=min(a[cnt1]*2,a[cnt2]*3,a[cnt3]*5); a[i]=minn; while(a[cnt1]*2&lt;=minn) cnt1++; while(a[cnt2]*3&lt;=minn) cnt2++; while(a[cnt3]*5&lt;=minn) cnt3++; &#125; return a[index-1]; &#125;&#125;; Java版： 1234567891011121314151617181920212223242526public class Solution &#123; public int min(int a,int b,int c)&#123; int min=(a&lt;b)?a:b; return (min&lt;c)?min:c; &#125; public int GetUglyNumber_Solution(int index) &#123; if(index&lt;=0) return 0; int[] a=new int[index]; a[0]=1; int cnt1=0; int cnt2=0; int cnt3=0; for(int i=1;i&lt;index;i++)&#123; int min=min(a[cnt1]*2,a[cnt2]*3,a[cnt3]*5); a[i]=min; while(a[cnt1]*2&lt;=min) cnt1++; while(a[cnt2]*3&lt;=min) cnt2++; while(a[cnt3]*5&lt;=min) cnt3++; &#125; return a[index-1]; &#125;&#125; 题目三十四 第一个只出现一次的字符题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 思路设立一个hashMap，将每个字母出现的次数进行统计。若要找出第一个，就要对string从头开始再次遍历一遍找到其在hashMap中的value值为1，则返回其下标 AC代码c++版： 12 Java版： 123456789101112131415161718192021222324252627282930import java.util.HashMap; public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; int index = -1; if (str == null || str == "") &#123; return index; &#125; HashMap&lt;Character, Integer&gt; statisticsMap = new HashMap&lt;Character, Integer&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; Character tempChar = str.charAt(i); if (statisticsMap.get(tempChar) == null) &#123; statisticsMap.put(tempChar, 1); &#125; else &#123; int tempCount = statisticsMap.get(tempChar) + 1; statisticsMap.remove(tempChar); statisticsMap.put(tempChar, tempCount); &#125; &#125; for (int i = 0; i &lt; str.length(); i++) &#123; Character tempChar1 = str.charAt(i); if (statisticsMap.get(tempChar1) == 1) &#123; index = i; break; &#125; &#125; return index; &#125; &#125; 题目三十五 数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 思路利用归并排序或者树状数组，暂时写了个Java的。 AC代码c++版： 12 Java版： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public int InversePairs(int [] array) &#123; int len = array.length; if(array== null || len &lt;= 0)&#123; return 0; &#125; return mergeSort(array, 0, len-1); &#125; public int mergeSort(int [] array, int start, int end)&#123; if(start == end) return 0; int mid = (start + end) / 2; int left_count = mergeSort(array, start, mid); int right_count = mergeSort(array, mid + 1, end); int i = mid, j = end; int [] copy = new int[end - start + 1]; int copy_index = end - start; int count = 0; while(i &gt;= start &amp;&amp; j &gt;= mid + 1)&#123; if(array[i] &gt; array[j])&#123; copy[copy_index--] = array[i--]; count += j - mid; if(count &gt; 1000000007)&#123; count %= 1000000007; &#125; &#125;else&#123; copy[copy_index--] = array[j--]; &#125; &#125; while(i &gt;= start)&#123; copy[copy_index--] = array[i--]; &#125; while(j &gt;= mid + 1)&#123; copy[copy_index--] = array[j--]; &#125; i = 0; while(start &lt;= end) &#123; array[start++] = copy[i++]; &#125; return (left_count+right_count+count)%1000000007; &#125;&#125; 题目三十六 两个链表的第一个公共结点题目描述输入两个链表，找出它们的第一个公共结点。 思路一个while循环，当不是共同结点的时候，两个链表都往后面移动 AC代码c++版： 12345678910111213141516171819202122232425262728/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindFirstCommonNode( ListNode* headA, ListNode* headB) &#123; if(headA==NULL || headB==NULL) return NULL; ListNode *ans1=headA,*ans2=headB; while(ans1!=ans2) &#123; if(ans1==NULL) ans1=headB; else ans1=ans1-&gt;next; if(ans2==NULL) ans2=headA; else ans2=ans2-&gt;next; &#125; return ans1; &#125;&#125;; Java版： 12345678910111213141516171819202122232425262728/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindFirstCommonNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; ListNode ans1=headA,ans2=headB; while(ans1!=ans2) &#123; if(ans1==null) ans1=headB; else ans1=ans1.next; if(ans2==null) ans2=headA; else ans2=ans2.next; &#125; return ans1; &#125;&#125; 题目三十七 数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。 思路一遍循环，因为是有序的数组，所以一直找到第一个大于k的数值就跳出循环，==的时候记录数量 AC代码c++版： 123456789101112131415class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; int len=data.size(); int ans=0; for(int i=0;i&lt;len;i++)&#123; if(data[i]==k)&#123; ans++; &#125; if(data[i]&gt;k) break; &#125; return ans; &#125;&#125;; Java版： 1234567891011121314public class Solution &#123; public int GetNumberOfK(int [] array , int k) &#123; int len=array.length; int ans=0; for(int i=0;i&lt;len;i++)&#123; if(array[i]==k)&#123; ans++; &#125; if(array[i]&gt;k) break; &#125; return ans; &#125;&#125; 题目三十八 二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路如果一棵树只有一个结点，它的深度为1，如果根节点只有左子树而没有右子树，那么树的深度应该是其左子树的深度+1.同样如果根节点只有右子树而没有左子树，那么树的深度应该是其右子树+1.如果既有左子树又有右子树，那概述的深度就是左、右子树的深度的较大值加1.。 所以我们可以用递归来实现代码 AC代码c++版： 123456789101112131415161718192021222324252627282930/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int ans=0; void dfs(TreeNode* root,int height)&#123; if(root-&gt;left)&#123; dfs(root-&gt;left,height+1); &#125; if(root-&gt;right)&#123; dfs(root-&gt;right,height+1); &#125; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)&#123; ans=max(ans,height); &#125; &#125; int TreeDepth(TreeNode* pRoot)&#123; if(pRoot == NULL) return 0; dfs(pRoot,1); return ans; &#125;&#125;; Java版： 1234567891011121314151617181920212223/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root == null) return 0; int nLeft = TreeDepth(root.left); int nRight = TreeDepth(root.right); return (nLeft &gt; nRight)?(nLeft+1):(nRight+1); &#125;&#125; 题目三十九 平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路首先如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 而我们已经做了二叉树的深度，遍历树的每个结点的时候，调用函数TreeDepth得到它的左右子树的深度。如果每个结点的左右子树的深度相差不超过1，按照定义它就是一棵平衡的二叉树 或者呢可以用冒泡排序的思想，我么知道冒泡排序是一个O(n^2)的算法，它是每次把一个数排序到最前面保证前面数有序，然后一直到整个数组有序，那么我们只需要循环k次就行了在这里面，保证前k个数最小的就满足题意了。 AC代码c++版： 123456789101112131415161718192021class Solution &#123;public: int depth(TreeNode* root)&#123; if(root==NULL) return 0; int left=depth(root-&gt;left); int right=depth(root-&gt;right); return (left&gt;right)?(left+1):(right+1); &#125; bool IsBalanced_Solution(TreeNode* root) &#123; if(root==NULL) return true; int left=depth(root-&gt;left); int right=depth(root-&gt;right); if(abs(left-right)&gt;1) return false; bool booleft=IsBalanced_Solution(root-&gt;left); bool booright=IsBalanced_Solution(root-&gt;right); return booleft&amp;&amp;booright; &#125;&#125;; Java版： 12345678910111213141516171819public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; if(root ==null) return true; int left = TreeDepth(root.leftNode); int right = TreeDepth(root.rightNode); int diff = left - right; if(diff &gt; 1 || diff &lt;-1) return false; return isBalanced(root.leftNode) &amp;&amp; isBalanced(root.rightNode); &#125; public int TreeDepth(TreeNode root) &#123; if(root == null) return 0; int nLeft = TreeDepth(root.left); int nRight = TreeDepth(root.right); return (nLeft &gt; nRight)?(nLeft+1):(nRight+1); &#125;&#125; 题目四十 数组中只出现一次的数字题目描述一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路首先是异或运算的一个性质：任何一个数字异或它自己都等于 0。也就是说， 如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些成对出现两次的数字全部在异或中抵消了，同样应用这个思路，分为三步： 从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于这两个数字肯定不一样，那么异或的结果肯定不为 0，也就是说在这个结果数字的二进制表示中至少就有一位为 1 。 我们在结果数字中找到第一个为 1 的位的位置，记为第 n 位。现在我们以第 n 位是不是 １ 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第 n 位都是 1，而第二个子数组中每个数字的第 n 位都是 0。由于我们分组的标准是数字中的某一位是 1 还是 0 ， 那么出现了两次的数字肯定被分配到同一个子数组。因为两个相同的数字的任意一位都是相同的，我们不可能把两个相同的数字分配到两个子数组中去，于是我们已经把原数组分成了两个子数组。 每个子数组都包含一个只出现一次的数字，而其他数字都出现了两次。我们已经知道如何在数组中找出唯一一个只出现一次数字 AC代码c++版： 123456789101112131415161718192021222324252627class Solution &#123;public: bool IsBit(int num,int index)&#123; num=num&gt;&gt;index; return (num&amp;1); &#125; void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int size=data.size(); int temp=data[0]; for(int i=1;i&lt;size;i++) temp=temp^data[i]; if(temp==0) return ; int index=0; while((temp&amp;1)==0)&#123; temp=temp&gt;&gt;1; ++index; &#125; *num1=*num2=0; for(int i=0;i&lt;size;i++)&#123; if(IsBit(data[i],index)) *num1^=data[i]; else *num2^=data[i]; &#125; &#125;&#125;; Java版： 1234567891011121314//num1,num2分别为长度为1的数组。传出参数//将num1[0],num2[0]设置为返回结果public class Solution &#123; public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) &#123; int diff = 0; for (int num : array) diff ^= num; // 得到最右一位 diff &amp;= -diff; for (int num : array) &#123; if ((num &amp; diff) == 0) num1[0] ^= num; else num2[0] ^= num; &#125; &#125;&#125; 题目四十一 和为S的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 思路窗口的思想，窗口里面的值加起来与我们的目标值进行对比，如果小了就让窗口右边界右移使得值变大，如果比我们的目标值大就使得窗口左边界右移使得值变小，如果刚好相等的话就把这个序列放到我们的答案序列里面。 AC代码c++版： 12 Java版： 123456789101112131415161718192021222324252627282930313233343536import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resultsList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if(sum &lt; 3)&#123; return resultsList; &#125; int startIndex = 1; int endIndex = 2; int mid = (sum + 1)/2; int cursum = startIndex + endIndex ; while(startIndex &lt; mid) &#123; /*如果起始值就大于目标值一半，那么这个窗口里的值一定比目标值要大*/ while(cursum &gt; sum &amp;&amp; startIndex &lt; mid) &#123; cursum = cursum-startIndex; startIndex ++; &#125; if(cursum == sum) &#123; ArrayList&lt;Integer&gt; listsum = new ArrayList&lt;Integer&gt;(); add(listsum,startIndex ,endIndex ); resultsList .add(listsum); &#125; endIndex ++; cursum = cursum+endIndex ; &#125; return resultsList ; &#125; private static void add(ArrayList&lt;Integer&gt; list,int small,int big) &#123; for (int i = small; i &lt;= big; i++) &#123; list.add(i); &#125; &#125;&#125; 题目四十二 和为S的两个数字题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 思路暴力的想法：先选定第一个数字，然后将后面的数字依次遍历求和，并与需要的数字比较，需要n－1次，如果第一个数字不行，选择第二个，依次遍历求和。。。。需要n^2次，时间复杂度比较高 同样的窗口的思想：第一个指向第一个元素，第二个指向最后一个元素； 先拿第一个元素和最后一个元素相加，与要求的数字进行比较；如果等于，恭喜找到了；如果大于，则将第二个指针向后移一位（索引值－1），再求和进行比较；如果小于，则将第一个指针向前移一位（索引值＋1），在进行求和比较；直至找到结果。 AC代码c++版： 12 Java版： 123456789101112131415161718192021222324252627import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (array.length &lt; 2 || array == null) &#123; return list; &#125; int len = array.length; int start = 0; int end = len - 1; while (start &lt; end &amp;&amp; start &lt; len - 1 &amp;&amp; end &gt; 0) &#123; if (array[start] + array[end] == sum) &#123; list.add(array[start]); list.add(array[end]); return list; &#125; if (array[start] + array[end] &gt; sum) &#123; end--; &#125; if (array[start] + array[end] &lt; sum) &#123; start++; &#125; &#125; return list; &#125;&#125; 题目四十三 左旋转字符串题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 思路就是一个取余的想法，还有一种就是先把它加上一段然后截取我们需要的那节。 AC代码c++版： 12345678910111213class Solution &#123;public: string LeftRotateString(string str, int n) &#123; int len = str.size(); string result; if(len &lt; 1) return result; n %= len; result = str.substr(n, len - n); result += str.substr(0,n); return result; &#125;&#125;; Java版： 123456789101112131415public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(str==null||str.length()==0)&#123; return ""; &#125; StringBuffer strBuffer = new StringBuffer(); for(int i=n; i&lt;str.length(); i++)&#123; strBuffer.append(str.charAt(i)); &#125; for(int i=0; i&lt;n; i++)&#123; strBuffer.append(str.charAt(i)); &#125; return strBuffer.toString(); &#125;&#125; 题目四十四 翻转单词顺序列题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路利用StringBuilder，然后倒序遍历。 也可以利用stack的性质，我们先遍历然后放到stack里面，然后再取出来。 AC代码c++版： 12 Java版： 123456789101112131415public class Solution &#123; public String ReverseSentence(String str) &#123; if(str == null || str.trim().equals("")) return str; String [] strs = str.split(" "); StringBuilder stb = new StringBuilder(); for(int i = strs.length - 1; i &gt;= 0; i--)&#123; stb.append(strs[i]); if(i != 0)&#123; stb.append(" "); &#125; &#125; return stb.toString(); &#125;&#125; 题目四十五 扑克牌顺子题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 思路我们根据0的个数，我们先给序列排个序，然后除了0，我们会得到一个序列，我们从头遍历，我们计算相邻两个数的差值这个区间缺的数我们就用0来代替，直到最后如果区间缺的值小于0的个数就可以成为一个So Lucky! AC代码c++版： 12 Java版： 12345678910111213141516171819202122232425import java.util.Arrays;public class Solution &#123; public static boolean isContinuous(int[] numbers) &#123; if (numbers == null || numbers.length != 5) &#123; return false; &#125; Arrays.sort(numbers); int numberOfZero = 0; int numberOfGap = 0; for (int i = 0; i &lt; numbers.length &amp;&amp; numbers[i] == 0; i++) &#123; numberOfZero++; &#125; int small = numberOfZero; int big = small + 1; while (big &lt; numbers.length) &#123; if (numbers[small] == numbers[big]) &#123; return false; &#125; numberOfGap += (numbers[big] - numbers[small] - 1); small = big; big++; &#125; return numberOfGap &lt;= numberOfZero; &#125;&#125; 题目四十六 孩子们的游戏(圆圈中最后剩下的数)题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 思路约瑟夫环：约瑟夫环（约瑟夫问题）是一个数学的应用问题：已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。通常解决这类问题时我们把编号从0~n-1，最后 [1] 结果+1即为原问题的解。 AC代码c++版： 1234567891011class Solution &#123;public: int LastRemaining_Solution(int n, int m)&#123; if (n &lt;= 0 || m &lt;= 0) return -1; int ans = 0; for (int i = 2; i &lt;= n; i++) &#123; ans = (ans + m) % i; &#125; return ans; &#125;&#125;; Java版： 12345678910public class Solution &#123; public int LastRemaining_Solution(int n, int m) &#123; if (n &lt;= 0 || m &lt;= 0) return -1; int ans = 0; for (int i = 2; i &lt;= n; i++) &#123; ans = (ans + m) % i; &#125; return ans; &#125;&#125; 题目四十七 求1+2+3+…+n题目描述求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 思路首先是一个递归的想法，不能用那些条件的时候递归就是一个很好地思路。 其次我们知道这个我们可以算出来一个数学公式，就可以利用内置的函数去解决这个问题 AC代码c++版： 12345678class Solution &#123;public: int Sum_Solution(int n) &#123; int temp = 0; (n == 0) || (temp = Sum_Solution(n-1)); return n + temp; &#125;&#125;; Java版： 12345public class Solution &#123; public int Sum_Solution(int n) &#123; return (int)(Math.pow(n, 2) + n) &gt;&gt; 1; &#125;&#125; 题目四十八 不用加减乘除做加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 思路不能进行正常的加法的话，第二个思路就是利用移位的思想来进行我们需要的运算，具体的思想我也是百度的。 AC代码c++版： 12 Java版： 1234567891011121314public class Solution &#123; public int Add(int x,int y) &#123; int sum; int temp; do &#123; sum = x ^ y; temp = (x &amp; y) &lt;&lt; 1; x = sum; y = temp; &#125; while (y != 0); return x; &#125;&#125; 题目四十九 把字符串转换成整数题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 思路这个就是简单的转换了，注意+，-这个符号只有在开始才会出现，然后就是简单的字符串转换数字 AC代码c++版： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int StrToInt(string str) &#123; int ans = 0; int len = str.size(); if(len == 0) &#123; return 0; &#125; else &#123; int i = 0; int flag = 0; while(str[i] == ' ') i++; if(str[i] == '+')&#123; flag = 1; i++; &#125; else if(str[i] == '-') &#123; flag = -1; i++; &#125; while(str[i] != '\0') &#123; if(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') &#123; ans = ans * 10 + (str[i] - '0'); i++; &#125; else &#123; ans = 0; break; &#125; &#125; if(flag == -1) ans = -ans; return ans; &#125; &#125;&#125;; Java版： 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int StrToInt(String str) &#123; int ans = 0; int len = str.length(); if(len == 0) &#123; return 0; &#125; else &#123; int i = 0; int flag = 0; while(str.charAt(i) == ' ') i++; if(str.charAt(i) == '+')&#123; flag = 1; i++; &#125; else if(str.charAt(i) == '-') &#123; flag = -1; i++; &#125; for(;i&lt;len;i++) &#123; if(str.charAt(i) &gt;= '0' &amp;&amp; str.charAt(i) &lt;= '9') &#123; ans = ans * 10 + (str.charAt(i) - '0'); &#125; else &#123; ans = 0; break; &#125; &#125; if(flag == -1) ans = -ans; return ans; &#125; &#125;&#125; 题目五十 数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路记录一个cnt数组，如果出现了重复就赋值到duplication中就可以了，还是比较简单的。 AC代码c++版： 1234567891011121314151617181920class Solution &#123;public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int* duplication) &#123; bool k[length]; for(int i=0;i&lt;length;i++) &#123; if (k[numbers[i]] == true) &#123; *duplication = (numbers[i]-1)%length; return true; &#125; k[numbers[i]] = true; &#125; return false; &#125;&#125;; Java版： 123456789101112131415161718192021public class Solution &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; boolean[] cnt = new boolean[length]; for (int i = 0; i &lt; cnt.length; i++) &#123; if (cnt[numbers[i]] == true) &#123; duplication[0] = numbers[i]; return true; &#125; cnt[numbers[i]] = true; &#125; return false; &#125;&#125; public class Solution { public int movingCount(int threshold, int rows, int cols) { boolean[][] flag = new boolean[rows][cols]; return helper(0, 0, rows, cols, threshold, flag); } public int helper(int i, int j, int rows,int cols, int threshold, boolean[][] flag){ if(i &lt; 0 || j &lt; 0 || i &gt;= rows || j &gt;= cols || flag[i][j] || (getSum(i) + getSum(j) &gt; threshold)){ return 0; } flag[i][j] = true; return helper(i- 1, j, rows, cols, threshold, flag) + helper(i, j - 1, rows, cols, threshold, flag) + helper(i + 1, j, rows, cols, threshold, flag) + helper(i , j + 1, rows, cols, threshold, flag) + 1; } int getSum(int x){ int sum = 0; while( x != 0){ sum += (x + 10) % 10; x /= 10; } return sum; }题目五十一 构建乘积数组题目描述给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 思路AC代码c++版： 12 Java版： 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt;B(A.size()); B[0] = 1; if(A.size() == 0) return vector&lt;int&gt;(); else if(A.size()!=0)&#123; for(int i = 1;i&lt;A.size();++i)&#123; B[i] = B[i-1]*A[i-1]; &#125; int tmp = 1; for(int j = A.size()-2;j&gt;=0;j--)&#123; tmp = tmp*A[j+1]; B[j] = B[j]*tmp; &#125; &#125; return B; &#125;&#125;; 题目五十二 正则表达式匹配题目描述请实现一个函数用来匹配包括&#39;.&#39;和&#39;\*&#39;的正则表达式。模式中的字符’.’表示任意一个字符，而&#39;\*&#39;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab\*a&quot;均不匹配 思路递归思想可以看代码的注释 AC代码c++版： 123456789101112131415161718192021222324class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(str==NULL || pattern==NULL) return false; if(*str=='\0'&amp;&amp;*pattern=='\0') return true; if(*str!='\0'&amp;&amp; *pattern=='\0') return false; if(*(pattern+1)=='*')&#123; if((*str==*pattern) || (*pattern=='.'&amp;&amp;*str!='\0'))&#123; // 1 匹配一个 2 匹配多个 3 忽略星号 return match(str+1,pattern+2) || match(str+1,pattern) || match(str,pattern+2); &#125;else&#123; //忽略星号 return match(str,pattern+2); &#125; &#125; if((*str==*pattern)||(*str!='\0'&amp;&amp;*pattern=='.')) return match(str+1,pattern+1); return false; &#125;&#125;; Java版： 12 题目五十三 表示数值的字符串题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。 思路 e/E后面必须跟数字，且只能有一个e/E；不能最后一个 第一次出现的符号（+/-）要么在开头，要么紧接在e/E后面，第二次出现的符号（+/-）只能在e/E后面； 小数点只能出现一次，并且只能出现在e/E前面； 不能出现除了0~9，+/-,.,e/E以外的字符 把握这四个规则，对应每个规则进行处理就可以了。 AC代码c++版： 123456789101112131415161718192021222324class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(str==NULL || pattern==NULL) return false; if(*str=='\0'&amp;&amp;*pattern=='\0') return true; if(*str!='\0'&amp;&amp; *pattern=='\0') return false; if(*(pattern+1)=='*')&#123; if((*str==*pattern) || (*pattern=='.'&amp;&amp;*str!='\0'))&#123; // 1 匹配一个 2 匹配多个 3 忽略星号 return match(str+1,pattern+2) || match(str+1,pattern) || match(str,pattern+2); &#125;else&#123; //忽略星号 return match(str,pattern+2); &#125; &#125; if((*str==*pattern)||(*str!='\0'&amp;&amp;*pattern=='.')) return match(str+1,pattern+1); return false; &#125;&#125;; Java版： 12 题目五十四 字符流中第一个不重复的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。 思路第一种就是利用string这个内置的函数，利用find判断，第二种就是开一个cnt数组，然后遍历一遍 AC代码c++版： 12345678910111213141516171819202122232425262728class Solution&#123;public: //Insert one char from stringstream string str = ""; void Insert(char ch) &#123; if(str.empty()) &#123; str = str + ch; &#125; else &#123; if(str.find(ch)!=-1) str.erase(str.find(ch),1); else str = str + ch; &#125; &#125; //return the first appearence once char in current stringstream char FirstAppearingOnce() &#123; if(str.empty()) return '#'; else return str[0]; &#125;&#125;; Java版： 12345678910111213141516171819202122232425public class Solution &#123; //Insert one char from stringstream String str=""; int[] count=new int[256]; public void Insert(char ch) &#123; if(ch &gt;=256) &#123; return ; &#125; else &#123; str+=ch; count[ch]++; &#125; &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; for(char c:str.toCharArray())&#123; if(count[c]==1)&#123; return c; &#125; &#125; return '#'; &#125;&#125; 题目五十五 链表中环的入口结点题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路利用快慢指针，一个每次走两步，一个每次走一步，直到两个指针重复，找到重复的时候，再走一圈就能知道这个环的入口结点了。 AC代码c++版： 1234567891011121314151617181920212223242526272829303132333435363738394041/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* head) &#123; if(head == NULL) return NULL; ListNode * slow = head; ListNode * fast = head; ListNode * temp = NULL; int node = 1; while(fast -&gt; next != NULL)&#123; slow = slow -&gt; next; fast = fast -&gt; next; if(fast -&gt; next != NULL) fast = fast -&gt; next; else return NULL; if(slow == fast)&#123; temp = slow; break; &#125; &#125; if(temp != NULL)&#123; slow = head; while(slow != fast)&#123; slow = slow -&gt; next; fast = fast -&gt; next; &#125; return slow; &#125; else return NULL; &#125;&#125;; Java版： 12345678910111213141516171819202122232425public class Solution &#123; //Insert one char from stringstream String str=""; int[] count=new int[256]; public void Insert(char ch) &#123; if(ch &gt;=256) &#123; return ; &#125; else &#123; str+=ch; count[ch]++; &#125; &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; for(char c:str.toCharArray())&#123; if(count[c]==1)&#123; return c; &#125; &#125; return '#'; &#125;&#125; 题目五十六 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 思路主要看代码的注释，注释说的比较清楚。 AC代码c++版： 12345678910111213141516171819202122232425262728293031323334353637/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (pHead == NULL || pHead-&gt;next == NULL) return pHead; /*---------先为链表创建一个头结点---------*/ ListNode* p1 = new ListNode(0); p1-&gt;next = NULL;//p1的轨迹记录没有重复的节点 ListNode* head = p1; ListNode* p2 = pHead;//p2用于遍历原链表，方便p1跳过重复的点 while(p2) &#123; if(p2-&gt;next &amp;&amp; p2-&gt;val == p2-&gt;next-&gt;val) &#123; while(p2-&gt;next &amp;&amp; p2-&gt;val == p2-&gt;next-&gt;val) &#123; p2 = p2-&gt;next; &#125; p2 = p2-&gt;next;//p2跳过重复串中的最后一个重复节点 //防止链表尾出现重复，p2==NUll，程序跳出will循环，而p1没有跳过尾部重复 p1-&gt;next = p2; &#125; else &#123;//如果没有重复 p1-&gt;next = p2; p1 = p2; p2 = p2-&gt;next; &#125; &#125; return head-&gt;next; &#125;&#125;; Java版： 12345678910111213141516171819202122232425262728293031323334353637/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null || pHead.next == null) return pHead; /*---------先为链表创建一个头结点---------*/ ListNode p1 = new ListNode(0); p1.next = null;//p1的轨迹记录没有重复的节点 ListNode head = p1; ListNode p2 = pHead;//p2用于遍历原链表，方便p1跳过重复的点 while(p2 != null) &#123; if(p2.next != null &amp;&amp; p2.val == p2.next.val) &#123; while(p2.next != null &amp;&amp; p2.val == p2.next.val) &#123; p2 = p2.next; &#125; p2 = p2.next;//p2跳过重复串中的最后一个重复节点 //防止链表尾出现重复，p2==NUll，程序跳出will循环，而p1没有跳过尾部重复 p1.next = p2; &#125; else &#123;//如果没有重复 p1.next = p2; p1 = p2; p2 = p2.next; &#125; &#125; return head.next; &#125;&#125; 题目五十七 二叉树的下一个结点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路主要看代码的注释，注释说的比较清楚。 AC代码c++版： 12 Java版： 12345678910111213141516171819202122232425262728293031323334/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode.right != null) &#123; pNode = pNode.right; while (pNode.left != null) &#123; pNode = pNode.left; &#125; return pNode; &#125; //第三种情况 // 如果当前子结点pNode右子树为空 // 返回上层的父结点，如果父结点的右子结点就是当前结点，继续返回到上层的父结点...直到父结点的左子结点等于当前结点 while (pNode.next != null &amp;&amp; pNode.next.right == pNode) &#123; pNode = pNode.next; &#125; //第二种 // 如果父结点的左子结点等于当前结点，说明下一个要遍历的结点就是父结点了；或者父结点为空（说明当前结点是root），还是返回父结点（null） // pNode.next == null 或者 pNode.next.left == pNode return pNode.next; &#125;&#125; 题目五十八 对称的二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 思路注意镜像对称的意义，左子树的左孩子和右字树的右孩子相等，左子树的右孩子和右字树的左孩子相等，递归的思想搞定。 AC代码c++版： 12 Java版： 1234567891011121314151617181920212223242526272829303132333435/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; if(pRoot == null || pRoot.left == null &amp;&amp; pRoot.right ==null)&#123; return true; &#125; return Symmetrical(pRoot.left,pRoot.right); &#125; boolean Symmetrical(TreeNode left,TreeNode right)&#123; if(left ==null &amp;&amp; right == null)&#123; return true; &#125; if(left ==null || right ==null)&#123; return false; &#125; if(left.val == right.val)&#123; return Symmetrical(left.left,right.right) &amp;&amp; Symmetrical(left.right,right.left); &#125; return false; &#125;&#125; 题目五十九 按之字形顺序打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 思路就是一个思路，奇数次从左到右入栈然后偶数次从右到左入栈，我们就开两个栈来实现就可以了，其他的就跟平时的打印二叉树一样。 AC代码c++版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; temp; if(pRoot==NULL) return result; stack&lt;TreeNode* &gt; oddStack; stack&lt;TreeNode* &gt; evenStack; oddStack.push(pRoot); while(!oddStack.empty() || !evenStack.empty())&#123; int topNum; TreeNode* pNode; //打印奇数行，从左向右（从1开始） while(!oddStack.empty())&#123; pNode=oddStack.top(); topNum=pNode-&gt;val; oddStack.pop(); temp.push_back(topNum); //下一层从右往左打印，左子树先入栈，右子树再入栈（栈后进先出） if(pNode-&gt;left!=NULL) evenStack.push(pNode-&gt;left); if(pNode-&gt;right!=NULL) evenStack.push(pNode-&gt;right); &#125; if(temp.size()!=0) result.push_back(temp); temp.clear(); //打印偶数行，从右向左 while(!evenStack.empty())&#123; pNode=evenStack.top(); topNum=pNode-&gt;val; evenStack.pop(); temp.push_back(topNum); //下一层从左往右打印。右子树先入栈，左子树再入栈 if(pNode-&gt;right!=NULL) oddStack.push(pNode-&gt;right); if(pNode-&gt;left!=NULL) oddStack.push(pNode-&gt;left); &#125; if(temp.size()!=0) result.push_back(temp); temp.clear(); &#125; return result; &#125; &#125;; Java版： 12 题目六十 把二叉树打印成多行题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路二叉树的打印，利用队列实现，一个bfs的感觉，输出就可以了。 AC代码c++版： 12345678910111213141516171819202122232425262728293031323334353637/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(pRoot==NULL) return res; queue&lt;TreeNode*&gt; q; q.push(pRoot); while(!q.empty())&#123; int start = 0,end = q.size(); vector&lt;int&gt; temp; while(start &lt; end)&#123; TreeNode* node = q.front(); q.pop(); temp.push_back(node-&gt;val); if(node-&gt;left!=NULL) q.push(node-&gt;left); if(node-&gt;right!=NULL) q.push(node-&gt;right); start++; &#125; res.push_back(temp); &#125; return res; &#125; &#125;; Java版： 12 题目六十一 序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 思路我们以前做过利用前序和中序序列来重建二叉树，这个也是差不多，利用中序的遍历实现序列化，然后进行反序列化。 AC代码c++版： 12 Java版： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public int index = -1; String Serialize(TreeNode root) &#123; StringBuffer sb = new StringBuffer(); if(root == null)&#123; sb.append("#,"); return sb.toString(); &#125; sb.append(root.val + ","); sb.append(Serialize(root.left)); sb.append(Serialize(root.right)); return sb.toString(); &#125; TreeNode Deserialize(String str) &#123; String[] strr = str.split(","); int len = strr.length; index++; if(index &gt;= len)&#123; return null; &#125; TreeNode node = null; if(!strr[index].equals("#"))&#123; node = new TreeNode(Integer.valueOf(strr[index])); node.left = Deserialize(str); node.right = Deserialize(str); &#125; return node; &#125;&#125; 题目六十二 二叉搜索树的第k个结点题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 思路首先我们要知道二叉搜索树是什么，根据输的性质我们知道按从小到大的顺序排列正好就是中序遍历；所以按照中序遍历查找，第k个节点就是结果。 AC代码c++版： 12 Java版： 12345678910111213141516171819202122232425262728293031323334/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; int count = 0; TreeNode KthNode(TreeNode pRoot, int k) &#123; if(pRoot == null || k &lt;= 0) return null; TreeNode target = null; if(pRoot.left != null) target = KthNode(pRoot.left, k); count++; if(target == null) &#123; if(count == k) &#123; target = pRoot; return target; &#125; &#125; if(target == null &amp;&amp; pRoot.right != null) target = KthNode(pRoot.right, k); return target; &#125;&#125; 题目六十三 数据流中的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 思路首先第一个想法就是我先把数据全部读进来，然后排个序，再根据这个数据的长度来进行取中位数的操作。 后来在百度上看到了一个更好的做法，就是利用堆的性质去做，具体的堆的做法可以看Java的注释。 AC代码c++版： 12 Java版： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.PriorityQueue;import java.util.Comparator;public class Solution &#123; private int count = 0; // 数据流中的数据个数 // 优先队列集合实现了堆，默认实现的小根堆 private PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); private PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(15, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2 - o1; // o1 - o2 则是小根堆 &#125; &#125;); public void Insert(Integer num) &#123; if ((count &amp; 1) == 0) &#123; // 当数据总数为偶数时，新加入的元素，应当进入小根堆 // （注意不是直接进入小根堆，而是经大根堆筛选后取大根堆中最大元素进入小根堆） // 1.新加入的元素先入到大根堆，由大根堆筛选出堆中最大的元素 maxHeap.offer(num); int filteredMaxNum = maxHeap.poll(); // 2.筛选后的【大根堆中的最大元素】进入小根堆 minHeap.offer(filteredMaxNum); &#125; else &#123; // 当数据总数为奇数时，新加入的元素，应当进入大根堆 // （注意不是直接进入大根堆，而是经小根堆筛选后取小根堆中最大元素进入大根堆） // 1.新加入的元素先入到小根堆，由小根堆筛选出堆中最小的元素 minHeap.offer(num); int filteredMinNum = minHeap.poll(); // 2.筛选后的【小根堆中的最小元素】进入小根堆 maxHeap.offer(filteredMinNum); &#125; count++; &#125; public Double GetMedian() &#123; // 数目为偶数时，中位数为小根堆堆顶元素与大根堆堆顶元素和的一半 if ((count &amp; 1) == 0) &#123; return new Double((minHeap.peek() + maxHeap.peek())) / 2; &#125; else &#123; return new Double(minHeap.peek()); &#125; &#125;&#125; 题目六十四 滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路就根据题意来做，我们可以根据窗口的大小来决定窗口的个数，然后从遍历起始点，得到窗口右边界，然后遍历这个窗口得到这个窗口的最值，然后放到vector。 AC代码c++版： 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) &#123; vector&lt;int&gt; res; if(num.size() == 0 || size == 0) return res; for(int start = 0;start &lt;= (int)(num.size( ) - size);start++) &#123; int end = start + size; int max = INT_MIN; for(int index = start; index &lt; end; index++) &#123; if(num[index] &gt; max) max = num[index]; &#125; res.push_back(max); &#125; return res; &#125;&#125;; Java版： 12 题目六十五 矩阵中的路径题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 思路这个其实就是bfs和dfs的最好的应用，遍历路径是否存在，其次还要记住有个回溯的过程。 AC代码c++版： 12 Java版： 1234567891011121314151617181920212223242526272829public class Solution &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; int flag[] = new int[matrix.length]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (helper(matrix, rows, cols, i, j, str, 0, flag))//每个元素作为起始顶点一次 return true; &#125; &#125; return false; &#125; private boolean helper(char[] matrix, int rows, int cols, int i, int j, char[] str, int k, int[] flag) &#123; int index = i * cols + j; if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || matrix[index] != str[k] || flag[index] == 1) return false; if(k == str.length - 1) return true; flag[index] = 1; if (helper(matrix, rows, cols, i - 1, j, str, k + 1, flag) || helper(matrix, rows, cols, i + 1, j, str, k + 1, flag) || helper(matrix, rows, cols, i, j - 1, str, k + 1, flag) || helper(matrix, rows, cols, i, j + 1, str, k + 1, flag)) &#123; return true; &#125; flag[index] = 0;//回溯 return false; &#125;&#125; 题目六十六 机器人的运动范围题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路同上，就是遍历所有的点，看满足题意的个数。 AC代码c++版： 12 Java版： 1234567891011121314151617181920212223242526public class Solution &#123; public int movingCount(int threshold, int rows, int cols) &#123; boolean[][] flag = new boolean[rows][cols]; return helper(0, 0, rows, cols, threshold, flag); &#125; public int helper(int i, int j, int rows,int cols, int threshold, boolean[][] flag)&#123; if(i &lt; 0 || j &lt; 0 || i &gt;= rows || j &gt;= cols || flag[i][j] || (getSum(i) + getSum(j) &gt; threshold))&#123; return 0; &#125; flag[i][j] = true; return helper(i- 1, j, rows, cols, threshold, flag) + helper(i, j - 1, rows, cols, threshold, flag) + helper(i + 1, j, rows, cols, threshold, flag) + helper(i , j + 1, rows, cols, threshold, flag) + 1; &#125; int getSum(int x)&#123; int sum = 0; while( x != 0)&#123; sum += (x + 10) % 10; x /= 10; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题（持续更新）]]></title>
    <url>%2F2019%2F06%2F24%2FLeetCode%E5%88%B7%E9%A2%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode1 Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路这个找到两个数，使得相加和为target。最简单的两重循环找到这个符合题意的值。 也可以一遍扫过去，每次找target-nums[i]值是否出现过，出现了就返回，不然就存到数组中。 AC代码12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123; var len=nums.length; var i,j; var hash=[]; for(i=0;i&lt;len;i++)&#123; j=target-nums[i]; if(hash[j]!==undefined)&#123; return [i,hash[j]]; &#125; else&#123; hash[nums[i]]=i; &#125; &#125;&#125;; LeetCode5 Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 思路题意是找出一个最长的回文子串，有几种做法，我这里提供两种。 第一种是暴力，回文子串有两种，长度为奇数的和长度为偶数的，对于每个位置点，我向两边进行扩散，分别进行奇数和偶数长度的回文子串判断，然后维护一个长度最大值和这个子串的起始位置。 AC代码1234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; s * @return &#123;string&#125; */var low=0;var maxn=0;var longestPalindrome = function(s) &#123; var len=s.length; if(len &lt; 2)&#123; return s; &#125; for(let i=0;i&lt;len-1;i++)&#123; check(s,i,i); check(s,i,i+1); &#125; let res=s.substring(low,low+maxn); low =0;maxn= 0; return res;&#125;;function check(s,start,end)&#123; while(start&gt;=0 &amp;&amp; end&lt;s.length &amp;&amp; (s[start]==s[end]))&#123; start--; end++; &#125; if(maxn&lt;(end-start-1))&#123; low=start+1; maxn=end-start-1; &#125;&#125; 第二种是利用动态规划的思想，我们知道对于长度为1的都是回文子串，然后枚举子串长度和子串起点，判断是否是回文子串，维护一个最大值和子串的起始点。 AC代码1234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; s * @return &#123;string&#125; */var low=0;var maxn=0;var longestPalindrome = function(s) &#123; var len=s.length; if(len&lt;2)&#123; return s; &#125; var dp=new Array(); var i=0;var j; var left=0,right=0,len1=0; for(;i&lt;len;i++) dp[i]=new Array(); for(i=0;i&lt;len;i++)&#123; dp[i][i]=1; for(j=0;j&lt;i;j++)&#123; dp[j][i] = (s[i] == s[j] &amp;&amp; (i - j &lt; 2 || dp[j + 1][i - 1])); if (dp[j][i] &amp;&amp; len1 &lt; i - j + 1) &#123; len1 = i - j + 1; left = j; right = i; &#125; &#125; &#125; return s.substr(left, right-left+1);&#125;; LeetCode7 Reverse IntegerGiven a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 思路题意是让一个32位的带符号的整数倒置过来。 就先取绝对值，然后初始化一个result = 0，把给定的数字n除以十，得到余数作为最低位，商作为新的数字n，result = result + 余数*10，这样每次得到的最低位就会随着循环不断提升数位，从而得到逆序的result。 AC代码1234567891011121314/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123; var y=Math.abs(x); var res=0; while(y&gt;0)&#123; res=res*10+y%10; y=parseInt(y/10); &#125; res=x&lt;0?-res:res; return res&gt;=-Math.pow(2,31)&amp;&amp;res&lt;=Math.pow(2,31)-1?res:0;&#125;; LeetCode9 Palindrome NumberDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. 思路给你一个数，看是不是回文数。首先负数肯定不会是回文数，直接return false即可，小于10的非负整数都是回文return true， 否则就从后往前进行逆序数组转数字运算，得到结果与初值进行比较，相等return true。 AC代码12345678910111213141516171819/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */var isPalindrome = function(x) &#123; //能被10整除的非0整数和负数，返回false if(x&lt;0) return false; if(x&lt;10) return true; var temp=0; var org=x;//记录x的初始值 while(x&gt;9)&#123; temp=x%10+temp*10 x=parseInt(x/10) &#125; temp=temp*10+x return temp===org&#125;;]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现六]]></title>
    <url>%2F2019%2F06%2F10%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%E5%85%AD%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端项目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现五]]></title>
    <url>%2F2019%2F06%2F10%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%E4%BA%94%2F</url>
    <content type="text"><![CDATA[功能需求现在情形是每当有人进频道的时候，这个人的视频数据和video数据都会被接受，现在想做成我只接收我现在当前屏幕的显示的视频的数据流，频道里其他人的话我只接收声音就可以了。 实现首先我么要知道什么时候我们需要这个视频流量屏蔽的功能，根据需求我们可以了解到是否绑定视图来决定是否要屏蔽流量，所以我们需要再三个地方进行修改。 在YoumeModule添加对应的事情监听： 123456789101112131415case YouMeConst.YouMeEvent.YOUME_EVENT_OTHERS_VIDEO_ON:&#123; Log.d(TAG, "video _on: "+param.toString()); TimerTask task = new TimerTask() &#123; @Override public void run() &#123; Vector&lt;SurfaceViewRenderer&gt; renderInfos = VideoRendererManager.getInstance().getRender(param.toString()); if(renderInfos == null || renderInfos.size() == 0) &#123; Log.d(TAG, "run: "+param.toString()); api.maskVideoByUserId(param.toString(), true); &#125; &#125; &#125;; Timer timer = new Timer(); timer.schedule(task, 150);&#125; 然后就是对应的在delete的时候肯定是屏蔽流量的，在对应的add或者change的时候肯定是不屏蔽的所以在YoumeViewManager中加以下的内容： 123456//添加或者改变的时候是在当前的videoview上修改，所以不屏蔽api.maskVideoByUserId(userID, false);//delete的时候需要屏蔽if(videoView.autoMask &amp;&amp;(renderInfos == null || renderInfos.size() == 0))&#123; api.maskVideoByUserId(videoView.userid, true);&#125;]]></content>
      <categories>
        <category>前端项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现四]]></title>
    <url>%2F2019%2F06%2F10%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[功能需求点击头部结束文字弹出用户提示是否要退出 实现使用Alert实现这个功能，参考https://reactnative.cn/docs/alert.html#docsNav，启动一个提示对话框，包含对应的标题和信息。本接口可以在 iOS 和 Android 上显示一个静态的提示框。如果要在显示提示框的同时接受用户输入一些信息，那你可能需要AlertIOS。 对应我们需求只需要一个静态的提示框就可以了。这个接口在 Android 上最多能指定三个按钮，这三个按钮分别具有“中间态”、“消极态”和“积极态”的概念： 如果你只指定一个按钮，则它具有“积极态”的属性（比如“确定”）；两个按钮，则分别是“消极态”和“积极态”（比如“取消”和“确定”）；三个按钮则意味着“中间态”、“消极态”和“积极态”（比如“稍候再说”，“取消”，“确定”）。我们这个只需要积极态和消极态就可以了。 1234567891011121314151617const &#123; meetingId &#125; = await retrieveUserLoginData();if (meetingId) &#123; Alert.alert( &apos;提示&apos;, &apos;是否确认退出当前视频会议&apos;, [ &#123; text: &apos;取消&apos;, onPress: () =&gt; &#123;&#125; &#125;, &#123; text: &apos;确定&apos;, onPress: async () =&gt; &#123; await this.yim.LeaveChannel(`$&#123;meetingId&#125;`);// IM 退出房间 await this.yim.logout();// IM 退出登录 TalkService.leaveChannel(); const &#123; navigate &#125; = this.context; navigate(&apos;JoinMeeting&apos;); &#125;&#125; ] );&#125;]]></content>
      <categories>
        <category>前端项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现三]]></title>
    <url>%2F2019%2F06%2F10%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[功能需求实现userId和View的一对多，以及保证线程安全，在ViewRenderManager中修改addRender，Remove的实现修改一个人对应的View。 实现首先之前的存储是利用HashMap存储，一个userId对应一个View： 123456789public class RenderInfo &#123; public int rotation; public SurfaceViewRenderer view; public RenderInfo(int rotation, SurfaceViewRenderer view)&#123; this.rotation = rotation; this.view = view; &#125;&#125;private Map&lt;String, RenderInfo&gt; renderers = new HashMap&lt;String, RenderInfo&gt;(); 那么我需要实现一个userId对应多个View，那么我肯定需要拿一个数据结构存储这多个View并且保证线程安全，可以选择ConcurrentHashMap代替HashMap，然后用Vector去存储这多个View。 1private Map&lt;String, Vector&gt; renderers = new ConcurrentHashMap&lt;String, Vector&gt;(); 我们在VideoRendererManager里写增删，然后再外面封装一层YoumeManager实现增删改，最后在YoumeViewManager写业务逻辑时候再调用函数实现功能点。 那我们先修改VideoRendererManager层： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*** 添加渲染源,添加的时候如果这个userId已经存在，就添加到对应的Vector里面，如果不存在* 话就新生成一个Vector，然后put到ConcurrentHashMap里面就可以了。* @param view* @return*/public RenderInfo addRender(String userId, SurfaceViewRenderer view) &#123; //int renderId = api.createRender(userId); RenderInfo info = new RenderInfo(0, view); Vector&lt;RenderInfo&gt; renderInfos = renderers.get(userId); if(renderInfos != null)&#123; renderInfos.add(info); &#125; else&#123; Vector&lt;RenderInfo&gt; renderInfos1 = new Vector&lt;RenderInfo&gt;(); renderInfos1.add(info); renderers.put(userId,renderInfos1); &#125; Log.d(TAG, "addRender userId:"+userId); return info;&#125;/*** get渲染源，以前的话只需要get出来那个userId，所以返回SurfaceViewRenderer就可以了* 现在因为一个userId对应多个View，所以应该返回Vector&lt;SurfaceViewRenderer&gt;，然后* 由于从ConcurrentHashMap里面取出来的是RenderInfo，所以应该把View从RenderInfo* 取出来放到Vector中再返回*/public Vector&lt;SurfaceViewRenderer&gt; getRender(String userId) &#123; Vector&lt;RenderInfo&gt; renderInfos = renderers.get(userId); Vector&lt;SurfaceViewRenderer&gt; surfaceViewRenderers = new Vector&lt;SurfaceViewRenderer&gt;(); if(renderInfos != null)&#123; for(int i=0;i&lt;renderInfos.size();i++)&#123; surfaceViewRenderers.add(renderInfos.get(i).view); &#125; return surfaceViewRenderers; &#125; else &#123; return null; &#125;&#125;/*** 删除的时候，因为每个人有多个View，所以删除的时候要删除对应的userId的对应的那个* RenderInfo，当然如果这个userId对应的View要是为空的时候就应该把这个userId* ConcurrentHashMap里面删除，*/public int deleteRender(String userId,RenderInfo renderInfo) &#123; //int ret = api.deleteRender(renderId); if(renderInfo == null) &#123; renderers.remove(userId); &#125; else&#123; Vector&lt;RenderInfo&gt; renderInfos = renderers.get(userId); if(renderInfos != null) &#123; renderInfos.remove(renderInfo); &#125; &#125; return 0;&#125;同理在渲染的时候之前是直接渲染对应的那个View，现在的话我们需要把这个userId对应的Vector取出来，然后渲染这个Vector。 这样的话最底层的数据修改就完成了，现在修改YoumeManager层： 1234567891011public VideoRendererManager.RenderInfo addRenderInfo(final String userid) &#123; SurfaceViewRenderer sView = new SurfaceViewRenderer(context); return VideoRendererManager.getInstance().addRender(userid,sView);&#125;public void deleteRenderInfo (String userid, VideoRendererManager.RenderInfo renderInfo)&#123; VideoRendererManager.getInstance().deleteRender(userid,renderInfo); if(renderInfo != null &amp;&amp; renderInfo.view != null)&#123; renderInfo.view.release(); &#125;&#125; 再修改YoumeViewManager层： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@ReactProp(name = "options")public void setOptions(final YoumeVideoView videoView, final ReadableMap options) &#123; String userID = options.hasKey("userID") ? options.getString("userID") : ""; //停止在最后一帧画面 boolean pause = options.hasKey("pause") ? options.getBoolean("pause") : false; //隐藏视频组件显示，如果全部都隐藏了，同时会屏蔽视频流接受 boolean hide = options.hasKey("hide") ? options.getBoolean("hide") : false; //在组件销毁时自动屏蔽视频接受 boolean autoMask = options.hasKey("autoMask") ? options.getBoolean("autoMask") : false; Log.d(REACT_COMPONENT_NAME, "setOptions:"+currentCount+ " " + userID + " pause:" + pause + " hide:" + hide); if (userID == null) return; /** 根据业务逻辑，当我们需要改变userId的时候有几种情况，第一个是change，第二个 * 是add，add的话我们就直接调用YoumeManager层的addRenderInfo函数，然后把对应 * 的View绑定到对应的videoView（正在渲染的View）上就可以了。change的话我们正常 * 的逻辑就是我把这个对应的userId的对应的View删了，然后把新的View添加到这个 * userId上去就可以了，当然还需要把之前的View从当前渲染的videoView上取消绑定以 * 及把新的View绑定到哦当前渲染的videoView上。 */ if (videoView.surfaceView != null) &#123; if (!userID.equals(videoView.userid)) &#123; YoumeManager.getInstance().deleteRenderInfo(videoView.userid, videoView.renderInfo); videoView.removeView(); videoView.renderInfo = YoumeManager.getInstance().addRenderInfo(userID); videoView.addView(videoView.renderInfo, userID); setZOrderMediaOverlay(videoView, videoView.zOrderMediaOverlay); &#125; &#125; else &#123; videoView.renderInfo = YoumeManager.getInstance().addRenderInfo(userID); videoView.addView(videoView.renderInfo, userID); &#125; videoView.setPause(pause); videoView.setHide(hide); api.maskVideoByUserId(userID, false); videoView.setAutoMask(autoMask); if(videoView.neetSetZOrder)&#123; videoView.neetSetZOrder = false; setZOrderMediaOverlay(videoView, videoView.zOrderMediaOverlay); &#125;&#125;@Override//销毁实例public void onDropViewInstance(YoumeVideoView videoView) &#123; Log.d(REACT_COMPONENT_NAME, "onDropViewInstance："+ currentCount + " "+ (videoView.userid != null ? videoView.userid:"")); if(videoView.userid != null) &#123; YoumeManager.getInstance().deleteRenderInfo(videoView.userid, videoView.renderInfo); Vector&lt;SurfaceViewRenderer&gt; renderInfos = VideoRendererManager.getInstance().getRender(videoView.userid); if(videoView.autoMask &amp;&amp;(renderInfos == null || renderInfos.size() == 0)) &#123; api.maskVideoByUserId(videoView.userid, true); &#125; &#125; super.onDropViewInstance(videoView);&#125; 这样的话，我们的任务就解决了。]]></content>
      <categories>
        <category>前端项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6熟悉]]></title>
    <url>%2F2019%2F06%2F08%2FES6%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Let和Const命令LetES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 123456&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 用let声明的变量不会进行变量提升，我们知道用var声明的变量定义的话是会进行变量提升，即使你在变量定义之前使用也只是用返回一个undefined，但是你要是用let声明的话是会抛出一个错误，因为如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 123456// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; for循环的时候就很适合使用let，但是注意一个点，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。如： 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 let不允许在相同作用域内，重复声明同一个变量，但是允许块级作用域的任意嵌套，然后内层作用域可以定义外层作用域的同名变量。 为什么需要块级作用域？ 第一种场景，内层变量可能会覆盖外层变量。 第二种场景，用来计数的循环变量泄露为全局变量。 块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。但是注意函数声明类似于var，即会提升到全局作用域或函数作用域的头部，同时，函数声明还会提升到所在的块级作用域的头部。比方这个实例： 12345678910111213141516171819// 浏览器的 ES6 环境function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log(&apos;I am inside!&apos;); &#125; &#125; f();&#125;());/* Uncaught TypeError: f is not a function，它会报错，说f并不是函数类型，这是因为上述说的问题，这样声明的情况下，代码等价于下面*/function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log(&apos;I am inside!&apos;); &#125; &#125; f();&#125;());//因此f在定义的时候不是一个函数后序又没有进行函数的声明调用导致报错 所以在块级作用域汇总避免声明函数，如果非要声明的话应该写成函数表达式的形式。另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，而let只能出现在当前作用域的顶层。 Constconst声明一个只读的常量。一旦声明，常量的值就不能改变，并且必须立即初始化。const的作用域与let命令相同：只在声明所在的块级作用域内有效。 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的，但是不能保证这对象或者数组里面的内容不会进行改变，不会变的知识这个地址，对象依旧能够添加新的对象。 如果真的想将对象冻结，应该使用Object.freeze方法。 1234const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 注意：ES6有六种声明变量的方法：let，const，var，function，class，import。 变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解，如下图： 1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值，如果解构不成功，变量的值就等于undefined。 解构赋值允许指定默认值，如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 什么时候能用解构赋值？只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。像set，array，map。对象也可以进行解构赋值。 对象解构赋值的注意点对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。如： 1234let &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;baz // &quot;aaa&quot;foo // error: foo is not defined//foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 对象结构赋值的时候也可以进行嵌套赋值，但是如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。当然对象的解构赋值也可以指定默认值。 除了这些还有： 如果要将一个已经声明的变量用于解构赋值，必须非常小心。 1234567// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;);//为 JavaScript 引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误。 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 解构赋值的圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理，ES6规定了几种不能使用圆括号的情况： （1）变量声明语句（2）函数参数（3）赋值语句的模式 看下实例： 123456789101112131415// 变量声明错误let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;//函数参数// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125;// 赋值语句的模式全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 解构赋值的用处1：交换变量的值 2：从函数返回多个值 3：函数参数的定义（可以方便地将一组参数与变量名对应起来） 4：提取 JSON 数据 5：函数参数的默认值 6：遍历 Map 结构 7：输入模块的指定方法 Module众所周知JavaScript是没有module的概念的，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。在ES6之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器，在ES6中，通过export命令显式指定输出的代码，再通过import命令输入，这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载。但是不是说有这个之后就不需要动态加载了，特别是在浏览器工作的时候有时候是不需要把所有依赖的东西都导入的，可以到你需要的时候导入。 Export一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。export命令除了输出变量，还可以输出函数或类。通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 123456789101112131415161718//输出变量export var year = 1958;var year = 1958;var firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;export &#123; firstName, lastName, year &#125;;//输出函数或者类export function multiply(x, y) &#123; return x * y;&#125;;//重命名function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错。 Importexport命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 import命令具有提升效果，会提升到整个模块的头部，首先执行，因为它是编译时期执行的，所以不能使用表达式和变量并且不能放在判断语句这些里面，这些只有在运行时才能得到结果的语法结构。 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 Export Default它的默认输出是一个函数。 1234567// export-default.jsexport default function () &#123; console.log(&apos;foo&apos;);&#125;// import-default.jsimport customName from &apos;./export-default&apos;;customName(); // &apos;foo&apos; 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。但是注意引入的模块的内容只能字啊import和export内容之间被引用。 Import()前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行所以，下面的代码会报错。 123if (x === 2) &#123; import MyModual from &apos;./myModual&apos;;&#125; 上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。所以引入import()函数以帮助完成动态加载。 import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。 import()返回一个 Promise 对象。 12345678const main = document.querySelector(&apos;main&apos;);import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;) .catch(err =&gt; &#123; main.textContent = err.message; &#125;); 它一般会用于：按需加载，条件加载，动态的模块路径。 Module加载实现浏览器加载HTML 网页中，浏览器通过&lt;script&gt;标签加载 JavaScript 脚本。默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。 12&lt;script src="path/to/myModule.js" defer&gt;&lt;/script&gt;&lt;script src="path/to/myModule.js" async&gt;&lt;/script&gt; defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成）才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type=&quot;module&quot;属性。 1&lt;script type="module" src="./foo.js"&gt;&lt;/script&gt; 浏览器对于带有type=&quot;module&quot;的&lt;script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。 ClassClass概念ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。利用class就很像我们之前在c++，java当中学习的对象。 12345678910class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125;/*constructor方法，这就是构造方法;this关键字则代表实例对象,Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。*/ 注意：类的数据类型就是函数，类本身就指向构造函数。而且类的方法都定义在prototype对象上面。 constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 类必须使用new调用，否则会报错。 类的所有实例共享一个原型对象。 1234var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__/*true，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。*/ 实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 123456789101112131415161718//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty(&apos;x&apos;) // truepoint.hasOwnProperty(&apos;y&apos;) // truepoint.hasOwnProperty(&apos;toString&apos;) // falsepoint.__proto__.hasOwnProperty(&apos;toString&apos;) // true/*上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。*/ 类的属性名，可以采用表达式。12345678910let methodName = &apos;getArea&apos;;class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125;//Square类的方法名getArea，是从表达式得到的。 Class表达式与函数一样，类也可以使用表达式的形式定义。 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。 静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 123456789class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;Foo.classMethod() // &apos;hello&apos;var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 如果静态方法包含this关键字，这个this指的是类，而不是实例 12345678910111213class Foo &#123; static bar() &#123; this.baz(); &#125; static baz() &#123; console.log(&apos;hello&apos;); &#125; baz() &#123; console.log(&apos;world&apos;); &#125;&#125;Foo.bar() // hello/*静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。*/ 父类的静态方法，可以被子类继承。静态方法也是可以从super对象上调用的。 Class继承Class 可以通过extends关键字实现继承 123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + &apos; &apos; + super.toString(); // 调用父类的toString() &#125;&#125; 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 Object.getPrototypeOf方法可以用来从子类上获取父类。可以使用这个方法判断，一个类是否继承了另一个类。 supersuper这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。就是我们上面写的代码中就能看出来。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 12345678910111213class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B();/*子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。*/ 由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 prototype属性和proto属性每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 子类的__proto__属性，表示构造函数的继承，总是指向父类。 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HOOK介绍及理解]]></title>
    <url>%2F2019%2F06%2F08%2FHOOK%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是HOOK，什么时候用？Hook是一个特殊的函数，它可以让你“钩入” React 的特性。它允许让你在不编写 class 的情况下使用 state 以及其他的 React 特性。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。 React 内置了一些像 useState，useEffect这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。 State Hook看实例： 12345678910111213141516import React, &#123; useState &#125; from &apos;react&apos;;function Example() &#123; // 声明一个叫 “count” 的 state 变量。 const [count, setCount] = useState(0); // 声明多个 state 变量！ const [age, setAge] = useState(42); const [fruit, setFruit] = useState(&apos;banana&apos;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useState 就是一个 Hook。通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState。这里用到了数组解构的语法。 useState 唯一的参数就是初始 state，不同于 this.state，这里的 state 不一定要是一个对象。 我们声明了一个叫 count 的 state 变量，然后把它设为 0。React 会在重复渲染时记住它当前的值，并且提供最新的值给我们的函数。我们可以通过调用 setCount 来更新当前的 count。 这样的话，我们在引用这个state变量的时候和更新state的时候就比之前方便很多，如： 123456//在函数中，我们可以直接用 count:&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;//更新的时候&lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me&lt;/button&gt; Effect HOOKEffect Hook可以让你在函数组件中执行副作用操作，使用useEffect来实现。我们可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合，在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。我们来更仔细地看一下他们之间的区别。感觉就是你需不需要返回一个清除的函数。 我们知道在 React 的 class 组件中，render 函数是不应该有任何副作用的。一般来说，在这里执行操作太早了，我们基本上都希望在 React 更新 DOM 之后才执行我们的操作。 不需要清除的Effect HOOK看下实例： 123456789101112131415import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function Example() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 通过使用这个 Hook，会告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。在这个 effect 中，我们设置了 document 的 title 属性。 为什么在组件内部调用 useEffect？将 useEffect 放在组件内部让我们可以在 effect 中直接访问 count state 变量（或其他 props）。 useEffect 会在每次渲染后都执行吗？默认情况下，它在第一次渲染之后和每次更新之后都会执行。你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的时，DOM 都已经更新完毕。 大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffectHook 供你使用 需要清除的Effect HOOK就是我们添加了监听事件或者一些事需要在之后进行清除操作防止引起内存泄露，那么我们就应该返回一个函数，其实是对应着之前说过的组件的生命周期componentWillUnmount不使用Hook的时候是需要在这个函数中调用清操作的。看实例： 123456789101112131415161718import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // Specify how to clean up after this effect: return function cleanup() &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return &apos;Loading...&apos;; &#125; return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;&#125; React 何时清除 effect？React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect之前对上一个 effect 进行清除。 通过跳过Effect进行性能优化在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决： 12345componentDidUpdate(prevProps, prevState) &#123; if (prevState.count !== this.state.count) &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125;&#125; 在Hook中，如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可： 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 仅在 count 更改时更新 但是注意使用这种优化的情况是：你这个 userEffect 依赖了 props 或者state的属性时，由于不想每次组件渲染的时候都执行这个 useEffect，因此可以在数组里面添加 props.name，每次组件渲染的时候，通过看一下 props.name 这个属性的值有没有变化，如果没有变化，就不执行这个 useEffect。这样就减少了这个 useEffect 的执行次数，从而达到了优化性能的作用。 就像官网上说的：如果你要使用此优化方式，请确保数组中包含所有外部作用域中会随时间变化并且在 effect 中使用的变量，否则你的代码会引用到先前渲染中的旧变量 Hook使用的一些规则Hook 本质就是JavaScript 函数，但是在使用它时需要遵循两条规则： 只在最顶层使用 Hook不要在循环，条件或嵌套函数中调用 Hook，确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。 如果需要调用条件循环的话，可以把判断放到Hook的内部： 123456useEffect(function persistForm() &#123; // 👍 将条件判断放置在 effect 中 if (name !== &apos;&apos;) &#123; localStorage.setItem(&apos;formData&apos;, name); &#125; &#125;); 只在 React 函数中调用 Hook不要在普通的 JavaScript 函数中调用 Hook，可以在React的函数组件中调用Hook，或者在自定义Hook中调用其他的Hook。 我们可以在单个组件中使用多个 State Hook 或 Effect Hook。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>HOOK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行报错汇总]]></title>
    <url>%2F2019%2F05%2F29%2F%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1.com.android.builder.testing.api.DeviceException：com.android.ddmlib.InstallException：INSTALL_FAILED_VERSION_DOWNGRADE是因为不在最新版本的RN上构建调试apk，可能在已安装的应用程序内部存在某些版本冲突，尝试在手机端先卸载然后重新运行一下。 2.Problem:Failed to capture fingerprint of output files for task ‘:app:generateDebugBuildConfig’ property ‘sourceOutputDir’ during up-to-date check.解决方法： 1234cd android./gradlew cleancd ..react-native run-android 3.This error is caused by hasteImpl returning the same name for different files.表明你有两个react-native依赖关系。一个在您的主项目，一个你的XXX模块中，从而创造自己的冲突package.json秒。似乎如果你从一个本地路径，它会将它的安装包像node_modules目录。 正如你已经react-native在你的自定义模块的依赖package.json，尝试删除E:cdg-nativeCDGnode_modulesreact-native-XXXnode_modules。我就是不小心在某个文件夹中又运行了一次yarn导入了一些依赖包，删了就可以运行了。 4.无设备连接先运行一下查看连接设备是否有正常设备连接 1adb devices 正常的连接的时候查看一下安装的细节情况： 1gradlew assembleDebug --info 具体的再去细致的看下吧]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现三]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BF%9D%E6%8C%81%E5%B1%8F%E5%B9%95%E5%B8%B8%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[功能需求在我们进行视频的过程中，需要保持屏幕常亮，避免进入锁屏的需要。想法就是在人员加入到频道的时候调用屏幕常亮的方法，然后在离开频道的时候调用去除屏幕常亮的方法。 几种常见的方法FLAG_KEEP_SCREEN_ON它是基于一个activity的方法，它是一个页面 Window 上的一个Flag，使用 addFlags() 方法添加。 1activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); 这里使用完成之后，也是需要取消掉的。取消这个 Flag 使用 clearFlags() 方法来取消。 1activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); keepScreenOn除了给Window添加一个FLAG_KEEP_SCREEN_ON的 Flag 之外，还可以对当前可见的View调用 keepScreenOn() 方法来设置屏幕常亮。它是是 View 对象上的方法。它的原理和FLAG_KEEP_SCREEN_ON一样的，只是它更简单，只需要对某个View设置，如果View可见即生效，否者就不生效。 需要注意的一点，使用keepScreenOn()设置的常亮标识，需要当前View保持屏幕可见才行。所以一般而言，我们会在页面的根布局中，添加此属性。 实际使用首先我需要在Java层实现这个函数，就是使用我们上面说的那个方法，但是在开始的时候是不能在方法内直接调用上面的方法的，因为视图层的更新必须是通过主线程更新的也就是UI线程更新，如果在主线程之外的线程中直接更新页面的话是会抛出以下的异常： 1android.view.ViewRoot$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 解决方法是：https://blog.csdn.net/luckyjda/article/details/8601517 通过Handle和runOnUiThread()去解决，具体的形式可以看链接。 所以在Java层的函数声明是这样的： 12345678910111213141516171819202122232425/** * 开启屏幕常亮 */ @ReactMethod public void keepScreenOn() &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; getCurrentActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125;); &#125; /** * 取消屏幕常亮 */ @ReactMethod public void cancelScreenOn() &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; getCurrentActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125;); &#125; 在Java层调用了之后我们还需要在对应的ts文件进行修改才能使得Js层能够调用这个函数。对应的操作就是对应的ReactNative的插件里面的YoumeVideoEngine.native.ts文件进行如下修改对应我们修改的Java层函数， 1234567public static keepScreenOn() &#123; Youme.keepScreenOn(); &#125; public static cancelScreenOn() &#123; Youme.cancelScreenOn(); &#125; 在此之后我们调用一些命令，把这个ts文件更新到js文件，使得对应的js文件得到修改 12yarnyarn build 做完这些需要的工作我们的接口的工作就已经完成了。 接下来应该做的是在Js层的sdk中调用这个函数， 按着初始的想法我们应该在leaveChannel和joinChannel中调用我们的接口函数： joinChannel中调用： 1YoumeVideoEngine.keepScreenOn(); leaveChannel中调用 1YoumeVideoEngine.cancelScreenOn(); 这样的话整个调用的过程就完成了，能得到预期的视频的时候屏幕常亮的效果。]]></content>
      <categories>
        <category>前端项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现二]]></title>
    <url>%2F2019%2F05%2F29%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[功能需求在接收视频的时候，对于所占屏幕较大的采用高清流，所占屏幕较小的采用低清流。 实现首先需要了解一下，这个视频是如何显示的，之前我是以为在这屏幕中，我需要把所有的memberlist的成员都渲染出来，对于渲染的那个userid就不能清楚的理解，后来我知道了，在这个屏幕的渲染中只会渲染两个成员，除了本身之外渲染memberlist的第一个成员。 这样的话，需要完成的点就比较清晰了。在之前已经有一个默认的把两个视频流都接收为低清流的函数。它是遍历了memberlist然后进行处理，那么我可以在memberlist里面多加一个boolean参数：isBigStream，当这个boolean值为true的时候我接收高清流，值为false的时候接收低清流。那么这个函数我就可以修改成（在之前的基础上修改，因为把对象弄错了，memberlist是一个容器，它是一个map，我们定义的isBigStream参数是对象上的）： 1234567891011_updateReceiveStream = ()=&gt;&#123; let streamInfos = []; for (const [k,v] of this.memberList) &#123; if(v.isBigStream) streamInfos.push(&#123;userID:k, streamID: 0 &#125;); else streamInfos.push(&#123;userID:k, streamID: 1 &#125;); &#125; if(streamInfos.length &gt; 0) YoumeVideoEngine.setUsersVideoInfo(streamInfos);&#125; 第一个问题解决了，那么就是第二个问题我如何设置这个参数值，在这里面我了解到在渲染的时候有两个函数，VideoBig组件和``Videosmall组件，它们分别的去渲染大窗口和小窗口，那么我需要在渲染大窗口的时候把这个userid传到函数里面，然后调用这个函数，把这个userid的isBigStream参数设置为true`就可以了。所以是这样调用 VideoBig.js中： 1TalkService.setUserBigStreamStatus(userId); 那么在封装的sdk中，我就需要写这样的一个函数setUserBigStreamStatus，是这样： 12345setUserBigStreamStatus = (userId) =&gt; &#123; this._updateMemberList(userId, &#123; isBigStream: true &#125;); &#125; 但是也出现了一个问题，因为我渲染的是memberlist里面的除了自己的第一个成员，要是我这个渲染的成员离开了视频，那我是不是要把这个离开的成员的userid对应的isBigStream参数重新设置为false，然后把现在渲染的userid的isBigStream参数值设置为true，因此我又加了两个变量，存储之前渲染的userid和现在要渲染的userid，然后在VideoBig.js中调用函数的时候我们把这个参数进行重新赋值和isBigStream参数的设置，基本上是这样： 123456789101112131415161718//添加部分// 存放状态为大流的 userIdthis.prevBigStreamUserId = '';this.currentBigStreamUserId = '';//函数的重新修改setUserBigStreamStatus = (userId) =&gt; &#123; this.prevBigStreamUserId = this.currentBigStreamUserId; this.currentBigStreamUserId = userId; this._updateMemberList(this.prevBigStreamUserId, &#123; isBigStream: false &#125;); this._updateMemberList(this.currentBigStreamUserId, &#123; isBigStream: true &#125;);&#125; 至此我们修改的任务就完成了，虽然不是自己一个人完成的，但是自己一个人确定的具体的思路还是正确的，争取早日自己独立完成功能点的开发。]]></content>
      <categories>
        <category>前端项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现一]]></title>
    <url>%2F2019%2F05%2F27%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[项目运行步骤先从git上把项目clone下来 1git clone &quot;项目地址的url&quot; 利用VSCode打开项目后，配置好终端，默认的是shell，用git bash的会好用一点。 下载好yarn（一个资源管理器，可以很快导入执行包），在终端中运行命令就可以把项目跑起来了： 12yarnreact-native run-android 功能需求实现成员列表页面的图标渲染，并把这个组件进行封装。 实现首先，已经有一个读取好的memberlist和监听频道中人员变化的函数了。 那么我就需要把数据从这个memberlist中读取出来并显示。基于之前写的那个ReactDemo知道我们需要调用一个函数，并且使用map函数，在函数中把存储的数据显示： 12345678910111213141516171819 function getListItem () &#123; return memberList.map(member =&gt; ( &lt;ListItem key=&#123;member.userId&#125;&gt; &lt;View style=&#123;&#123; flexDirection: 'row' &#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1, flexDirection: 'row'&#125;&#125;&gt; &lt;Text style=&#123;&#123;flex: 3&#125;&#125;&gt; &#123;member.userInfo &amp;&amp; member.userInfo.nick_name&#125;&lt;/Text&gt; &lt;Image source= &#123;member.isMicrophoneOn ? require('./icons/Microphone.png') : require('./icons/Microphone1.png')&#125; /&gt; &lt;Image source= &#123;member.isVideoOn ? require('./icons/Camera.png') : require('./icons/Camera1.png')&#125; /&gt; &lt;/View&gt; &lt;/View&gt; &lt;/ListItem&gt; )); &#125; &lt;View&gt; &lt;List&gt; &#123;getListItem () &#125; &lt;/List&gt;&lt;/View&gt; 这样的话我们就能够读取出信息并基于读取的信息来设定对应的图标。 然后要把这个List封装起来，就需要在我们的components组件文件下定义这个Component。基本的实现其实和我们写好的函数差不多， 12345678910111213141516171819202122232425262728293031323334import React, &#123;useState, useEffect&#125; from 'react';import PropTypes from 'prop-types';import &#123; View, Image &#125; from 'react-native';import &#123; List, ListItem, Text &#125; from 'native-base';export default function EasyList (props)&#123; const &#123; images &#125; = props; const &#123; Microphone, Microphone1, Camera, Camera1 &#125; = images; function getListItem () &#123; return props.memberList.map(member =&gt; ( &lt;ListItem key=&#123;member.userId&#125;&gt; &lt;View style=&#123;&#123; flexDirection: 'row' &#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1, flexDirection: 'row'&#125;&#125;&gt; &lt;Text style=&#123;&#123;flex: 3&#125;&#125;&gt; &#123;member.userInfo &amp;&amp; member.userInfo.nick_name&#125;&lt;/Text&gt; &lt;Image source= &#123;member.isMicrophoneOn ? Microphone : Microphone1&#125; /&gt; &lt;Image source= &#123;member.isVideoOn ? Camera : Camera1&#125; /&gt; &lt;/View&gt; &lt;/View&gt; &lt;/ListItem&gt; )); &#125; return( &lt;List&gt; &#123;getListItem()&#125; &lt;/List&gt; );&#125;EasyList.propTypes = &#123; memberList: PropTypes.array.isRequired, images: PropTypes.object.isRequired&#125;; 我们要知道，组件中调用的资源都是从父组件中传递过来的，所以我们需要把之前的图标也传递过来。 在Image中，我们初步写的函数中调用资源的话是 1source= &#123;...&#125; 那么我们需要把{...}这些资源传递到组件中，因此可以定义一个常量进行传递： 12345678910const images = &#123; Microphone: require('./icons/Microphone.png'), Microphone1: require('./icons/Microphone1.png'), Camera: require('./icons/Camera.png'), Camera1: require('./icons/Camera1.png'),&#125;;&lt;View&gt; &lt;EasyList memberList=&#123;memberList&#125; images=&#123;images&#125; /&gt;&lt;/View&gt; 至于如何读取，在上面的已经写过了，基本上思想是一样的就不重复的叙述了。]]></content>
      <categories>
        <category>前端项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客多台电脑]]></title>
    <url>%2F2019%2F05%2F25%2FHexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[在公司用hexo搭好博客之后，突然有个疑问：我想要回到家继续写文章，那换了电脑之后该怎么更新博客呢？然后就开始智障了。通过谷歌，照着弄了好久，才弄好了。 思路：使用git分支。 准备工作和环境要求在这之前，首先你得有台电脑是配置好了的，也就是确保你已经使用hexo在github pages上面部署好你的个人博客，并在本地电脑拥有该博客的部署环境，即类似于以下图片的文件目录 对username.github.io仓库新建分支，并克隆在Github的username.github.io仓库上新建一个xxx分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为xxx，save保存；然后将该仓库克隆（必须要用命令行）到本地，进入该username.github.io文件目录。 完成上面步骤后，在当前目录使用Git Bash执行git branch命令查看当前所在分支，应为新建的分支xxx 将本地博客的部署文件拷贝进username.github.io文件目录并提交将本地博客的部署文件全部拷贝进username.github.io文件目录，将拷贝进来的博客hexo部署环境提交到xxx分支，提交之前需注意：将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。 执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push即可将博客的hexo部署环境提交到GitHub个人仓库的xxx分支。现在可以在GitHub上的*username*.github.io仓库看到两个分支的差异了。 master分支和xxx分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；xxx分支用于备份博客部署文件，供自己维护更新，保证了两者在一个GitHub仓库内互不冲突。至此你搭配好的电脑上的任务就完成了。 新电脑环境部署和更新首先你需要安装一下Hexo： 123npm install hexonpm installnpm install hexo-deployer-git --save 然后将新电脑的生成的ssh key添加到GitHub账户上 在新电脑上克隆username.github.io仓库的xxx分支到本地，此时本地git仓库处于xxx分支 切换到username.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录[也不需要]，所以需要install下. 然后就可以正常的编辑、撰写文章或其他博客更新改动。 依次执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push指令，保证xxx分支版本最新 执行hexo d -g指令（在此之前，有时可能需要执行hexo clean），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！ 注意：每次换电脑进行博客更新时，不管上次在其他电脑有没有更新（就怕更新之后忘了），最好先git pull获取xxx分支的最新版本，之后再进行编辑和提交。反正就是xjb弄就完事了。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习一]]></title>
    <url>%2F2019%2F05%2F25%2FReact%2F</url>
    <content type="text"><![CDATA[React是什么？React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。React 中拥有多种不同类型的组件。 12345678910111213141516171819class Square extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: null, &#125;; &#125; render() &#123; return ( &lt;div className="shopping-list"&gt; &lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Instagram&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;// 用法示例: &lt;Square name="Talk" /&gt; render 方法的返回值描述了你希望在屏幕上看到的内容。render 返回了一个 React 元素，这是一种对渲染内容的轻量级描述。一个组件接收一些参数，我们把这些参数叫做 props，然后通过 render 方法返回需要展示在屏幕上的视图的层次结构。如上面的代码中 Square 组件只会渲染一些内置的 DOM 组件，如&lt;div /&gt;、&lt;li /&gt;等，但是你也可以组合和渲染自定义的 React 组件。 第一个Reactdemo我们要实现一个列表，列表有Name和Job两列，我们能进行delete操作和submit操作。 安装环境要求以及运行环境至少要求：Node.js5.2版本以上 安装React 1npm install -g create-react-app 创建一个对应的目录存放文件，利用cmd命令行cd到对应的目录，执行以下命令： 123npx create-react-app react-tutorialcd react-tutorialnpm start 运行完之后将localhost:3000使用新的React应用程序弹出一个新窗口如下： 这个时候你去对应的react-tutorial文件夹下就能看到对应的文件了，这个时候你就可以打开/src目录，对里面的文件进行操作了，在你打开对应的localhost:3000的时候，在对应的编辑器里面进行操作保存的话对应的网站内容就会即时的进行更新，报错的信息也能很快地看到。 第一次修改尝试我们将里面的对应的App.js文件进行修改 1234567891011import React, &#123; Component &#125; from &apos;react&apos;class App extends Component &#123; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Hello, React!&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;export default App; 运行之后的效果图 我们将组件导出为App并加载index.js。将组件分离到文件中并不是强制性的，但如果不这样做，应用程序将开始变得笨拙和失控，就是对应的功能做到对应的文件里面，维护一个较好的功能树。 创建Table组件，实现放置列表首先创建一个Table.js文件。创建一个组件的方式有两种，一个是类组件，用类组件创建这个Table组件： 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react'class Table extends Component &#123; render() &#123; return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Job&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Charlie&lt;/td&gt; &lt;td&gt;Janitor&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mac&lt;/td&gt; &lt;td&gt;Bouncer&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Dee&lt;/td&gt; &lt;td&gt;Aspiring actress&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Dennis&lt;/td&gt; &lt;td&gt;Bartender&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; ) &#125;&#125;export default Table; 我们创建的这个组件是一个自定义类组件。我们将自定义组件大写，以区别于常规HTML元素。返回App.js，我们可以在表中加载，首先导入它： 1import Table from &apos;./Table&apos; 加载了之后我们才能在App.js文件中使用这个组件，不然是会报错的。那么加载了之后修改对应的render()函数内容 12345return ( &lt;div className=&quot;container&quot;&gt; &lt;Table /&gt; &lt;/div&gt;) 效果图如下： 另一种创建组件的方式是使用ES6箭头函数来创建这些简单的组件。它是一个函数。此组件不使用class关键字。我们修改一下刚才创建Table组件的方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243const TableHeader = () =&gt; &#123; return ( &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Job&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; )&#125;const TableBody = () =&gt; &#123; return ( &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Charlie&lt;/td&gt; &lt;td&gt;Janitor&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mac&lt;/td&gt; &lt;td&gt;Bouncer&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Dee&lt;/td&gt; &lt;td&gt;Aspiring actress&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Dennis&lt;/td&gt; &lt;td&gt;Bartender&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; )&#125;//修改对应的render()函数class Table extends Component &#123; render() &#123; return ( &lt;table&gt; &lt;TableHeader /&gt; &lt;TableBody /&gt; &lt;/table&gt; ) &#125;&#125; 刷新一下结果还是和之前的一样。 利用props和state进行数据的传输我们现在已经有了一个Table组件，但是数据是硬编码的，React的一个很好的点就是数据传输非常的方便，它使用props和state来实现。我们先使用props来进行数据传输。 props首先删除TableBody组件中的所有数据 123const TableBody = () =&gt; &#123; return &lt;tbody /&gt;&#125; 然后我们在它的父组件里面加入数据，并进行数据传输，我们进行数据传输的方式就是使用属性的方式传递给子组件： 123456789101112131415161718192021222324252627class App extends Component &#123; render() &#123; const characters = [ &#123; name: 'Charlie', job: 'Janitor', &#125;, &#123; name: 'Mac', job: 'Bouncer', &#125;, &#123; name: 'Dee', job: 'Aspring actress', &#125;, &#123; name: 'Dennis', job: 'Bartender', &#125;, ] return ( &lt;div className="container"&gt; &lt;Table characterData=&#123;characters&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 传递到了Table组件之后，我们需要把数据从这个组件内拿出来： 1234567891011121314151617181920212223//拿出来的方式通过数组映射返回数组每个对象，将其映射在rows变量中并返回const TableBody = props =&gt; &#123; const rows = props.characterData.map((row, index) =&gt; &#123; return ( &lt;tr key=&#123;index&#125;&gt; &lt;td&gt;&#123;row.name&#125;&lt;/td&gt; &lt;td&gt;&#123;row.job&#125;&lt;/td&gt; &lt;/tr&gt; ) &#125;) return &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt;&#125;class Table extends Component &#123; render() &#123; const &#123; characterData &#125; = this.props return ( &lt;table&gt; &lt;TableHeader /&gt; &lt;TableBody characterData=&#123;characterData&#125; /&gt; &lt;/table&gt; ) &#125;&#125; 这样的话数据传输就做完了，但是props呢，它只能进行读取并不能对于组件的信息进行改动，如果需要改动的话就需要state了，也就是实现我们的delete操作。 state首先需要在父组件里面创建一个state对象。存放我们之前的数据，为了更新状态，我们将使用this.setState()一种内置的方法来操作状态 12345678state = &#123; characters: [ &#123; name: 'Charlie', // the rest of the data &#125;, ], &#125; 我们需要通过一个函数来处理这件事情，filter就是之前在学习JavaScript的一个高阶函数 12345678removeCharacter = (index) =&gt; &#123; const &#123; characters &#125; = this.state this.setState(&#123; characters: characters.filter((character, i) =&gt; &#123; return i !== index &#125;), &#125;)&#125; 同时呢我们也需要把这个函数传给下面对应的组件，在App.js中进行更新： 12345return ( &lt;div className="container"&gt; &lt;Table characterData=&#123;characters&#125; removeCharacter=&#123;this.removeCharacter&#125; /&gt; &lt;/div&gt;) 在Table组件中也需要进行相应的更新操作：首先要提取出正确的数据，然后继续传递给下面的组件TableBody 123456789render() &#123; const &#123; characterData, removeCharacter &#125; = this.props return ( &lt;table&gt; &lt;TableHeader /&gt; &lt;TableBody characterData=&#123;characterData&#125; removeCharacter=&#123;removeCharacter&#125; /&gt; &lt;/table&gt; )&#125; 在TableBody中就需要添加对应的组件并对点击时间进行removeCharacter()方法的处理： 1234567&lt;tr key=&#123;index&#125;&gt; &lt;td&gt;&#123;row.name&#125;&lt;/td&gt; &lt;td&gt;&#123;row.job&#125;&lt;/td&gt; &lt;td&gt; &lt;button onClick=&#123;() =&gt; props.removeCharacter(index)&#125;&gt;Delete&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt; 该onClick函数必须通过一个返回该removeCharacter()方法的函数就实现了我们的需求。对应的效果图如下并且删除了一个Mac 至此初始化和删除操作就搞定了。 表单的提交通过表单的提交我们可以添加对应的数据，首先我们删除之前的数据，使它为空，然后我们创建一个From.js的文件，设置初始状态为Form具有一些空属性的对象，并将该初始状态指定给this.state。 1234567891011import React, &#123; Component &#125; from 'react'class Form extends Component &#123; constructor(props) &#123; super(props) this.initialState = &#123; name: '', job: '', &#125; this.state = this.initialState &#125;&#125; 我们对此表单的想法是每次在表单中更改字段的状态，并且当我们提交时，所有数据将传递到App状态，然后将更新状态Table。 首先我们定义一个函数handleChange ，在Input中添加Onchange属性调用改函数，使得它能获得Input组件输入的数据。 123456789101112131415161718192021222324252627handleChange = (event) =&gt; &#123; const &#123; name, value &#125; = event.target this.setState(&#123; [name]: value, &#125;) &#125;render() &#123; const &#123; name, job &#125; = this.state; return ( &lt;form&gt; &lt;label&gt;Name&lt;/label&gt; &lt;input type="text" name="name" value=&#123;name&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;label&gt;Job&lt;/label&gt; &lt;input type="text" name="job" value=&#123;job&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/form&gt; );&#125; 这个时候，这个表单已经能够成功的提交了。但是还不能渲染到父组件，我们需要做的最后一步就是在App.js文件创建一个名为handleSubmit() 的函数，传递到From.js组件，然后在该组件中调用这个函数，使得我们在App.js中能够成功的实际提交该数据并更新父状态。 App.js 1234567891011121314//我们实际提交该数据并更新父状态handleSubmit = character =&gt; &#123; this.setState(&#123; characters: [...this.state.characters, character] &#125;)&#125;render() &#123; const &#123; characters &#125; = this.state; return ( //使用属性将数据传递给子组件 &lt;div className="container"&gt; &lt;Table characterData=&#123;characters&#125; removeCharacter=&#123;this.removeCharacter&#125;/&gt; &lt;Form handleSubmit=&#123;this.handleSubmit&#125; /&gt; &lt;/div&gt; ) &#125; From.js 12345678onFormSubmit = (event) =&gt; &#123; event.preventDefault(); this.props.handleSubmit(this.state); this.setState(this.initialState); &#125;&lt;button type="submit" value="Submit" onClick=&#123;this.onFormSubmit&#125; &gt; Submit&lt;/button&gt; 差不多这样整个demo就跑通了。 流程是这样的，可能叙述的不是很清楚，大家可以去github上看下源码就能理解了，还是很基础的demo。 https://github.com/xiaorui2/FrontLearn/tree/master/react-tutorial/src]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语法熟悉三]]></title>
    <url>%2F2019%2F05%2F24%2FJs%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%E4%B8%89%2F</url>
    <content type="text"><![CDATA[JavaScript的异步处理AjaxAjax概念与工作流程AJAX 并非编程语言，它通过浏览器内建的 XMLHttpRequest 对象（从 web 服务器请求数据），然后利用JavaScript 和 HTML DOM（显示或使用数据）。它能够不刷新页面更新网页，在页面加载后从服务器请求和接收数据，在后台向服务器发送数据。 它的工作流程：网页中发生一个事件（页面加载、按钮点击） -&gt; JavaScript 创建 XMLHttpRequest 对象 -&gt; XMLHttpRequest 对象向 web 服务器发送请求 -&gt; 服务器处理该请求 -&gt; 服务器将响应发送回网页 -&gt; JavaScript读取响应并执行正确的动作（比如更新页面） 注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 Ajax实例123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt;table,th,td &#123; border : 1px solid black; border-collapse: collapse;&#125;th,td &#123; padding: 5px;&#125;&lt;/style&gt;&lt;body&gt;&lt;button type="button" onclick="loadDoc()"&gt;获取我的音乐列表&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;table id="demo"&gt;&lt;/table&gt;&lt;script&gt;function loadDoc() &#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myFunction(this); &#125; &#125;; xhttp.open("GET", "/demo/music_list.xml", true); xhttp.send();&#125;function myFunction(xml) &#123; var i; var xmlDoc = xml.responseXML; var table="&lt;tr&gt;&lt;th&gt;艺术家&lt;/th&gt;&lt;th&gt;曲目&lt;/th&gt;&lt;/tr&gt;"; var x = xmlDoc.getElementsByTagName("TRACK"); for (i = 0; i &lt;x.length; i++) &#123; table += "&lt;tr&gt;&lt;td&gt;" + x[i].getElementsByTagName("ARTIST")[0].childNodes[0].nodeValue + "&lt;/td&gt;&lt;td&gt;" + x[i].getElementsByTagName("TITLE")[0].childNodes[0].nodeValue + "&lt;/td&gt;&lt;/tr&gt;"; &#125; document.getElementById("demo").innerHTML = table;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; XMLHttpRequest对象方法和属性 方法 描述 new XMLHttpRequest() 创建新的 XMLHttpRequest 对象 getAllResponseHeaders() 返回头部信息 open(method, url, async, user, psw) 规定请求method：请求类型 GET 或 POSTurl：文件位置，使用的是相对路径async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码 send() 将请求发送到服务器，用于 GET 请求 send(string) 将请求发送到服务器，用于 POST 请求 onreadystatechange 定义当 readyState 属性发生变化时被调用的函数 readyState 保存 XMLHttpRequest 的状态。0：请求未初始化1：服务器连接已建立2：请求已收到3：正在处理请求4：请求已完成且响应已就绪 responseText/XML 以字符串/XML返回响应数据 status 返回请求的状态号：200: &quot;OK&quot;403: &quot;Forbidden&quot;404: &quot;Not Found&quot; CORS跨域在Ajax上我们知道输入URL使用的是相对路径，这是浏览器的同源策略导致的，也就是在发送AJAX请求时，URL的域名必须和当前页面完全一致，不然会报错。这也就是跨域 Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。 Promise在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现，上面的Ajax就是典型的异步操作。 Promise是另一种异步的操作 它的处理想法就是先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。 123456789101112131415161718192021222324function test(resolve, reject) &#123; var timeOut = Math.random() * 2; log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () &#123; if (timeOut &lt; 1) &#123; log('call resolve()...'); resolve('200 OK'); &#125; else &#123; log('call reject()...'); reject('timeout in ' + timeOut + ' seconds.'); &#125; &#125;, timeOut * 1000);&#125;var p1 = new Promise(test);//变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象：//如果成功，执行这个函数：var p2 = p1.then(function (result) &#123; console.log('成功：' + result);&#125;);//如果失败，执行这个函数：var p3 = p2.catch(function (reason) &#123; console.log('失败：' + reason);&#125;); 最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了 再看一个： 12345678910111213141516171819202122232425262728293031'use strict';function log(s) &#123; var p = document.createElement('p'); p.innerHTML = s; logging.appendChild(p);&#125;// 0.5秒后返回input*input的计算结果:function multiply(input) &#123; return new Promise(function (resolve, reject) &#123; log('calculating ' + input + ' x ' + input + '...'); setTimeout(resolve, 500, input * input); &#125;);&#125;// 0.5秒后返回input+input的计算结果:function add(input) &#123; return new Promise(function (resolve, reject) &#123; log('calculating ' + input + ' + ' + input + '...'); setTimeout(resolve, 500, input + input); &#125;);&#125;var p = new Promise(function (resolve, reject) &#123; log('start new Promise...'); resolve(123);&#125;);p.then(multiply) .then(add) .then(multiply) .then(add) .then(function (result) &#123; log('Got value: ' + result);&#125;); Promise还可以并行执行异步任务。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运输层]]></title>
    <url>%2F2019%2F05%2F23%2F%E4%BC%A0%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[运输层概念运输层是位于应用层和网络层之间，为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用，主要要理解的就是我们常用的UDP和TCP协议。通常我们知道的TCP它是一个可靠的传输连接，而UDP是一个不可靠的传输连接。 无连接运输：UDPUDP做的事它是基于Internet IP协议，做了（传输层都要做的功能）复用 / 分用，简单的错误检测。它是无连接的，UDP发送方和接收方之间不需要握手，每个UDP段的处理独立于其他段，并且UDP段可能丢失，非按序到达。 UDP为什么存在因为无需要建立连接（减少延迟），实现简单，无需维护连接状态，头部开销少，没有拥塞控制，应用可以更好的控制发送时间和速率。用于DNS，SNMP等。 如何在UDP上实现可靠数据传输在应用层增加可靠性机制，应用特定的错误恢复机制。（在应用层保证数据传输可靠）添加seq/ack机制，确保数据发送到对端，添加发送和接收缓冲区，主要是用户超时重传，添加超时重传机制 详细说明：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。 UDP的数据格式和校验和 可靠的数据传输原理什么叫可靠？数据不错，不丢，不乱。可靠数据传输对应用层，传输层，链路层都很重要。信道的不可靠性决定可靠数据传输协议（rdt）的复杂性。 可靠的数据传输协议基本结构是通过接口来实现的。调用一些 rdt_send()，rdt_rcv() ，deliver_data()这些函数接口。 可靠信道上的可靠数据传输和产生位错误的信道上的可靠数据传输首先底层信道完全可靠（不会发生错误，不会丢弃分组），发送放和接收方的FSM（有限状态自动机）独立。 在会产生错误的信道传输会利用校验和来检测位错误，发送ACK（接收方显示的告知发送发分组已经正确的接收）或者NAK（错误的接收）当发现错误的时候会利用重传机制重传分组。 从可靠数据传输流水线可靠数据传输Rdt2.1：如何解决重复分组问题：给每个分组增加序列号，接收方丢弃重复分组。应对ACK/NAK破坏或者被损坏的情况。 Rdt2.2：无NAK消息协议，与Rdt2.1功能相同，但是只使用ACK。如何实现？接收方通过ACK告知最后一个被正确接收的分组，在ACK消息中显示的加入被确认分组的序列号。发送发收到重复的ACK之后，采取和收到NAK的动作一样。 Rdt3.0：如果信道既可能发生错误也可能丢失分组，那么校验和+序列号+ACK+重传就不够用了（比方说ACK消息丢失了，发送方就一直在等待）解决方法也很简单：给发送方设置一个合理的时间，如果没有收到ACK就重传。但是这个合理的时间是很难确定的。那么就是需要设置定时器。Rdt3.0能够正常工作，但是性能很差。主要是由于停等协议导致的。 基于Rdt3.0，可以不使用停等协议，允许发送方发送多个分组而无需等待确认，只要最后能收获到ACK确认的技术就是流水线。可因此也需要增加一些内容： 允许发送发在收到ACK之前连续发送多个分组，需要更大的序列号范围；发送方和接收方需要更大存储空间以缓存分组；出现错误时候的处理：滑动窗口协议（主要是回退N步和选择重传） 滑动窗口协议1比特滑动窗口协议（停等协议）当发送窗口和接收窗口的大小固定为1时，滑动窗口协议退化为停等协议。该协议规定发送方每发送一帧后就要停下来，等待接收方已正确接收的确认（ACK）返回后才能继续发送下一帧。由于接收方需要判断接收到的帧是新发的帧还是重新发送的帧，因此发送方要为每一个帧加一个序号。由于停等协议规定只有一帧完全发送成功后才能发送新的帧，因而只用一比特来编号就够了，具有累计确认机制。 回退N帧协议发送窗口大于1，接收窗口大于1， 由于停等协议要为每一个帧进行确认后才继续发送下一帧，大大降低了信道利用率，因此又提出了后退n协议。后退n协议中，发送方在发完一个数据帧后，不停下来等待应答帧，而是连续发送若干个数据帧，即使在连续发送过程中收到了接收方发来的应答帧，也可以继续发送。且发送方在每发送完一个数据帧时都要设置超时定时器。只要在所设置的超时时间内仍收到确认帧，就要重发相应的数据帧。如：当发送方发送了N个帧后，若发现该N帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不重新发送出错帧及其后的N帧。 选择重传协议发送窗口大于1，接收窗口大于1。在后退n协议中，接收方若发现错误帧就不再接收后续的帧，即使是正确到达的帧，这显然是一种浪费。另一种效率更高的策略是当接收方发现某帧出错后，其后继续送来的正确的帧虽然不能立即递交给接收方的高层，但接收方仍可收下来，存放在接收缓冲区中，同时要求发送方重新传送出错的那一帧。一旦收到重新传来的帧后，就可以原已存于缓冲区中的其余帧一并按正确的顺序递交高层。这种方法称为选择重发(SELECTICE REPEAT)。显然，选择重发减少了浪费，但要求接收方有足够大的缓冲区空间。 有连接运输：TCPTCP特点它是一个点到点的通信机制，只能有一个发送方和一个接收方；它提供是一个可靠的，按序的字节流机制；使用流水线机制，通过拥塞控制和流量控制的机制设置窗口尺寸；发送方和接收方都有缓存；它是一个全双工，能双向传输数据的面向连接的通信，通信双方必须在发送数据之前建立连接，连接状态只能在连接的两端维护，不能在沿途的结点维护状态。 TCP报文段结构 源地址端口，目的端口地址 序号：TCP传输保证连接性，发送的每个字节都要编上号 确认号：接收方期望从对方接受的字节编号。如果报文段的接收方成功的接受了对方发过来的编号x的字节，那么返回x+1作为确认号，确认号可以和数据捎带一起发送） 控制：定义了6中不同的控制位或者标志位：URG:紧急数据标志位，ACK：确认标志位，PSH：请求推送位，接收端应尽快把数据传送给应用层，RST：连接复位，通常，如果TCP收到的一个分段明显不属于该主机的任何一个连接，则向远程发送一个复位包，SYN：建立连接，让连接双方同步序列号，FIN：释放连接 检验和：TCP的使用检验和是强制性的,UDP使用检验和是可选的。在计算检验和是报文段要附加相同的伪首部，对于TCP来说伪首部的协议字段的值是6 TCP实现可靠数据传输TCP 在 IP 层提供的不可靠服务基础上实现的可靠数据传输，使用流水线机制，累积确认机制，单一的重传计时器。触发重传的事件：超时，收到重复的 ACK。 序列号和确认号序列号为当前端成功发送的数据位数，确认号为当前端成功接收的数据位数，SYN 标志位和 FIN 标志位也要占 1位 注意这个序列号要和前面的传输的数据量大小联系起来。 快速重传机制TCP 实现中，如果发生超时时间，超时时间间隔会重新设置，即将超时时间间隔加倍，导致其很大，重发丢失分组的时间会等待很久的时间。可以通过重复 ACK 检测检测分组丢失，Sender 收到同一个数据的 3 个 ACK，则假定该数据之后的段已经丢失，即在定时器超时之前进行重传。 TCP流量控制TCP 的滑动窗口大小实际上就是 socket 的接收缓冲区大小的字节数，可以用上层 setopt 来设置。 接收方为 TCP 连接分配 buffer 如果上层应用处理 buffer 中的数据较慢，发送方在这个机制下发送方不会传输的太多太快以至于淹没接收方（buffer 溢出）实现的时候就是 Received 在 Segment 的头部字段中将 RcvWindow 告诉 Sender ，Sender 限制自己发送的但还没收到 ACK 的数据不超过接收方的空闲 RECWindow 的尺寸。但是如果 Received 告知 Sender RcvWindow=0是，发送方仍然可以发送一个很少的数据段，从而更新 RcvWindow 的值 ACK对滑动窗口控制流量的贡献ACK包含两个非常重要的信息： 一是期望接收到的下一字节的序号 n，该 n 代表接收方已经接收到了前 n-1 字节数据，此时如果接收方收到第 n+1 字节数据而不是第 n 字节数据，接收方是不会发送序号为 n+2 的 ACK 的。举个例子，假如接收端收到 1-1024 字节，它会发送一个确认号为 1025 的 ACK，但是接下来收到的是 2049-3072，它是不会发送确认号为 3072 的 ACK,而依旧发送 1025 的 ACK。 二是当前的窗口大小 m，如此发送方在接收到 ACK 包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，假定当前发送方已发送到第 x 字节，则可以发送的字节数就是 y=m-(x-n) .这就是滑动窗口控制流量的基本原理 重点：发送方根据收到 ACK 当中的期望收到的下一个字节的序号 n 以及窗口 m，还有当前已经发送的字节序号x，算出还可以发送的字节数 TCP拥塞控制首先，拥塞控制和流量控制是不一样的。拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程。流量控制是点对点通信量的控制，是一个端到端的问题，主要就是抑制发送端发送数据的速率，以便接收端来得及接收。 拥塞的标志：重传计时器超时，接收到三个重复确认。 发送方维持一个叫做拥塞窗口的状态变量。拥塞窗口的大小取决于网络的拥塞程度，且动态地在变化，我们使用TCP 拥塞控制算法，该算法包括：慢开始和拥塞避免以及快速恢复。 慢启动和拥塞避免慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大（指数的增长）逐渐增加拥塞窗口的大小。拥塞避免则是让拥塞窗口缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞控制窗口加一 为了防止拥塞窗口增长过大引起网络拥塞，设置一个慢开始门限（ ssthresh 状态变量）当拥塞窗口＜ ssthresh，使用慢开始算法（指数增长）当拥塞窗口 = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法（线性增长）当拥塞窗口＞ ssthresh，使用拥塞避免算法 但是无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为 1，执行慢开始算法。 快速恢复与快速重传配合使用采用快速恢复算法时，慢开始只在TCP连接建立时和网络出现超时时才使用。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。 TCP连接管理TCP的三次握手 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x（随机数）； 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置ACK为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y； 客户端收到服务器的SYN+ACK报文段。然后将ACK设置为y+1，向服务器发送ACK报文段， 为什么需要三次握手？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也就是保证第二次的握手客户端是知道连接已经建立。 为什么不是四次握手？因为完全可靠的通信协议是根本不存在的，我们任何的通信协议都是在接受这样的现实情况之上进行的。 而三次握手后，客户端和服务端至少可以确认之前的通信情况，但无法确认之后的情况。 TCP的四次挥手 为什需要四次挥手？ TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 TIME_WAIT 和 CLOSE_WAIT 状态我们看到这个四次挥手的过程中客户端有一个TIME_WAIT 服务器端会到一个CLOSE_WAIT状态。 如果服务器出了异常，百分之八九十都是因为服务端保持了过多的这两种装填，因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，一旦达到句柄数上限，新的请求就无法被处理了，接着就是大量Too Many Open Files异常，Tomcat崩溃。 TIME_WAITTIME_WAIT是主动关闭链接时形成的，等待2MSL时间，约 4 分钟。主要是防止最后一个ACK丢失。 由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接。 为什么需要 TIME_WAIT 状态？假设最终的ACK丢失，server将重发FIN，client必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果server认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，client必须进入TIME_WAIT 状态，因为client可能面 临重发最终ACK的情形。 那为什么需要保持 2MSL 这么长的时间？如果 TIME_WAIT 状态保持时间不足够长(比如小于2MSL)，第一个连接就正常终止了。第二个拥有相同相关五元组的连接出现，而第一个连接的重复报文到达，干扰了第二个连接。TCP实现必须防止某个连接的重复报文在连接终止后出现，所以让TIME_WAIT状态保持时间足够长(2MSL)，连接相应方向上的TCP报文要么完全响应完毕，要么被 丢弃。建立第二个连接的时候，不会混淆。 大量TIME_WAIT造成的影响高并发短连接的 TCP 器上，当服务器处理完请求后立刻按照主动正常关闭连接。这个场景下，会出现大量 socket处于 TIMEWAIT 状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。 高并发短连接的情况导致的，就是业务处理+传输数据的时间 远远小于 TIMEWAIT 超时的时间”的连接，比如取一个 web 页面，1 秒钟的 http 短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在 TIMEWAIT 状态几分钟，而这几分钟，其他 HTTP 请求来临的时候是无法占用此端口的就会出现服务器资源严重浪费的情况。 如何尽量处理TIMEWAIT过多sysctl 改两个内核参数就行了，如下： net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 简单来说，就是打开系统的 TIMEWAIT 重用和快速回收 CLOSE_WAIT它是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回 0。 为什么TCP采用随机初始序列号在TCP的三次握手中，后采用随机产生的初始化序列号进行请求，这样做主要是出于网络安全的因素着想。如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段。 客户端和服务器最多能发送和接收多少TCP连接数？对于服务器，每一个TCP连接都要占一个文件描述符，一旦这个文件描述符使用完了，就会返回错误。我们知道操作系统上端口号1024以下是系统保留的，从1024-65535是用户使用的。由于每个TCP连接都要占一个端口号，所以我们最多可以有60000多个并发连接？但是事实并不是这样。 我们还知道对于TCP连接是由：原IP，原端口，目的IP，目的端口。但是监听server端TCP连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因为它是固定在本地的端口上去监听，所以最大TCP连接为：客户端ip数×客户端port数. 而对于客户端，网络通信过程中服务端监听一个固定的端口,客户端主动发起连接请求后要经过三次握手才能与服务器建立起一个TCP连接.客户端每次发起一个TCP连接时,系统会随机选取一个空闲的端口,该端口是独占的不能与其他TCP连接共享,因此理论上一台机器有多少空闲的端口,就能对外发起多少个TCP连接。根据TCP/IP协议,端口port使用16位无符号整数unsigned short来存储,因此本地端口一共有2^16=65536个,即0-65535,其中0~1023是预留端口,0有特殊含义不能使用,1024以下端口都是超级管理员用户(如root)才可以使用,因此就算使用root权限,一台机器最多能使用的端口也只有65535个。但是一台机器最多只能利用28232个端口. TCP粘包TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。 什么是保护消息边界和流?保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包。而面向流则是指无保护消息保护边界的，如果发送端连续发送数据，接收端有可能在一次接收动作中，会接收两个或者更多的数据包。 例如，我们连续发送三个数据包，大小分别是2k，4k ，8k,这三个数据包，都已经到达了接收端的网络堆栈中，如果使用UDP协议，不管我们使用多大的接收缓冲区去接收数据，我们必须有三次接收动作，才能够把所有的数据包接收完.而使用TCP协议，我们只要把接收的缓冲区大小设置在14k以上，我们就能够一次把所有的数据包接收下来，只需要有一次接收动作。 因此这就是因为UDP协议的保护消息边界使得每一个消息都是独立的。而流传输却把数据当作一串数据流，他不认为数据是一个一个的消息。所以有很多人在使用tcp协议通讯的时候，并不清楚tcp是基于流的传输，当连续发送数据的时候，他们时常会认识tcp会丢包。其实不然，因为当他们使用的缓冲区足够大时，他们有可能会一次接收到两个甚至更多的数据包，而往往只解析检查了第一个数据包。 粘包出现原因简单得说，在流传输中出现，UDP不会出现粘包，因为它有消息边界(参考Window网络编程) 发送端需要等缓冲区满才发送出去，造成粘包 接收方不及时接收缓冲区的包，造成多个包接收 什么时候需要考虑粘包问题如果利用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题。 如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包3如果双方建立连接，需要在连接后一段时间内发送不同结构数据，就需要考虑了。 如何避免粘包 对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满； 对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象； 由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。 网络通讯的封包和拆包为什么基于TCP的通讯程序需要进行封包和拆包TCP是个”流”协议，所谓流，就是没有界限的一串数据，大家可以想想河里的流水，是连成一片的，其间是没有分界线的。但一般通讯程序开发是需要定义一个个相互独立的数据包的，比如用于登陆的数据包，用于注销的数据包。由于TCP”流”的特性以及网络状况，在进行数据传输时会出现以下几种情况。 假设我们连续调用两次send分别发送两段数据data1和data2,在接收端有以下几种接收情况(当然不止这几种情况,这里只列出了有代表性的情况). 先接收到data1,然后接收到data2. 先接收到data1的部分数据,然后接收到data1余下的部分以及data2的全部. 先接收到了data1的全部数据和data2的部分数据,然后接收到了data2的余下的数据. 一次性接收到了data1和data2的全部数据. 对于A这种情况正是我们需要的,不再做讨论.对于B,C,D的情况就是大家经常说的”粘包”,就需要我们把接收到的数据进行拆包，拆成一个个独立的数据包，为了拆包就必须在发送端进行封包。 另：对于UDP来说就不存在拆包的问题,因为UDP是个”数据包”协议,也就是两段数据间是有界限的，在接收端要么接收不到数据要么就是接收一个完整的一段数据，不会少接收也不会多接收。 为什么会出现B.C.D的情况 由Nagle算法造成的发送端的粘包:Nagle算法是一种改善网络传输效率的算法.简单的说,当我们提交一段数据给TCP发送时,TCP并不立刻发送此段数据,而是等待一小段时间,看看在等待期间是否还有要发送的数据,若有则会一次把这两段数据发送出去.这是对Nagle算法一个简单的解释,详细的请看相关书籍. C和D的情况就有可能是Nagle算法造成的. 接收端接收不及时造成的接收端粘包:TCP会把接收到的数据存在自己的缓冲区中,然后通知应用层取数据.当应用层由于某些原因不能及时的把TCP的数据取出来,就会造成TCP缓冲区中存放了几段数据. 封包封包就是给一段数据加上包头,这样一来数据包就分为包头和包体两部分内容了(以后讲过滤非法包时封包会加入”包尾”内容)。包头其实上是个大小固定的结构体，其中有个结构体成员变量表示包体的长度，这是个很重要的变量，其他的结构体成员可根据需要自己定义。根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。 拆包对于拆包目前我最常用的是以下两种方式： 动态缓冲区暂存方式。之所以说缓冲区是动态的是因为当需要缓冲的数据长度超出缓冲区的长度时会增大缓冲区长度。 利用底层的缓冲区来进行拆包 Nagle 算法它是用于处理小报文段（微小分组）的发送问题。可以减少网络中微小分组的数量，比如客户端需要依次向服务器发送大小为1,2,3,1,2字节的5个分组。在没有开启nagle算法的情况下，这些小分组会被依次发送（不需要等待上一个小分组的应答，因为没启动Nagle），总共发送的报文段（分组）个数为5 当开启Nagle 算法时，客户端首先发送大小为1字节的第一个分组，随后其它分组到达发送缓冲区，由于上一个分组的应答还没有收到，所以TCP会先缓存新来的这4个小分组，并将其重新分组，组成一个大小为8(2+3+1+2)字节的”较大的”小分组。当第一个小分组的应答收到后，客户端将这个8字节的分组发送。总共发送的报文段（分组）个数为2。可以看到，当传输数据存在大量交互数据时，Nagle 算法可以有效减少网络中的报文段个数。 Nagle 基本定义是任意时刻，最多只能有一个未被确认的小段。所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。 Nagle 算法的规则： 如果包长度达到MSS，则允许发送； 如果该包含有FIN，则允许发送； 设置了TCP_NODELAY选项，则允许发送； 未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送； 上述条件都未满足，但发生了超时（一般为200ms），则立即发送。 虽然Nagle 算法可以减少网络中小分组的个数，但是对于那些需要实时预览的通讯程序而言，客户端可能需要不断发送更新数据并得到服务器的响应，这种情况下Nagle 算法会造成客户端明显的延迟，所以需要禁用Nagle 算法。将套接字描述符设置TCP_NODELAY选项可以禁止Nagle 算法。配合Nagle 的还有延迟确认和累积确认机制这些可以再看看。 TCP和UDP的区别 TCP面向连接,UDP是无连接的，即发送数据之前不需要建立连接； TCP提供可靠的服务，UDP不保证可靠交付； UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信； 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 TCP对系统资源要求较多，UDP对系统资源要求较少。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React长列表优化方案]]></title>
    <url>%2F2019%2F05%2F23%2FReactNative%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[考虑问题我有一个列表，这个列表里面我需要存放10000条数据，我要使得这个列表进行滑动的时候比较流畅，也就是渲染的效果ok。 对这个问题分析一下，我们知道DOM结构如果过大, 网页就会出现用户操作体验上的问题, 比如滚动, 点击操作，会导致渲染的不够及时情况发生。 解决方案解决方案的话就是对于列表形态的数据展示的按需渲染。这种方式是指根据容器元素的高度以及列表项元素的高度来显示长列表数据中的某一个部分，而不是去完整地渲染长列表。通俗的说就是我就渲染我可见的区域的组件，也就是虚拟列表，它是一种根据滚动容器元素的可视区域来渲染长列表数据中某一个部分数据的技术。 实现虚拟列表就是在处理用户滚动时，要改变列表在可视区域的渲染部分，其具体步骤如下结合图片理解一下： 计算当前可见区域起始数据的 startIndex 计算当前可见区域结束数据的 endIndex 计算当前可见区域的数据，并渲染到页面中 计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上 计算 endIndex对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到列表上。 在React上就是使用react-window 和 react-virtualized是热门的虚拟滚动库，而在ReactNative中，我们可以使用Flatlist和Sectionlist组件，这两个组件呢是继承于VirtualizedLis，这个组件的思想也就是维护活动项的有限渲染窗口并用适当大小的空白空间替换渲染窗口之外的所有项，大大提高了大型列表的内存消耗和性能。这样已经能满足大多数情况下的使用，但是这个有一个问题就是当我们更快地滚动时会暂时看到空白内容。我测试了一下，大部分的软件在滑动过快的时候也就会出现加载上的情况等待加载。 所以使用Flatlist和Sectionlist组件能解决常用的长列表问题，至于Flatlist内容的更多优化，可以参考http://yangguang1029.github.io/2018/12/20/rn-improve-flatlist/]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css概念和基础语法]]></title>
    <url>%2F2019%2F05%2F23%2FCss%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Css概念它是一个层叠样式表，存储着很多的样式，而样式定义着如何显示Html元素，因此解决了内容与表现分离的问题，就是我Html只需要写内容，然后用Css来控制它的表现。 当同一个Html元素被不止一个样式定义的时候，会根据优先级高低控制，优先级从高到低依次是： 内联样式（在 Html元素内部）-&gt; 内部样式表（位于 &lt;head&gt; 标签内部）-&gt; 外部样式表 -&gt; 浏览器缺省设置 Css基础Css语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 选择器通常是您需要改变样式的 Html元素。每条声明由一个属性和一个值组成。属性就是希望设置的样式属性。你也可以对选择器进行分组，如下： 123h1,h2,h3,h4,h5,h6 &#123; color: green; &#125; Css的选择器派生选择器用于根据文档的上下文关系来确定某个标签的样式，比方说希望列表中的strong元素变为斜体字，那么我选择器就写成li strong {...}，这样的话只有 li元素中的strong元素的样式为斜体字，不在li元素内部的就还是正常的粗体字. id选择器id 选择器以&quot;#&quot; 来定义。可以独立的调用如：#red {color:red;}。它可以利用派生选择器的思想进行联合使用，比方： 12345#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em; &#125; 那么上面的样式只会应用于出现在id 是 sidebar 的元素内的段落。 注意：id属性只能在每个 Html 文档中出现一次。 类选择器它以一个点号显示： 1234.center &#123;text-align: center&#125;&lt;h1 class="center"&gt;This heading will be center-aligned&lt;/h1&gt; 注意：类名的第一个字符不能使用数字。 属性选择器它以为拥有指定属性的HTML 元素设置样式，而不仅限于class和 id属性，对带有指定属性的HTML 元素设置样式。它还可以绑定值： 12345&lt;!-- 不带后面的等号内容的时候就是为所有带有 title 属性的所有元素设置样式 --&gt;[title=W3School]&#123;border:5px solid blue;&#125; 属性选择器在为不带有 class 或id的表单设置样式时特别有用，如设置表单的样式 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;input[type="text"]&#123; width:150px; display:block; margin-bottom:10px; background-color:yellow; font-family: Verdana, Arial;&#125;input[type="button"]&#123; width:120px; margin-left:35px; display:block; font-family: Verdana, Arial;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form name="input" action="" method="get"&gt;&lt;input type="text" name="Name" value="Bill" size="20"&gt;&lt;input type="text" name="Name" value="Gates" size="20"&gt;&lt;input type="button" value="Example Button"&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 如何插入一个样式表外部样式表个页面使用 &lt;link&gt;标签链接到样式表。&lt;link&gt;标签在（文档的）头部： 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;&lt;/head&gt; 内部样式表当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 &lt;style&gt;标签在文档头部定义内部样式表，就像这样: 1234567&lt;head&gt;&lt;style type="text/css"&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125; body &#123;background-image: url("images/back40.gif");&#125;&lt;/style&gt;&lt;/head&gt; 内联样式当样式仅需要在一个元素上应用一次时。 123&lt;p style="color: sienna; margin-left: 20px"&gt;This is a paragraph&lt;/p&gt; 注意：如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。相同的时候按优先级来选择继承。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html语法熟悉]]></title>
    <url>%2F2019%2F05%2F23%2FHtml%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Html基础Html 标题Heading是通过 &lt;h1&gt; - &lt;h6&gt; 等标签进行定义的 12&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;h2&gt;This is a heading&lt;/h2&gt; Html段落它是通过 &lt;p&gt;标签进行定义的 1&lt;p&gt;This is a paragraph.&lt;/p&gt; Html折行通过&lt;br/&gt;实现折行 1&lt;p&gt;This is&lt;br /&gt;a para&lt;br /&gt;graph with line breaks&lt;/p&gt; Html水平线是通过&lt;hr/&gt;用于在页面中创建水平线 12&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;hr/&gt; Html链接1&lt;a href="http://www.w3school.com.cn"&gt;This is a link&lt;/a&gt; Html图像通过&lt;img&gt;标签进行定义的，可以定义它的大小，位置等，还有一个代替文本 1&lt;img src="w3school.jpg" width="104" height="142" alt="Big Boat"&gt; Html元素是从开始标签到结束标签的所有代码。 12345&lt;html&gt;&lt;body&gt;&lt;p&gt;This is my first paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 以上实例就是有三个元素，&lt;html&gt;元素，&lt;body&gt; 元素，&lt;p&gt;元素。对应的元素内容就是body元素，p元素和This is my first paragraph。 Html属性可以给Html元素提供更多的信息，并且属性总是在 Html元素的开始标签中规定。比方说它可以定义这个元素在哪个位置呈现，背景颜色是什么，是否加个链接，样式是什么这些的。列一点： 属性 值 描述 class classname 规定元素的类名（classname） id id 规定元素的唯一 id style style_definition 规定元素的行内样式（inline style） title text 规定元素的额外信息（可在工具提示中显示） 注意Html的style属性可以直接使用 style 属性直接将样式添加到 HTML元素，也可以间接地在独立的样式表中（CSS 文件）进行定义。比方说设置一下字体，大小，颜色等： 12345&lt;html&gt;&lt;body&gt;&lt;p style=&quot;font-family:arial;color:red;font-size:20px;&quot;&gt;A paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Html文本格式化对应标签： 标签 描述 &lt;b&gt; 定义粗体文本。 &lt;big&gt; 定义大号字。 &lt;i&gt; 定义斜体字。 &lt;small&gt; 定义小号字。 &lt;strong&gt; 定义加重语气。 &lt;sub&gt; 定义下标字。 &lt;sup&gt; 定义上标字。 &lt;ins&gt; 定义插入字。 Html引用是通过&lt;q&gt;元素定义短的引用， &lt;blockquote&gt;元素定义被引用的节且会进行缩进处理。 Html缩进利用&lt;abbr&gt; 。 Html&lt;address&gt;元素定义文档或文章的联系信息（作者/拥有者）。且此元素通常以斜体显示。大多数浏览器会在此元素前后添加折行。 Html的计算机代码格式对于计算机代码格式利用&lt;kbd&gt;（定义键盘输入）, &lt;samp&gt;（定义计算机输出示例）, &lt;pre&gt;（定义预格式化文本）以及 &lt;code&gt;（定义计算机代码文本）元素，如： 1234567891011&lt;p&gt;Coding Example:&lt;/p&gt;&lt;code&gt;&lt;pre&gt;var person = &#123; firstName:"Bill", lastName:"Gates", age:50, eyeColor:"blue"&#125;&lt;/pre&gt;&lt;/code&gt; Html链接它的name属性，它规定了锚的名称，当使用命名锚时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接。如： 123456首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：&lt;a name="tips"&gt;基本的注意事项 - 有用的提示&lt;/a&gt;然后，我们可以在同一个文档中创建指向该锚的链接：&lt;a href="#tips"&gt;有用的提示&lt;/a&gt;也可以在其他页面中创建指向该锚的链接&lt;a href="http://www.w3school.com.cn/html/html_links.asp#tips"&gt;有用的提示&lt;/a&gt; Html列表： 标签 描述 &lt;ol&gt; 定义有序列表。 &lt;li&gt; 定义列表项。 &lt;ul&gt; 定义无序列表。 &lt;dl&gt; 自定义列表 &lt;dt&gt; 自定义项目 &lt;dd&gt; 自定义描述 Html的&lt;div&gt;元素它是一个块级元素(块级元素在浏览器显示时，通常会以新行来开始（和结束）)可用于组合其他Html元素的容器。 Html的类和布局对 HTML 进行分类（设置类），使我们能够为元素的类定义 CSS 样式。为相同的类设置相同的样式，或者为不同的类设置不同的样式。联合&lt;div&gt;理解，&lt;div&gt;把这个html分块了，有的块样式相同有的不相同就可以使用相同的类或者不同的类，如： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.cities &#123; background-color:black; color:white; margin:20px; padding:20px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="cities"&gt;&lt;h2&gt;London&lt;/h2&gt;&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;/div&gt;&lt;div class="cities"&gt;&lt;h2&gt;Paris&lt;/h2&gt;&lt;p&gt;Paris is the capital and most populous city of France.&lt;/p&gt;&lt;/div&gt;&lt;div class="cities"&gt;&lt;h2&gt;Tokyo&lt;/h2&gt;&lt;p&gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area,and the most populous metropolitan area in the world.&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 同理Html的 &lt;span&gt; 元素是行内元素，能够用作文本的容器。设置 &lt;span&gt;元素的类，能够为相同的&lt;span&gt;元素设置相同的样式。 布局的话就是Html和Css的联合使用了，利用Html语言对我们需要呈现的内容就行分块，然后Css对于这些分好的块填充样式，包括放哪。这样的结合之后就可以写出一个静态的页面了。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接下来三个月事情安排]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%8E%A5%E4%B8%8B%E6%9D%A5%E4%B8%89%E4%B8%AA%E6%9C%88%E4%BA%8B%E6%83%85%E5%AE%89%E6%8E%92%2F</url>
    <content type="text"><![CDATA[这次我选择去深圳，做一个前端的实习，前端对于我来说是一个很陌生的环境，其实想去找后台的工作，但我对于后台也不是很熟悉，只是对语言熟悉一些，具体的业务和开发流程熟悉的不够，所以我想多尝试一下。除了项目上的更多的熟悉，基础的知识方面也不能忘，这是对自己的要求，好好准备三个月冲刺一下准备秋招。不让任何人失望，不让自己最后觉得自己没有拼尽全力。加油，自己！ 打算完成的事情（不断更新）： 1.实习时候前端安排到的学习任务，项目任务。在步入正轨的时候尝试的去接触一下后台开发 2.SpringBoot学习，花一个月的时间把牛客高级项目课的内容搞定，理解的那种，所有的内容记录好博客。（这玩意等到自己熟悉了前端的这块内容之后再去看） 3.计算机网络自定向下，主要是传输层那块的内容，网络编程，学习内容记录 4.操作系统设计与实现，熟悉进程线程的那块 5.高性能Mysql，redis，牛客网的sql题，特别是数据库的索引那块内容 6.Java语言和JavaScript语言的熟悉，用Java语言去刷LeetCode，保持自己的做题能力，每天完成5道简单题，2-3进阶题，记录自己的结题思路。（做题数这块要改一下，还是和SpringBoot学习一样，现在一天做个一两道等到步入正轨的时候开始按计划完成一定的数量） 7.看一些之前自己没看的文学书：围城，我们仨，充实一下自己内心，改一下自己急躁的性格 8.关注助理的事情，把最后几个月的学生工作做好结尾]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>安排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理机调度和死锁]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[概念在多道程序环境下，进程数目往往多于处理机数目，致使它们竞争使用处理机。这就要求系统能按某种算法，动态地把处理机分配给就绪队列中的一个进程，使之执行。一个作业从提交开始，往往要经历三级调度：高级调度、中级调度、低级调度。 高级调度：调度对象是作业。 中级调度：提高内存利用率和系统吞吐量。 低级调度：它所调度的对象是进程。进程调度是最基本的一种调度。进程调度方式有两种调度方式：非抢占方式和抢占方式（基于优先权，短作业优先，时间片原则）。 作业调度和进程调度的区别作业调度为进程活动做准备，进程调度使进程活动起来 作业调度次数少，进程调度次数多 有的系统不设作业调度，但进程调度必不可少 进程调度算法FCFS先来先服务该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。FCFS 算法比较有利于长作业(进程)，而不利于短作业(进程)。 短作业优先短作业优先调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。 高优先权优先调度算法（动态优先权）动态优先级调度算法是指在创建进程之初，先赋予其一个优先级，然后其值随着进程的推进或等待时间的增加而改变，以便获得更好的调度性能。例如，可以规定在就绪队列中的进程随其等待的时间的正常，使其优先级相应提高。若所有的进程都具有相同的优先级初值，则最先进入就绪队列的进程会因为其优先级变得最高，而优先获得处理机，这相当于FCFS算法。若所有的就绪进程具有各不相同的优先级初值，那么对于优先级初值低的进程，在等待了足够的时间后，也可以获得处理机。 基于时间片的轮转调度算法在分时系统中，为保证能及时响应用户的请求，必须采用基于时间片的轮转式进程调度算法。每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。 死锁产生死锁原因竞争资源（多个进程竞争共享的资源），进程间推进顺序非法（进程请求和释放的资源顺序不当） 产生死锁的条件互斥条件，请求和保持条件，不剥夺条件，环路等待条件。 处理死锁的几种条件预防死锁，避免死锁，检测死锁，解除死锁。 银行家算法它是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。 安全序列是指一个进程序列{P1，…，Pn}是安全的，即对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。（即在分配过程中，不会出现某一进程后续需要的资源量比其他所有进程及当前剩余资源量总和还大的情况）注：存在安全序列则系统是安全的，如果不存在则系统不安全，但不安全状态不一定引起死锁。 原理过程：系统给当前进程分配资源时，先检查是否安全：在满足当前的进程X资源申请后，是否还能有足够的资源去满足下一个距最大资源需求最近的进程（如某进程最大需要5个单位资源，已拥有1个，还尚需4个），若可以满足，则继续检查下一个距最大资源需求最近的进程，若均能满足所有进程，则表示为安全，可以允许给当前进程X分配其所需的资源申请，否则让该进程X进入等待。（注：检查过程中，每拟满足一个进程，则进行下个检查时，当前可用资源为回收上一个进程资源的总值，每满足一个进程表示此进程已结束，资源可回收。） 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;string&gt;using namespace std;const int maxnsource = 100;const int maxnprocess = 50;int available[maxnsource];//可以使用的资源。int max[maxnprocess][maxnprocess];//最大需求矩阵。int allocation[maxnprocess][maxnprocess];//已经分配的矩阵。int need[maxnprocess][maxnprocess];//还需要的矩阵。int requestsource[maxnprocess][maxnprocess];//进程请求的矩阵。int finish[maxnprocess];//进程是否能得到足够的资源使其结束。int n, m;int i, j;int p[maxnsource];//记录进程号int safe()//判断是否为安全的&#123; int cnt = 0; int flag = 0; int temp[maxnsource]; for (i = 0; i &lt; n; i++) temp[i] = available[i]; for (i = 0; i &lt; m; i++) &#123; if (finish[i] == 0) &#123; for (j = 0; j &lt; n; j++) &#123; if (need[i][j] &gt; temp[j]) break; &#125; if (j == n) &#123; finish[i] = 1; for (int k = 0; k &lt; n; k++) temp[k] += allocation[i][k]; p[cnt++] = i; i = -1;//这里不是0,重置之后i++会变为1，就错了。 &#125; else continue; if (cnt == m) &#123; cout &lt;&lt; "系统是安全的" &lt;&lt; endl; cout &lt;&lt; "安全序列:" &lt;&lt; endl; for (i = 0; i&lt;cnt; i++) &#123; cout &lt;&lt; p[i]; if (i != cnt - 1) &#123; cout &lt;&lt; "--&gt;"; &#125; &#125; cout &lt;&lt; "" &lt;&lt; endl; return 1; &#125; &#125; &#125; cout &lt;&lt; "系统是不安全的" &lt;&lt; endl; return 0;&#125;void bank()//银行家算法&#123; int cur; while (1) &#123; cout &lt;&lt; "输入要申请资源的进程号" &lt;&lt; endl; cin &gt;&gt; cur; cout&lt;&lt; "输入进程所请求的各资源的数量" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) cin &gt;&gt; requestsource[cur][i]; for (int i = 0; i &lt; n; i++) &#123; if (requestsource[cur][i] &gt; need[cur][i]) &#123; cout &lt;&lt; "输入的请求数超过进程的需求量!请重新输入!" &lt;&lt; endl; continue; &#125; if (requestsource[cur][i] &gt; available[i]) &#123; cout &lt;&lt; "输入的请求数超过系统有的资源数!请重新输入!" &lt;&lt; endl; continue; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; available[i] -= requestsource[cur][i]; allocation[cur][i] += requestsource[cur][i]; need[cur][i] -= requestsource[cur][i]; &#125; for (int i = 0; i &lt; m; i++) finish[i] = 0; if (safe()) &#123; cout &lt;&lt; "同意分配请求!" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "您的请求被拒绝!" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; available[i] += requestsource[cur][i]; allocation[cur][i] -= requestsource[cur][i]; need[cur][i] += requestsource[cur][i]; &#125; for (int i = 0; i &lt; m; i++) finish[i] = 0; string s; cout &lt;&lt; "是否还想再次请求分配吗?如果想，请输入YES" &lt;&lt; endl; cin &gt;&gt; s; if (s == "YES") continue; else break; &#125; &#125;&#125;int main()&#123; memset(finish, 0, sizeof(finish)); cout &lt;&lt; "输入进程的数量:"; cin &gt;&gt; m; cout &lt;&lt; "输入资源的种类:"; cin &gt;&gt; n; cout &lt;&lt; "输入每个进程最多所需要的资源数："; for (i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; max[i][j]; cout &lt;&lt; "输入每个进程已经分配的资源数："; for (i = 0; i &lt; m; i++) &#123; for (j = 0; j &lt; n; j++) &#123; cin &gt;&gt; allocation[i][j]; need[i][j] = max[i][j] - allocation[i][j]; if (need[i][j] &lt; 0) &#123; cout &lt;&lt; "输入的第" &lt;&lt; i + 1 &lt;&lt; "个进程所拥有的第" &lt;&lt; j + 1 &lt;&lt; "个资源数 错误,请重新输入:" &lt;&lt; endl; j--; continue; &#125; &#125; &#125; cout &lt;&lt; "输入各资源现有的资源数："; for (i = 0; i &lt; n; i++) cin &gt;&gt; available[i]; /*for (i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; max[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125; for (i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; allocation[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125; for (i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; need[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125;*/ safe(); bank(); return 0;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程]]></title>
    <url>%2F2019%2F05%2F22%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概念与区别从本质上来说，一个进程就是一个正在执行的程序，它是系统进行资源分配和调度的基本单位，是操作系统结构的基础。每个进程都有自己的地址空间，包括可执行程序，程序的数据，栈，一组寄存器（程序计算器，栈指针以及其他运行程序需要的信息 线程有时被称为轻量级进程，是程序执行的最小执行流，它是进程的一个实体，是系统独立调度和分派的基本单位 进程和线程的区别： 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。 资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程 执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 线程是处理器调度的基本单位，但是进程不是。 两者均可并发执行。 进程进程的创建和终止进程的创建主要有四个原因：系统初始化，正在运行的进程执行了创建进程的系统调用，用户请求创建一个进程以及批处理作业的初始化。 常见的就是一个进程调用了fork()函数创建新的进程。 进程终止的一些原因：工作完成正常退出，出错退出，严重错误，被其他进程杀死。 进程的状态和控制原语进程有三种状态：运行态，阻塞态，就绪态。这三种状态的转换是： 就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。 阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。 运行：当一个进程在处理机上运行时，则称该进程处于运行状态。 注意不可能存在直接从阻塞态转换到执行态。 除了这三个基本状态还有一个挂起状态，新建状态，终止状态。 引起挂起状态的原因：终端用户的请求，父进程请求，负荷调节的需要，操作系统的需要。 用于控制进程的原语有： 创建原语（Create）：创建一个就绪状态的进程，使进程从创建状态变迁为就绪状态。 阻塞原语（Block）：使进程从执行状态变迁为阻塞状态。 唤醒原语（Wakeup）：使进程从阻塞状态变迁为就绪状态。 挂起原语（Suspend）：将指定的进程或处于阻塞的进程挂起 Java的Runnable状态与操作系统中进程运行状态的关系RUNNABLE 状态对应了传统的 ready，running 以及部分的 waiting状态，也就是上面的三种状态，但是操作体系中其实是有五种状态的。 进程间通信每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。 管道管道是由调用pipe函数来创建 1234#include &lt;unistd.h&gt;int pipe (int fd[2]);//返回:成功返回0，出错返回-1 // fd参数返回两个文件描述符,fd[0]指向管道的读端,fd[1]指向管道的写端。fd[1]的输出是fd[0]的输入。 实现进程通信的方式 父进程创建管道，得到两个⽂件描述符指向管道的两端 父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。 父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。 管道读取数据的几种情况： 读端不读，写端一直写 写端不写，但是读端一直读 读端一直读，且fd[0]保持打开，而写端写了一部分数据不写了，并且关闭fd[1]。 读端读了一部分数据，不读了且关闭fd[0]，写端一直在写且fd[1]还保持打开状态。 对应的处理： 如果一个管道的写端一直在写，而读端的引⽤计数是否⼤于0决定管道是否会堵塞，引用计数大于0，只写不读再次调用write会导致管道堵塞； 如果一个管道的读端一直在读，而写端的引⽤计数是否⼤于0决定管道是否会堵塞，引用计数大于0，只读不写再次调用read会导致管道堵塞； 而当他们的引用计数等于0时，只写不读会导致写端的进程收到一个SIGPIPE信号，导致进程终止，只写不读会导致read返回0,就像读到⽂件末尾⼀样。 管道的特点： 管道只允许具有血缘关系的进程间通信，如父子进程间的通信。 管道只允许单向通信。 管道内部保证同步机制，从而保证访问数据的一致性。 面向字节流 管道随进程，进程在管道在，进程消失管道对应的端口也关闭，两个进程都消失管道也消失。 信号量信号量本质上是一个计数器（不设置全局变量是因为进程间是相互独立的，而这不一定能看到，看到也不能保证++引用计数为原子操作）,用于多进程对共享数据对象的读取，它和管道有所不同，它不以传送数据为主要目的，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。 工作原理： 由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的： P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行 V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1. 在信号量进行PV操作时都为原子操作（单条指令的执行是不会被打断的，因为它需要保护临界资源） 与信号量相关的函数： 12345678910// 创建信号量,返回:成功返回信号集ID，出错返回-1int semget(key_t key,int nsems,int flags)// 删除和初始化信号量int semctl(int semid, int semnum, int cmd, ...);// 改变信号量的值int semop(int semid, struct sembuf *sops, size_t nops);// 对应的参数的含义：https://blog.csdn.net/skyroben/article/details/72513985 消息队列消息队列是消息的链接表，存放在内核中并由消息队列标识符标识。 用户可以从消息队列中读取数据和添加消息，其中发送进程添加消息到队列的末尾，接收进程在队列的头部接收消息，消息一旦被接收，就会从队列中删除。 消息队列常用的一些函数有： msgget创建或者打开消息队列， msgsnd添加消息， msgrcv读取消息， msgctl 控制消息队列， ftok由于文件路径工程ID生成的标准key。 共享内存共享内存就是允许两个或多个进程共享一定的存储区。就如同malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。因为数据不需要在客户机和服务器端之间复制，数据直接写到内存，不用若干次数据拷贝。 但是共享内存没有任何的同步与互斥机制，所以要使用信号量来实现对共享内存的存取的同步 共享内存的涉及到的函数： 12345// 创建共享内存,成功返回共享内存的ID,出错返回-1 int shmget(key_t key, size_t size, int shmflg);// 操作共享内存,成功返回0，出错返回-1int shmctl(int shm_id, int cmd, struct shmid_ds *buf); 共享内存优缺点： 优点：我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。 缺点：共享内存没有提供互斥同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段比如信号量等来进行进程间的同步工作。 为什么需要进程间通信进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信 进程间通信的目的： 数据传输：一个进程需要将它的数据发送给另一个进程。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 线程间通信同步指多个线程通过Synchronized关键字这种方式来实现线程间的通信。 比方说由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了通信。 这种方式，本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。 while轮询的方式参考：Java多线程通信方式 wait/notify机制通过进程调用对应的函数，通知对应另外的线程从而实现线程的通信。 比方说当条件未满足时，线程A调用wait()放弃CPU，并进入阻塞状态，当条件满足时，线程B调用 notify()通知线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。 进程同步进程同步是一个操作系统级别的概念,是在多道程序的环境下，存在着不同的制约关系，为了协调这种互相制约的关系，实现资源共享和进程协作，从而避免进程之间的冲突，引入了进程同步。 比如说进程A需要从缓冲区读取进程B产生的信息，当缓冲区为空时，进程B因为读取不到信息而被阻塞。而当进程A产生信息放入缓冲区时，进程B才会被唤醒。 临界资源 在操作系统中，进程是占有资源的最小单位，但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。典型的临界资源比如物理上的打印机 对于临界资源的访问，必须是互诉进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。 对于临界区的访问过程分为四个部分： 进入区:查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞 临界区:在临界区做操作 退出区:清除临界区被占用的标志 剩余区：进程与临界区不相关部分的代码 进程互斥进程互斥是进程之间的间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待。只有当使用临界资源的进程退出临界区后，这个进程才会解除阻塞状态。 比如进程 B 需要访问打印机，但此时进程 A 占有了打印机，进程 B 会被阻塞，直到进程 A 释放了打印机资源,进程B 才可以继续执行。 实现临界区互斥的基本方法 通过硬件实现临界区最简单的办法就是关 CPU 的中断 信号量实现：常见的 P，V 操作 进程同步与进程通信区别 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语法熟悉二]]></title>
    <url>%2F2019%2F05%2F22%2FJs%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%891%2F</url>
    <content type="text"><![CDATA[JavaScript输出使用window.alert()12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;window.alert(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用innerHTML写入Html元素如需访问 HTML 元素，JavaScript 可使用 document.getElementById(id) 方法。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt; document.getElementById(&quot;demo&quot;).innerHTML = 5 + 6;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; console.log()写入控制台12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;console.log(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用document.write()写入Html元素12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;document.write(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 但是在 HTML 文档完全加载后使用 document.write()将删除所有已有的 HTML，所以只用于测试 什么时候产生NaN表达式计算一个表达式中如果有减号 (-)、乘号 (*) 或 除号 (/) 等运算符时，JS 引擎在计算之前，会试图将表达式的每个分项转化为 Number 类型（使用 Number(x) 做转换）。如果转换失败，表达式将返回 NaN 。 123456100 - '2a' ; // NaN'100' / '20a'; // NaN'20a' * 5 ; // NaNundefined - 1; // NaN, Number(undefined) == NaN[] * 20 ; // 0, Number([]) == 0null - 5; // -5, Number(null) == 0 类型转换直接使用 parseInt，parseFloat 或 Number 将一个非数字的值转化为数字时，表达式返回 NaN ,但是对于 数字+字符的值，其转化结果会有所不同，Number 转换的是整个值，而不是部分值；parseInt 和 parseFloat 只转化第一个无效字符之前的字符串。 另外，一元加操作符也可以实现与 Number 相同的作用。 ： 123456789101112'abc' - 3 // NaNparseInt('abc') // NaNparseFloat('abc') // NaNNumber('abc') // NaNNumber('123abc'); // NaNparseInt('123abc'); // 123parseInt('123abc45'); // 123parseFloat('123.45abc');// 123.45+ '12abc'; // NaN+ '123'; // 123+ '123.78'; // 123.78+ 'abc'; // NaN 三个标准对象DateDate对象用来表示日期和时间。Date常用的一些函数： 123456789101112131415var now = new Date();//获取系统当前时间now; now.getFullYear(); // 2019, 获得now这个Date的年份now.getMonth(); // 4, 获得now这个Date的月份，注意月份范围是0~11，4表示五月now.getDate(); // 22, 获得now这个Date的日期，表示24号now.getDay(); // 3, 获得now这个Date的星期几，表示星期三now.getHours(); // 18, 获得now这个Date的小时，24小时制now.getMinutes(); // 30, 获得now这个Date的分钟now.getSeconds(); // 22, 获得now这个Date的秒数now.getMilliseconds(); // 426, 获得now这个Date的毫秒数now.getTime(); // 1558521017632, 以number形式表示的时间戳，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数，时间戳可以精确地表示一个时刻，并且与时区无关var d = new Date(2015, 5, 19, 20, 15, 30, 123);//创建一个自己要求的Dated; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)var d = Date.parse('2015-06-24T19:49:22.875+08:00');//创建一个自己要求的Date的第二种方法d; // 1435146562875 注意 JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 Json首先Json是一种数据传输的格式。 其次把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串。对应的如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。 序列化是通过JSON.stringify(JavaScirpt的对象)来实现的。这个函数有三个参数，第一个就是我们要序列化的JavaScript的对象，第二个参数是用来控制如何筛选对象的键值，比方可以传函数，传要取出来的属性，第三个是控制的转换后的格式。如果我们还想要精确控制如何序列化一个对象的话如xiaoming，可以给xiaoming定义一个toJSON()的方法，直接返回JSON应该序列化的数据： 12345678910111213141516var xiaoming = &#123; name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\"W3C\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'], toJSON: function () &#123; return &#123; // 只输出name和age，并且改变了key： 'Name': this.name, 'Age': this.age &#125;; &#125;&#125;;JSON.stringify(xiaoming); // '&#123;"Name":"小明","Age":14&#125;' 反序列化是通过用JSON.parse()把它变成一个JavaScript对象，同时这个函数还可以接收一个函数作为参数，用来转换解析出的属性： 1234567var obj = JSON.parse('&#123;"name":"小明","age":14&#125;', function (key, value) &#123; if (key === 'name') &#123; return value + '同学'; &#125; return value;&#125;);console.log(JSON.stringify(obj)); // &#123;name: '小明同学', age: 14&#125; RegExp(待补)面向对象创建对象JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。形成一个原型链，当我们要访问一个对象的一个属性的时候，就会通过这个原型链查找，如果一直找到Object.prototype对象，都还没有找到，就只能返回undefined。 比方说我们创建了一个Array对象，我们可以得到其对应的原型链如下： 12var arr = [1, 2, 3];arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null 我们这个arr对象，能调用arr，Array.prototype，Object.prototype上定义的所有的方法。 构造函数，除了直接用{...}创建一个函数之外，还可以通过构造函数创建对象 123456789function Student(name) &#123; this.name = name; this.hello = function () &#123; alert('Hello, ' + this.name + '!'); &#125;&#125;var xiaoming = new Student('小明');xiaoming.name; // '小明'xiaoming.hello(); // Hello, 小明! 这是一个普通函数，但是在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象,注意，如果不写new，这就是一个普通函数，它返回undefined。 class继承在ES6开始引入了class这个概念，就很类似Java的class对象了，例如： 12345678class Student &#123; constructor(name) &#123;//构造函数 this.name = name; &#125; hello() &#123;//普通函数 alert('Hello, ' + this.name + '!'); &#125;&#125; 继承的话和Java也很像，利用extends关键字 123456789class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 错误处理错误捕获这个和Java也很像，利用try ... catch捕获。 如果代码发生了错误，又没有被try ... catch捕获，那么，程序执行流程会跳转到哪呢？如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。 利用try ... catch捕获错误1234567891011121314151617181920function main(s) &#123; console.log('BEGIN main()'); try &#123; foo(s); &#125; catch (e) &#123; console.log('出错了：' + e); &#125; console.log('END main()');&#125;function foo(s) &#123; console.log('BEGIN foo()'); bar(s); console.log('END foo()');&#125;function bar(s) &#123; console.log('BEGIN bar()'); console.log('length = ' + s.length); console.log('END bar()');&#125;main(null);]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative（一）]]></title>
    <url>%2F2019%2F05%2F22%2FReactNative%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[搭建第一个ReactNative项目环境要求需要Node，Python2，Jdk，Android Studio，Android SDK。 注：学会通过Chocolatey（一种流行的Windows程序包管理器）安装Node和Python2以及Jdk。 配置环境变量添加ANDROID_HOME 在Windows控制面板中的“ 系统和安全”下打开“系统”窗格，然后单击“ 更改设置…”。打开“ 高级”选项卡，然后单击“ 环境变量…”。单击New …以创建ANDROID_HOME指向Android SDK路径的新用户变量 将平台工具添加到Path 在Windows控制面板中的“ 系统和安全”下打开“系统”窗格，然后单击“ 更改设置…”。打开“ 高级”选项卡，然后单击“ 环境变量…”。选择Path变量，然后单击“ 编辑”。单击“ 新建”，将平台工具的路径添加到列表中。 此文件夹的默认位置是： 1c:\Users\YOUR_USERNAME\AppData\Local\Android\Sdk\platform-tools 跑Demo利用cmd命令行界面生成一个名为AwesomeProject的新React Native项目 1react-native init AwesomeProject 利用Android Studio打开这个项目，并跑好虚拟机。 然后在命令行运行 12cd AwesomeProjectreact-native run-android 如果设置都是正确的话，你就能得到以下界面：（这样的话第一个demo就跑通了，要修改的话就在App.js文件修改即可，刷新的话使用ctrl+m或者双击RR 基础知识简单的组件介绍学习过Html的话会熟悉很多，ReactNative提供很多的内置组件像&lt;Text&gt;，&lt;View&gt;，&lt;Button&gt;这些，当然你也可以自己定义自己的组件，如下，这样的话我们就定义好了自己的组件Greeting。 123456789class Greeting extends Component&#123; render()&#123; return ( &lt;View style=&#123;styles.instructions&#125;&gt; &lt;Text&gt; Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 大多数组件在创建时可以使用不同的参数进行自定义。调用这些创建参数props。 比方说利用组件Image创建图像，可以使用命名的道具source来控制它显示的图像。 12345678910111213141516import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render() &#123; let pic=&#123; uri : 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg' &#125;; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt;Hello World!&lt;/Text&gt; &lt;Image source=&#123;pic&#125; style=&#123;styles.iamge1&#125;/&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 这个是内置组件自带的道具，那么要是我们自己定义的组件的话想用props也是可以的。如下 自己定义的组件，通过在下面组件的调用的时候传入参数，利用this.props来调用显示。道具的概念就是对于组件使用不同的参数进行自定义的操作。像正常组件Text调用的style，Image调用source的这些都是道具也就是props。（个人感觉把道具和props连在一起理解会好一些） 1234567891011121314151617181920212223import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';class Greeting extends Component&#123; render()&#123; return ( &lt;View style=&#123;styles.instructions&#125;&gt; &lt;Text&gt; Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default class App extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center', top: 50&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 对于每个组件的话是有两个控制组件的参数：props和state。props由父项设置，它们在组件的整个生命周期内都是固定的。对于即将发生变化的数据，我们必须使用state，利用setstate来重新渲染。假设我们想要制作一直闪烁的文本的话代码如下： 123456789101112131415161718192021222324252627282930313233import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';class Greeting extends Component&#123; constructor(props)&#123; super(props); this.state= &#123;isShowingText :true&#125;; setInterval(() =&gt; ( this.setState(previousState =&gt; ( &#123;isShowingText: !previousState.isShowingText&#125; )) ),1000); &#125; render()&#123; if(!this.state.isShowingText)&#123; return null; &#125; return( &lt;Text&gt;&#123;this.props.name&#125;&lt;/Text&gt; ); &#125;&#125;export default class App extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center', top: 50&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 但是在实际应用中，会调用Redux或者Mobx等状态容器来控制数据流。（还没用过，口嗨一下） 样式和组件大小所有核心组件都接受名为的道具style，就是当一个组件需要写的道具过多的时候，就用样式来代替它。如下：（复制下教程的代码，自己写的因为堆积内容过多） 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View &#125; from 'react-native';const styles = StyleSheet.create(&#123; bigBlue: &#123; color: 'blue', fontWeight: 'bold', fontSize: 30, &#125;, red: &#123; color: 'red', &#125;,&#125;);export default class LotsOfStyles extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt; &lt;Text style=&#123;styles.bigBlue&#125;&gt;just bigBlue&lt;/Text&gt; &lt;Text style=&#123;[styles.bigBlue, styles.red]&#125;&gt;bigBlue, then red&lt;/Text&gt; &lt;Text style=&#123;[styles.red, styles.bigBlue]&#125;&gt;red, then bigBlue&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; LotsOfStyles); 组件大小的话是用width和height样式来控制的 1234567891011121314import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, View &#125; from 'react-native';export default class FixedDimensionsBasics extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 100, height: 100, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 150, height: 150, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; FixedDimensionsBasics); 利用Flexbox进行布局和Flex尺寸组件可以使用Flexbox算法指定其子项的布局，常用flexDirection，alignItems以及justifyContent。不同的又有一些对应的参数值 1234567891011121314import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render()&#123; return( &lt;View style=&#123;&#123;flex: 1,flexDirection: 'column',justifyContent: 'flex-end'&#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;flex: 2, height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;flex: 3, height: 50, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 我们看到第一个View有个flex的参数设置为1，它告诉组件填充所有可用空间，在具有相同父级的其他组件之间平均共享。孩子所占用的分量根据孩子的flex值进行相比分配，但是注意如果组件的父级具有大于0的维度，则组件只能展开以填充可用空间。如果父组件没有固定的width和height或flex，则父组件的维度为0，flex子组件将不可见。也就是如果父组件的flex为0了，或者只给了width或者heigth它的子组件是没办法显示的。 处理文本输入和处理接触文本输入利用TextInput组件，它是一个允许用户输入文本的基本组件，它有onChangeText和onSubmitEditing这两个props。假设用户键入时，您将其单词翻译成其他语言。在这种新语言中，每个单词用$$$代替。（还不是很理解和这个函数的写法，后续学习补一下） 1234567891011121314151617181920212223import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; constructor(props)&#123; super(props); this.state= &#123;text: ''&#125;; &#125; render()&#123; return( &lt;View style=&#123;&#123;padding:10&#125;&#125;&gt; &lt;TextInput style=&#123;&#123;height: 40&#125;&#125; placeholder="Type here to translate!" onChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125; /&gt; &lt;Text style=&#123;&#123;padding: 10,fontSize: 42&#125;&#125;&gt; &#123;this.state.text.split(' ').map((word) =&gt; word &amp;&amp; '$$$').join(' ')&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 处理接触的话是利用Button这个组件还有一些处理常见的手势组件（没看），简单看一下接触的处理。可触摸的组件有多种返回类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; onPressButton()&#123; Alert.alert('you tapped the button'); &#125; onLongPresssButton()&#123; Alert.alert('you press the button longer'); &#125; render()&#123; return( &lt;View style=&#123;styles.container&#125;&gt; //当用户按下按钮时，视图的背景将变暗。 &lt;TouchableHighlight onPress=&#123;this.onPressButton&#125; underlayColor='white'&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableHighlight&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; //通过降低按钮的不透明度来提供反馈，从而允许在用户按下时看到背景 &lt;TouchableOpacity onPress=&#123;this.onPressButton&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableOpacity&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; //显示响应用户触摸的墨水表面反应涟漪 &lt;TouchableNativeFeedback onPress=&#123;this.onPressButton&#125; background=&#123;Platform.OS === 'android' ? TouchableNativeFeedback.SelectableBackground() : ''&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableNativeFeedback&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableNativeFeedback&gt; //处理点击手势但不希望显示任何反馈 &lt;TouchableWithoutFeedback onPress=&#123;this.onPressButton&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableWithoutFeedback&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableWithoutFeedback&gt; //在之前的视图变暗的基础上加上了一个长按的操作 &lt;TouchableHighlight onPress=&#123;this.onPressButton&#125; onLongPress=&#123;this.onLongPresssButton&#125; underlayColor="white"&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Touchable with Long Press&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 滚动条和列表视图ScrollView一个通用的滚动容器，可以放置多个component或者 views，通过参数控制是横着还是竖着。 123456789101112131415161718192021222324import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; //实现一个界面放两个滚动条 render() &#123; render() &#123; return ( &lt;View&gt; &lt;ScrollView horizontal&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Scroll me plz&lt;/Text&gt; &lt;/ScrollView&gt; &lt;ScrollView&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;If you like&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Scrolling down&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;What's the best&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Framework around?&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:80&#125;&#125;&gt;React Native&lt;/Text&gt; &lt;/ScrollView&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); React Native提供了一套用于显示数据列表的组件：FlatList和SectionList。列表视图最常见的用途之一是显示从服务器获取的数据。 FlatList组件显示一个滚动列表，它唯一呈现当前在屏幕上显示的元素，而不是一次显示所有元素。它有两个道具：data和renderItem。data是列表的信息来源。renderItem从源中获取一个项目并返回要呈现的格式化组件。 12345678910111213141516171819202122232425import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render()&#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123;[ &#123;key: 'Devin'&#125;, &#123;key: 'Jackson'&#125;, &#123;key: 'James'&#125;, &#123;key: 'Joel'&#125;, &#123;key: 'John'&#125;, &#123;key: 'Jillian'&#125;, &#123;key: 'Jimmy'&#125;, &#123;key: 'Julie'&#125;, ]&#125; //renderItem这个不是很懂，看懂了再解释 renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item.key&#125;&lt;/Text&gt;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 如果将一组数据分解为逻辑部分，可能使用部分标题，那么就使用SectionList 1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, SectionList, StyleSheet, Text, View &#125; from 'react-native';export default class SectionListBasics extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;SectionList sections=&#123;[ &#123;title: 'D', data: ['Devin']&#125;, &#123;title: 'J', data: ['Jackson', 'James', 'Jillian', 'Jimmy', 'Joel', 'John', 'Julie']&#125;, ]&#125; renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item&#125;&lt;/Text&gt;&#125; renderSectionHeader=&#123;(&#123;section&#125;) =&gt; &lt;Text style=&#123;styles.sectionHeader&#125;&gt;&#123;section.title&#125;&lt;/Text&gt;&#125; keyExtractor=&#123;(item, index) =&gt; index&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, paddingTop: 22 &#125;, sectionHeader: &#123; paddingTop: 2, paddingLeft: 10, paddingRight: 10, paddingBottom: 2, fontSize: 14, fontWeight: 'bold', backgroundColor: 'rgba(247,247,247,1.0)', &#125;, item: &#123; padding: 10, fontSize: 18, height: 44, &#125;,&#125;)AppRegistry.registerComponent('AwesomeProject', () =&gt; SectionListBasics);]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语法熟悉一]]></title>
    <url>%2F2019%2F05%2F21%2FJs%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Js基本语法在哪里引入Js代码？1）首先JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到&lt;head&gt;中，我们看到网页的源码的时候被&lt;script&gt;...&lt;/script&gt;包含的代码就是JavaScript代码，它会直接被浏览器执行。 2）单独的写一个 .js文件，然后在HTML中通过&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;引入这个文件。这样的话是方便多个网页应用到了同一份Js文件。 数据类型，运算符以及变量的申明1）Js的数据类型主要有Number，布尔值，字符串。JavaScript不区分整数和浮点数，统一用Number表示。 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity Number可以直接做四则运算，规则和数学一致。 注意一个点：字符串也可以使用加号，但是字符串将被级联但是注意字符串和数字相加会返回一个字符串，例如： 1234var x = "8" + 3 + 5;//输出结果：835var x = 3 + 5 + "8";//输出结果88 布尔值的话只能有false，true两种。 字符串的话就跟Java，c++的都差不多，不过JavaScript中以单引号’或双引号”括起来的任意文本都是字符串。 2）运算符：&amp;&amp;运算，||运算，!运算，比较运算符。基本上都差不多，但是要注意的是相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 通常的话我们是坚持使用===。 另外是NaN这个特殊的Number，它和其他所有的值都不相等，包括本身。唯一能判断NaN的方法是通过isNaN()函数。 3）变量的申明方式 变量名的要求：变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。 12345678910var age = 15;var arr = [1, 2, 3.14, 'Hello', null, true];//JavaScript的数组可以包括任意数据类型var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;;//申明JavaScript的对象，它是由键-值组成的无序集合，引用的话和Java差不多，用对象变量.属性名的方式 同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，注意在JavaScript中通过赋值可以修改变量的数据类型，JavaScript是一个动态的语言。像Java这种静态的语言就不能这样的进行赋值。 注意：不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。 字符串在前面我们看到字符串就是用&#39;&#39;或&quot;&quot;括起来的字符。跟c++一样有转义字符，具体的熟悉一下就行。 通过+来连接字符串。 通过s.length来获取字符的长度 通过下标索引获取字符串某个指定位置的字符，索引号从0开始，需要注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果，如下： 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写： indexOf()会搜索指定字符串出现的位置（字符串第一个出现该字符的位置） substring()返回指定索引区间的子串 split()把字符串转换为数组 1234var txt = "a,b,c,d,e"; // 字符串txt.split(","); // 用逗号分隔txt.split(" "); // 用空格分隔txt.split("|"); // 用竖线分隔 数组和对象通过arr.length获取数组长度，直接给Array的length赋一个新的值会导致Array大小的变化如： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] 和字符串不同，数组可以通过下表索引修改对应的元素值。但是要是索引超过范围的话同样会导致数组大小的变化。 通过indexOf()来搜索一个指定的元素的位置（同字符串第一个出现该字符的位置） slice()截取Array的部分元素，然后返回一个新的Array push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉 往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉 sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置 reverse()把整个Array反转 splice()方法可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素 concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array，并不是修改当前的数组。 join()方法能把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。 练习：在新生欢迎会上，你已经拿到了新同学的名单，请排序后显示：欢迎XXX，XXX，XXX和XXX同学！： 1234'use strict';var arr = ['小明', '小红', '大军', '阿黄'];arr.sort();console.log(`欢迎$&#123;arr[0]&#125;,$&#123;arr[1]&#125;,$&#123;arr[2]&#125;和$&#123;arr[3]&#125;同学!`); JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,可以通过delete删除属性，赋值增加属性如： 1234567891011var xiaoming = &#123; name: '小明', score: null&#125;;xiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 利用in操作符检测是否拥有一个属性，但是注意所有对象最终都会在原型链上指向object，所以我们定义的对象都有object对象的属性，所以要判断一个属性是否是我们定义的对象拥有的，而不是继承得到的，可以用hasOwnProperty()方法 容器和一些控制语句条件判断if...else，这些都差不多，就是逻辑的判断。 练习：小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖 用if...else...判断并显示结果： 12345678910111213141516'use strict';var height = parseFloat(prompt('请输入身高(m):'));var weight = parseFloat(prompt('请输入体重(kg):'));var bmi=weight/height/height;if (bmi &lt; 18.5) &#123; console.log('过轻');&#125; else if (bmi &lt;= 25) &#123; console.log('正常');&#125; else if (bmi &lt; 28) &#123; console.log('过重');&#125; else if (bmi &lt; 32) &#123; console.log('肥胖');&#125; else &#123; console.log('严重肥胖');&#125; 循环也是一样利用for或者while或者do...while 练习: 利用for循环计算1 * 2 * 3 * ... * 10的结果： 123456789101112'use strict';var x = 1;var i;for (i=1;i&lt;=10;i++)&#123; x*=i;&#125;if (x === 3628800) &#123; console.log('1 x 2 x 3 x ... x 10 = ' + x);&#125;else &#123; console.log('计算错误');&#125; 请利用循环遍历数组中的每个名字，并显示Hello, xxx!： 12345678910111213'use strict';var arr = ['Bart', 'Lisa', 'Adam'];arr.sort(); // 正序//倒序arr.reverse();for(var i=0;i&lt;arr.length;i++)&#123; console.log(`Hello,$&#123;arr[i]&#125;`);&#125;var i=0;while(i&lt;arr.length)&#123; console.log(`Hello,$&#123;arr[i]&#125;`); i++;&#125; Map和Set容器 Map是一组键值对的结构，利用key和value。常用的函数有set，delete，get。用法都差不多。 set一组key的集合且不重复，常用的函数有delete，add。 iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for ... of循环来遍历。因为遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。如： 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 或者通过forEach()方法循环，forEach()有三个参数 1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，可以忽略。 Js 函数函数函数定义如下： 123456789101112131415function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;//或者另一种var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;;//注意这比上面多一个等号 JavaScript在调用参数的时候允许任意个参数调用，不管传多还是传少都不会报错。因此JavaScript提供了一个关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array，利用它可以判断传入参数的个数。 之后JavaScript又引入了rest参数，rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。如 1234567891011121314151617function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] 练习： 请用rest参数编写一个sum()函数，接收任意个参数并返回它们的和： 1234567891011121314151617181920212223242526'use strict';function sum(...rest) &#123; var arr = []; arr = rest; //获取所有的参数，以数组显示保存在arr数组中 var result = 0; for(var i = 0; i &lt; arr.length; i++)&#123; result = result + arr[i]; &#125; return result;&#125; // 测试:var i, args = [];for (i=1; i&lt;=100; i++) &#123; args.push(i);&#125;if (sum() !== 0) &#123; console.log('测试失败: sum() = ' + sum());&#125; else if (sum(1) !== 1) &#123; console.log('测试失败: sum(1) = ' + sum(1));&#125; else if (sum(2, 3) !== 5) &#123; console.log('测试失败: sum(2, 3) = ' + sum(2, 3));&#125; else if (sum.apply(null, args) !== 5050) &#123; console.log('测试失败: sum(1, 2, 3, ..., 100) = ' + sum.apply(null, args));&#125; else &#123; console.log('测试通过!');&#125; 定义一个计算圆面积的函数area_of_circle()，它有两个参数： r: 表示圆的半径； pi: 表示π的值，如果不传，则默认3.14 12345678910111213141516171819202122'use strict';function area_of_circle(r, pi) &#123; var area; if (arguments.length == 2) &#123; area = pi * r * r; &#125; else if (arguments.length &lt; 2)&#123; pi = 3.14; area = pi * r * r; &#125; else&#123; console.log("arguments number must be 1 or 2."); return ; &#125; return r * r * (pi || 3.14);&#125;// 测试:if (area_of_circle(2) === 12.56 &amp;&amp; area_of_circle(2, 3.1416) === 12.5664) &#123; console.log('测试通过');&#125; else &#123; console.log('测试失败');&#125; 函数变量作用域以及解析赋值在JavaScript中，用var申明的变量实际上是有作用域的。一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量，但是由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量。但是如果内部函数和外部函数的变量名重名的情况下在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。看样例： 1234567891011121314function foo() &#123; var x = 1; function bar() &#123; var x = 'A'; console.log('x in bar() = ' + x); // 'A' &#125; console.log('x in foo() = ' + x); // 1 bar();&#125;foo();/*结果为x in foo() = 1x in bar() = A*/ 而且JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部，也就是所有的变量都会在函数初步就定义了。 同时JavaScript默认有一个全局对象window，不在任何函数内定义的变量就具有全局作用域，全局作用域的变量实际上被绑定到window的一个属性。我们在之前说过函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象，其实我们每次直接调用的alert()函数其实也是window的一个变量。 所以JavaScript中任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。 因此在这个基础上，个人感觉引用了c++的using namespace std命名空间的概念，在JavaScript中有一个名字空间，因为全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，就会造成命名冲突，解决的方式就是把自己的所有变量和函数绑定到一个全局变量里面会减少全局变量冲突的几率。 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 解构赋值：在ES6后引入了这个解构赋值，直接对于多个变量同时赋值如： 1234567var [x, y, z] = ['hello', 'JavaScript', 'ES6'];// x, y, z分别被赋值为数组对应元素:console.log('x = ' + x + ', y = ' + y + ', z = ' + z);/*结果为x = hello, y = JavaScript, z = ES6*/根据数组的格式进行嵌套赋值，但是要注意嵌套层次和位置要保持一致 同理解构赋值也能对对象进行同样的操作如： 12345678910111213141516171819var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: &#123; city: 'Beijing', street: 'No.1 Road', zipcode: '100001' &#125;&#125;;var &#123;name, address: &#123;city, zip&#125;&#125; = person;name; // '小明'city; // 'Beijing'zip; // undefined, 因为属性名是zipcode而不是zip// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:address; // Uncaught ReferenceError: address is not defined//当然可以赋默认值避免了不存在的属性返回undefined的问题 方法和高阶函数在一个对象中绑定函数，那么就成为这个对象的方法，如 1234567891011var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 在函数内部this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性，但是我们要注意this这个指向，最好是在引用函数之前就把这个this给记录下来如that，然后在方法内定义其他的函数，用that去代替this；或者呢用aplpy函数去修复，apply它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。同样有个call函数。 一个很重要的点高阶函数： 什么叫高阶函数？高阶函数指最少满足下列条件之一的函数：函数可以作为参数传递，函数可以作为返回值输出。（理解的不够，再细致的理解再补） map/reduce函数：它们都是Array中定义的，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果，比方说我要得到一个数组中每个数的平方： 12345678'use strict';function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); //map()传入的参数是pow(),是函数本身console.log(results);// [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce函数的话是把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，实际能做的事情是对一个数组进行重复的处理，比方说求和，求积，如： 1234567891011121314’use strict';function product(arr) &#123; var ans=arr.reduce(function(x,y)&#123; return x*y; &#125;); return ans;&#125;// 测试:if (product([1, 2, 3, 4]) === 24 &amp;&amp; product([0, 1, 2]) === 0 &amp;&amp; product([99, 88, 77, 66]) === 44274384) &#123; console.log('测试通过!');&#125;else &#123; console.log('测试失败!');&#125; 把[1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场： 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x * 10 + y;&#125;); // 13579 练习： 不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数： 1234567891011121314151617181920212223'use strict';function string2int(s) &#123; var arr= []; for(let i=0;i&lt;s.length;i++) arr[i]=s[i]-'0'; var ans=arr.reduce(function (x, y) &#123; return x * 10 + y; &#125;); return ans;&#125;// 测试:if (string2int('0') === 0 &amp;&amp; string2int('12345') === 12345 &amp;&amp; string2int('12300') === 12300) &#123; if (string2int.toString().indexOf('parseInt') !== -1) &#123; console.log('请勿使用parseInt()!'); &#125; else if (string2int.toString().indexOf('Number') !== -1) &#123; console.log('请勿使用Number()!'); &#125; else &#123; console.log('测试通过!'); &#125;&#125;else &#123; console.log('测试失败!');&#125; 请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]，输出：[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]。 1234567891011121314'use strict';function normalize(arr) &#123; return arr.map(function(x) &#123; return x[0].toUpperCase() + x.substring(1).toLowerCase() &#125;);&#125;// 测试:if (normalize(['adam', 'LISA', 'barT']).toString() === ['Adam', 'Lisa', 'Bart'].toString()) &#123; console.log('测试通过!');&#125;else &#123; console.log('测试失败!');&#125; 小明希望利用map()把字符串变成整数，他写的代码很简洁： 123456'use strict';var arr = ['1', '2', '3'];var r;r = arr.map(parseInt);console.log(r);结果竟然是1, NaN, NaN，小明百思不得其解，请帮他找到原因并修正代码。 这个主要是parseInt的一些误区，后序会写篇来介绍这个，先暂时性看这个理解一下https://blog.csdn.net/wjl84945979/article/details/56478927 filter函数filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。类似一个筛选的功能，例如：在一个Array中，删掉偶数，只保留奇数 12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (element, index, self) &#123; return element% 2 !== 0;&#125;);r; // [1, 5, 9, 15] 看上面的调用filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身。 练习： 请尝试用filter()筛选出素数： 1234567891011121314151617181920212223242526272829303132333435'use strict';function get_primes(arr) &#123; var ans=arr.filter(function (element,index,self) &#123; if(element&lt;2 ) return false; else&#123; var flag=false; for(let i=2;i&lt;element;i++)&#123; if(element%i===0)&#123; flag=true; break; &#125; &#125; if(flag) return false; else return true; &#125; &#125;); return ans;&#125;// 测试:var x, r, arr = [];for (x = 1; x &lt; 100; x++) &#123; arr.push(x);&#125;r = get_primes(arr);if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) &#123; console.log('测试通过!');&#125; else &#123; console.log('测试失败: ' + r.toString());&#125;]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
</search>
