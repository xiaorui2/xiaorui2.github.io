<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HashMap,HashTable,CourrentHashMap]]></title>
    <url>%2F2019%2F06%2F24%2FHashMap-HashTable-CourrentHashMap%2F</url>
    <content type="text"><![CDATA[HashMap我们知道Map是一个 key-val 的集合，HashMap是基于Hash表的Map接口的非同步实现。HashMap的基本数据结构是数组和链表。 HashMap的存储原理和存储过程声明一个下标范围比较大的数组来存储元素，另外设计一个哈希函数获得每一个元素的Key（关键字）的函数值（即数组下标，hash值）相对应，数组存储的元素是一个Entry类，这个类有三个数据域，key、value（键值对），next(指向下一个Entry)。 当两个key通过哈希函数计算相同时，则发生了hash冲突(碰撞)，HashMap解决hash冲突的方式是用链表。 例如， 第一个键值对A进来。通过计算其key的hash得到的index=0。记做:Entry[0] = A。第二个键值对B，通过计算其index也等于0， HashMap会将B.next =A,Entry[0] =B,第三个键值对 C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方事实上存取了A,B,C三个键值对,它们通过next这个属性链接在一起。所以当hash冲突很多时，HashMap退化成链表。 存储过程： 先判断键值对数组table[i] 是否为空否则进行扩容操作（resize（））； 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加到最后一步，如果table[i]不为空进行下一步； 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则进行下一步，这里的相同指的是hashCode以及equals； 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则进行下一步； 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 HashMap取值过程： 先通过key值进行哈哈希函数的运算得到hash值； 调用getNode()，得到桶号； 在桶里面找元素和key值相等的即可，未找到返回空。 HashMap的初始化容量为什么为2的次幂？因为在get（）方法中，获得元素的位置是通过(length- 1) &amp; h 来得到的，其中 h:为插入元素的hashcode length:为map的容量大小。如果length为2的次幂 则length-1 转化为二进制必定是11111……的形式，在于h的二进制与操作效率会非常的快，而且空间不浪费。如果是其他的话，空间不够，碰撞的几率变大，查询变慢，空间会浪费。 为什么HashMap是非线程安全的？首先我们知道为了减少冲突，我们需要时刻留意当前的size是否太大，检查是否需要扩容，一旦超过设定的threshold，那么就要重新增大数组尺寸，此时所有元素都需要重新计算应该放置的下标。同时HashMap在扩容的时候，是通过重新创建一个新的hash表，把原来旧数组中的Entry一个个迁移到新数组的，注意一点就是计算在newTable中的位置，原来在同一条链上的元素可能被分配到不同的位置。 单线程的情况resize（）是没有问题的，但是多线程的时候就可能会出现形成环形链表的情况，导致扩容失败。具体详细的图可以看https://blog.csdn.net/andy_budd/article/details/81413464 HashMap和HashTable的区别：HashTable 是不能接受NULL，NULL值组合的，而HashMap可以。（因为HashMap做了对应的NULL值处理，会把NULL值的键值对放到hashcode 为0 的链表里面）。 HashTable是线程安全的，HashMap是线程非安全的。因为HashTable是synchronized，要想是HashMap线程安全Map m = Collections.synchronizeMap(hashMap).]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css盒模型，布局以及定位]]></title>
    <url>%2F2019%2F06%2F24%2FCss%E7%9B%92%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8A%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[盒模型什么是盒模型CSS盒模型是网页布局的基础 ——每个元素被表示为一个矩形的方框，框的内容、内边距、边界和外边距像洋葱的膜那样，一层包着一层构建起来。浏览器渲染网页布局时，它会算出每个框的内容要用什么样式，周围的洋葱层有多大，以及框相对于其它框放在哪里。 盒模型的属性文档的每个元素被构造成文档布局内的一个矩形框，框每层的大小都可以使用一些特定的CSS属性调整。相关属性如下: width 和 heightwidth和 height设置内容框（content box）的宽度和高度。内容框是框内容显示的区域——包括框内的文本内容，以及表示嵌套子元素的其它框。 还以为设置设置大小约束而不是绝对的大小。这些属性包括min-width，max-width，min-height，max-height。 paddingpadding 表示一个 CSS 框的内边距——这一层位于内容框的外边缘与边界的内边缘之间。该层的大小可以通过简写属性padding一次设置所有四个边，或者通过padding-top，padding-right，padding-left，padding-bottom属性一次设置一个边。 borderborder是一个分隔层，位于内边距的外边缘以及外边距的内边缘之间。边界的默认大小为0——从而让它不可见——不过我们可以设置边界的厚度、风格和颜色让它出现。 border简写属性可以一次设置四个边例如 border: 1px solid black;但这个简写可以被各种普通书写的更详细的属性所覆盖. margin外边距（margin）代表 CSS 框周围的外部区域，称为外边距，它在布局中推开其它 CSS 框。其表现与 padding 很相似；简写属性为margin，单个属性margin-top，margin-right，margin-left，margin-bottom。 外边距有一个特别的行为被称作：外边距塌陷，当两个框彼此接触时，它们的间距将取两个相邻外边界的最大值，而非两者的总和。 溢流当你使用绝对的值设置了一个框的大小（如，固定像素的宽/高），允许的大小可能不适合放置内容，这种情况下内容会从盒子溢流。我们使用overflow属性来控制这种情况的发生。它有一些可能的值，但是最常用的是： auto: 当内容过多，溢流的内容被隐藏，然后出现滚动条来让我们滚动查看所有的内容。 hidden: 当内容过多，溢流的内容被隐藏。 visible: 当内容过多，溢流的内容被显示在盒子的外边（这个是默认的行为） 背景裁剪框的背景是由颜色和图片组成的，它们堆叠在一起（background-color, background-image）。 它们被应用到一个盒子里，然后被画在盒子的下面。默认情况下，背景延伸到了边界外沿。这通常是OK的，但是在一些情况下假使你有一个平铺的背景图，你只想要它延伸到内容的边沿会怎么做？该行为可以通过设置盒子的background-clip属性来调整。 盒类型 块框（ block box）是定义为堆放在其他框上的框（例如：其内容会独占一行），而且可以设置它的宽高，之前所有对于框模型的应用适用于块框 （ block box） 行内框（ inline box）与块框是相反的，它随着文档的文字流动（例如：它将会和周围的文字和其他行内元素出现在同一行，而且它的内容会像一段中的文字一样随着文字部分的流动而打乱），对行内盒设置宽高无效，设置padding, margin 和 border都会更新周围文字的位置，但是对于周围的的块框（ block box）不会有影响。 行内块状框（inline-block box） 像是上述两种的集合：它不会重新另起一行但会像行内框（ inline box）一样随着周围文字而流动，而且他能够设置宽高，并且像块框一样保持了其块特性的完整性，它不会在段落行中断开。 默认状态下display属性值，块级元素display: block ，行内元素display: inline]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM知识点]]></title>
    <url>%2F2019%2F06%2F24%2FJVM%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[JAVA虚拟机JAVA跨平台我们都知道JAVA是一个可以跨平台的语言，那么它为什么可以跨平台？ Java不只是一种编程语言，还是一个完整的操作平台。Java之所以可以跨平台，这离不开JVM虚拟机。JVM是一个软件，在不同的平台上，JVM有不同的版本。Java在编译之后会生成一种.class文件，这种文件成为字节码文件。JVM虚拟机就是将Java编译后的.class文件翻译成特定平台下的机器码，然后运行。也就是说，在不同平台上装上平台对应的JVM虚拟机后，就可以将Java字节码文件转换，然后运行我们的Java程序。 Java编译后的结果是生成字节码，而不是机器码。字节码是不可以直接运行的，必须通过JVM再次翻译成机器码才可以运行。即使是将Java程序打包成可执行文件，也仍然需要JVM的支持才可以运行。跨平台的是Java程序，而不是JVM。JVM是用C/C++开发的，不能平台，不同的平台下JVM的版本是不同的。 JAVA虚拟机内存划分在Java中，程序员把内存控制权利交给 Java 虚拟机而不用像c++为一个 new 操作去写对应的 delete/free 操作，因此不是很容易出现内存泄露和溢出的问题。 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域： 其中线程私有的有：虚拟机栈，本地方法栈，程序计数器；线程共共享的有堆，方法区，直接内存。 JAVA堆Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。同时它也是是垃圾收集器管理的主要区域，因此也被称作GC堆，Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。 新生代分为：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1。参考https://blog.csdn.net/lojze_ly/article/details/49456255 一般情况下，新创建的对象都会被分配到Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。(一些大对象特殊处理：大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝新生代采用复制算法收集内存),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到老年代中。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 新生代和老年代的一些区别：新生代和老年代是针对于分代收集算法来定义的，新生代又分为Eden和Survivor两个区。加上老年代就这三个区。数据会首先分配到Eden区 当中（当然也有特殊情况，如果是大对象那么会直接放入到老年代（大对象是指需要大量连续内存空间的java对象）。），当Eden没有足够空间的时候就会 触发jvm发起一次Minor GC。如果对象经过一次Minor GC还存活，并且又能被Survivor空间接受，那么将被移动到Survivor空 间当中。并将其年龄设为1，对象在Survivor每熬过一次Minor GC，年龄就加1，当年龄达到一定的程度（默认为15）时，就会被晋升到老年代 中了，当然晋升老年代的年龄是可以设置的。其实新生代和老年代就是针对于对象做分区存储，更便于回收等等 有关年轻代的几个参数： 1.XX:NewSize和-XX:MaxNewSize 用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。 2.XX:SurvivorRatio 用于设置Eden和其中一个Survivor的比值，这个值也比较重要。默认8:1； 3.XX:+PrintTenuringDistribution 这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。 4-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold 用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。 程序计数器程序计数器的作用：字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，从而实现代码的流程控制；在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 注意：程序计数器是唯不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 JAVA虚拟机栈Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有局部变量表、操作数栈、动态链接、方法出口信息。每个方法从被调用，直到被执行完。对应着一个栈帧在虚拟机中从入栈到出栈的过程 Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。第一个是如果线程请求的栈深度大于虚拟机所允许的深度抛出的错误，第二个则是虚拟机在动态扩展栈时无法申请到足够的内存空间抛出的异常。 通常说的栈就是指局部变量表部分，存放编译期间可知的8种基本数据类型，及对象引用和指令地址。局部变量表是在编译期间完成分配，当进入一个方法时，这个栈中的局部变量分配内存大小是确定的。 jvm 的局部变量表是做什么的？ 存储局部变量、函数调用时传递参数，很多字节码指令都是对局部变量表和操作数栈进行操作的。 本地方法栈该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务，和平台有关的方法。 方法区它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，它有一个别名叫做 Non-Heap（非堆）也常称为永久代，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。 类加载什么是类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 类加载的过程类加载主要分为以下五个步骤：加载，验证，准备，解析，初始化。 加载：程序运行之前jvm会把编译完成的.class二进制文件加载到内存，供程序使用，用到的就是类加载器classLoader。 验证：保证类加载的准确性，看是否是javac 编译的class 文件。 准备：为类的静态变量分配内存，将其初始化为默认值。 解析：把类中的符号引用转化为直接引用。 初始化：为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值。 类加载基于的机制Java类加载器基于三个机制：委托、可见性和单一性。委托就是将加载一个类的请求交给父类加载器，如果没有父类加载器或者父类加载器不给它加载再加载它，可见性是父类加载器不能看到子类的加载的类，但是子类的加载能看到父类的加载的类。单一性是指仅加载一个类一次，这是由委托机制确保子类加载器不会再次加载父类加载器加载过的类。 为什么要双亲委派？ 保证java类库中的类不受用户类影响，防止用户自定义一个类库中的同名类，引起问题。 我们常见的有三种加载器：Bootstrap类加载器（加载java核心类库）、Extension类加载器（加载 Java 的扩展库）和System类加载器（Java 应用的类路径来加载 Java 类） 注意：使用不同的类加载器，你可以从不同的源地址加载同一个类，它们被视为不同的类。 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误 几个类加载器的层次关系： 自己写个String能加载吗加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是说当发现这个类没有的时候会先去让自己的父类去加载，父类没有再让儿子去加载，那么在这个例子中我们自己写的String应该是被Bootstrap ClassLoader加载了，所以App ClassLoader就不会再去加载我们写的String类了，导致我们写的String类是没有被加载的。但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载 jre.jar 包中的那个 java.lang.String。双亲委派机制是可以打破的， 所以，这些类都是可以重写的。 但是JVM出于安全的考虑， 你自己写的类 ， 不能用java.* 开头， 否则都不会被加载。 懂了吧， 总结一下就是： 可以写， 但是包名要改。 类初始化时机只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如 Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类 Java虚拟机结束生命周期在如下几种情况下，Java虚拟机将结束生命周期： 执行了 System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 JVM初始化步骤 假如这个类还没有被加载和连接，则程序先加载并连接该类 假如该类的直接父类还没有被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 对象的创建对象的创建的过程： 类加载检查—&gt;分配内存—&gt;初始化零值—&gt;设置对象头—&gt;执行 init 。 类加载检查： 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存：类加载检查通过后，接下来虚拟机将为新生对象分配内存。分配方式有：指针碰撞 和 空闲列表两种。在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的。 初始化零值：虚拟机将分配到的内存空间都初始化为零值。 设置对象头：虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 执行 init ：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，所以要执行程序写的 init 方法。 GC算法与垃圾回收为什么需要垃圾回收以及什么时候GC首先因为内存是有限的，在不断的分配内存空间而不回收的话内存迟早都会被消耗完，所以垃圾回收是必须的。 触发GC 的条件： 1.GC在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用。 2.Java堆内存不足时，GC会被调用。 触发Full GC：调用Sytem.GC()；老年代空间不足时；GC担保失败。 对象存活判断判断对象是否存活一般有两种方式： 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。能够作为GC Roots对象的有：虚拟机栈中引用的对象，方法区中的类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象。 GC算法 标记—清除：程序暂停运行，启动GC，GC从堆或静态存储区开始遍历所有对象，判断对象是否“活”的对象，如果是活不删除，反之删除。判断是否“活”就是判断该对象是否有被其他对象引用，从链上去查找。当是活对象时，会给对象给个标记符号，死对象则不标记，遍历完后，第二次遍历时，只保留标记的对象，把所有没标记的对象都删除。 停止—复制：程序暂停运行，启动GC，GC从堆或静态存储区开始遍历所有对象，判断对象是否“活”的对象，如果是活不删除，反之删除。判断是否“活”就是判断该对象是否有被其他对象引用，从链上去查找。当是活对象时，GC会从另外堆里开避一个大空间，然后将活对象复制一份到新空间里，在复制时按着紧密排列，同时更新所有引用地址为新的地址，不活对象原封不动。遍历完后，再遍历一次，这次是将不活的对象彻底给删除。 优点：所有对象能够重新紧密排列，不会出现内存碎片，这对以后创建对象能提供更快的效率。 缺点：占用的内存空间大，要原对象的2倍空间；这种模式无论如何所有活的对象都要复制一份，假设遍历到最后，对象很稳定，只出现少量垃圾对象或者根本没垃圾对象，这时已经做了复制工作，浪费了资源。 标记—整理：标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。 分代收集：根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。 垃圾收集器 CMS 垃圾收集器：获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法。 初始标记(标记GCRoots能直接关联到的对象，时间很短)-&gt; 并发标记(进行可达性分析过程，时间很长)-&gt; 重新标记-&gt;并发清除(回收内存空间，时间很长) G1收集器 并行和并发：使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行 分代收集：独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果 空间整合：基于标记 - 整理算法，无内存碎片产生。]]></content>
      <categories>
        <category>Java入门</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer刷题（持续更新）]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目一 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路首先我们知道了最小数是第一行第一个，最大数是最后一行的最后一个，每一行最大的一个数是每一行的最后一个，每一行最小一个数是每一行的第一个。 所以先从第一行的最后一个数设为J开始比较，如果目标大于J，则与下一行的最后一个数比较，如此循环，直到目标比J小 当目标比J小时，我们就能确定是哪一行然后往该行的前面递减。 AC代码c++版： 123456789101112131415161718192021222324class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int n = array.size(); if(n == 0) return false; int m = array[0].size(); int i = 0; int j = m-1; while(i&lt;n &amp;&amp; j&gt;=0)&#123; int temp = array[i][j]; if(target &lt; temp)&#123; j--; &#125; else if(target &gt; temp)&#123; i++; &#125; else&#123; return true; &#125; &#125; return false; &#125;&#125;; Java版： 123456789101112131415161718192021222324public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array == null)&#123; return false; &#125; int n = array.length; int m = array[0].length; int i = 0; int j = m-1; while(i&lt;n &amp;&amp; j&gt;=0)&#123; int temp = array[i][j]; if(target &lt; temp)&#123; j--; &#125; else if(target &gt; temp)&#123; i++; &#125; else&#123; return true; &#125; &#125; return false; &#125;&#125; 题目二 替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路第一个想法肯定就是从头开始找到一个空格就替换，但是这样的时间复杂度是O(n^2)的，因为你要写两重循环，我们可以降低时间复杂度，先预处理出来空格的个数，然后从后往前碰到空格进行替换，最后得到结果。当然这题用Java就巨简单了，Java提供替代函数。 AC代码c++版： 123456789101112131415161718192021222324252627class Solution &#123;public: void replaceSpace(char *str,int length) &#123; int blankNumber = 0; int oldstringLen; for (oldstringLen = 0; str[oldstringLen] != '\0'; oldstringLen++)&#123; if (str[oldstringLen] == ' ') blankNumber++; &#125; int newstringLen = oldstringLen + blankNumber * 2; if (newstringLen&gt;length) return; str[newstringLen] = '\0'; int point1 = oldstringLen - 1, point2 = newstringLen - 1; while (point1 &gt;= 0 &amp;&amp; point2&gt;point1)&#123;//两指针相同时，跳出循环 if (str[point1] == ' ')&#123; str[point2--] = '0'; str[point2--] = '2'; str[point2--] = '%'; &#125; else str[point2--] = str[point1]; point1--; &#125; &#125;&#125;; Java版： 12345public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replaceAll("\\s", "%20"); &#125;&#125; 题目三 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 思路因为链表是从头到尾，但是要从尾到头，所以很自然的就想到用Stack先存储对应的值，然后取出来放到ArrayList中。 AC代码c++版： 12345678910111213141516171819202122232425262728/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; ListNode *q=head; stack&lt;int&gt;s; vector&lt;int&gt;a; while(q!=NULL) &#123; s.push(q-&gt;val); q=q-&gt;next; &#125; while(!s.empty()) &#123; a.push_back(s.top()); s.pop(); &#125; return a; &#125;&#125;; Java版： 1234567891011121314151617181920212223242526272829/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); Stack&lt;Integer&gt; temp = new Stack&lt;Integer&gt;(); ListNode head = listNode; while(head!=null)&#123; temp.push(head.val); head=head.next; &#125; while(temp.size()!=0)&#123; ans.add(temp.peek()); temp.pop(); &#125; return ans; &#125;&#125; 题目五 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路一个栈存储放进来的值，一个栈用来pop，看下代码就知道了。 AC代码c++版： 123456789101112131415161718192021222324class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; int result; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.top()); stack1.pop(); &#125; &#125; result = stack2.top(); stack2.pop(); return result; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; Java版： 12345678910111213141516171819202122import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(stack2.size()==0)&#123; while(stack1.size()!=0)&#123; stack2.push(stack1.peek()); stack1.pop(); &#125; &#125; int temp=stack2.peek(); stack2.pop(); return temp; &#125;&#125; 题目六 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路就是找到这个数组的最小值。 AC代码c++版： 123456789101112131415class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; v) &#123; int len=v.size(); if(len==0)&#123; return 0; &#125; int ans=v[0]; for(int i=1;i&lt;len;i++)&#123; if(v[i]&lt;ans) ans=v[i]; &#125; return ans; &#125;&#125;; Java版： 12345678910111213141516import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if(array==null)&#123; return 0; &#125; int len=array.length; int ans=array[0]; for(int i=1;i&lt;len;i++)&#123; if(array[i]&lt;ans)&#123; ans=array[i]; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题（持续更新）]]></title>
    <url>%2F2019%2F06%2F24%2FLeetCode%E5%88%B7%E9%A2%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode1 Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路这个找到两个数，使得相加和为target。最简单的两重循环找到这个符合题意的值。 也可以一遍扫过去，每次找target-nums[i]值是否出现过，出现了就返回，不然就存到数组中。 AC代码12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123; var len=nums.length; var i,j; var hash=[]; for(i=0;i&lt;len;i++)&#123; j=target-nums[i]; if(hash[j]!==undefined)&#123; return [i,hash[j]]; &#125; else&#123; hash[nums[i]]=i; &#125; &#125;&#125;; LeetCode5 Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 思路题意是找出一个最长的回文子串，有几种做法，我这里提供两种。 第一种是暴力，回文子串有两种，长度为奇数的和长度为偶数的，对于每个位置点，我向两边进行扩散，分别进行奇数和偶数长度的回文子串判断，然后维护一个长度最大值和这个子串的起始位置。 AC代码1234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; s * @return &#123;string&#125; */var low=0;var maxn=0;var longestPalindrome = function(s) &#123; var len=s.length; if(len &lt; 2)&#123; return s; &#125; for(let i=0;i&lt;len-1;i++)&#123; check(s,i,i); check(s,i,i+1); &#125; let res=s.substring(low,low+maxn); low =0;maxn= 0; return res;&#125;;function check(s,start,end)&#123; while(start&gt;=0 &amp;&amp; end&lt;s.length &amp;&amp; (s[start]==s[end]))&#123; start--; end++; &#125; if(maxn&lt;(end-start-1))&#123; low=start+1; maxn=end-start-1; &#125;&#125; 第二种是利用动态规划的思想，我们知道对于长度为1的都是回文子串，然后枚举子串长度和子串起点，判断是否是回文子串，维护一个最大值和子串的起始点。 AC代码1234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; s * @return &#123;string&#125; */var low=0;var maxn=0;var longestPalindrome = function(s) &#123; var len=s.length; if(len&lt;2)&#123; return s; &#125; var dp=new Array(); var i=0;var j; var left=0,right=0,len1=0; for(;i&lt;len;i++) dp[i]=new Array(); for(i=0;i&lt;len;i++)&#123; dp[i][i]=1; for(j=0;j&lt;i;j++)&#123; dp[j][i] = (s[i] == s[j] &amp;&amp; (i - j &lt; 2 || dp[j + 1][i - 1])); if (dp[j][i] &amp;&amp; len1 &lt; i - j + 1) &#123; len1 = i - j + 1; left = j; right = i; &#125; &#125; &#125; return s.substr(left, right-left+1);&#125;; LeetCode7 Reverse IntegerGiven a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 思路题意是让一个32位的带符号的整数倒置过来。 就先取绝对值，然后初始化一个result = 0，把给定的数字n除以十，得到余数作为最低位，商作为新的数字n，result = result + 余数*10，这样每次得到的最低位就会随着循环不断提升数位，从而得到逆序的result。 AC代码1234567891011121314/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123; var y=Math.abs(x); var res=0; while(y&gt;0)&#123; res=res*10+y%10; y=parseInt(y/10); &#125; res=x&lt;0?-res:res; return res&gt;=-Math.pow(2,31)&amp;&amp;res&lt;=Math.pow(2,31)-1?res:0;&#125;; LeetCode9 Palindrome NumberDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. 思路给你一个数，看是不是回文数。首先负数肯定不会是回文数，直接return false即可，小于10的非负整数都是回文return true， 否则就从后往前进行逆序数组转数字运算，得到结果与初值进行比较，相等return true。 AC代码12345678910111213141516171819/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */var isPalindrome = function(x) &#123; //能被10整除的非0整数和负数，返回false if(x&lt;0) return false; if(x&lt;10) return true; var temp=0; var org=x;//记录x的初始值 while(x&gt;9)&#123; temp=x%10+temp*10 x=parseInt(x/10) &#125; temp=temp*10+x return temp===org&#125;;]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现六]]></title>
    <url>%2F2019%2F06%2F10%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%E5%85%AD%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现五]]></title>
    <url>%2F2019%2F06%2F10%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%E4%BA%94%2F</url>
    <content type="text"><![CDATA[功能需求现在情形是每当有人进频道的时候，这个人的视频数据和video数据都会被接受，现在想做成我只接收我现在当前屏幕的显示的视频的数据流，频道里其他人的话我只接收声音就可以了。 实现首先我么要知道什么时候我们需要这个视频流量屏蔽的功能，根据需求我们可以了解到是否绑定视图来决定是否要屏蔽流量，所以我们需要再三个地方进行修改。 在YoumeModule添加对应的事情监听： 123456789101112131415case YouMeConst.YouMeEvent.YOUME_EVENT_OTHERS_VIDEO_ON:&#123; Log.d(TAG, "video _on: "+param.toString()); TimerTask task = new TimerTask() &#123; @Override public void run() &#123; Vector&lt;SurfaceViewRenderer&gt; renderInfos = VideoRendererManager.getInstance().getRender(param.toString()); if(renderInfos == null || renderInfos.size() == 0) &#123; Log.d(TAG, "run: "+param.toString()); api.maskVideoByUserId(param.toString(), true); &#125; &#125; &#125;; Timer timer = new Timer(); timer.schedule(task, 150);&#125; 然后就是对应的在delete的时候肯定是屏蔽流量的，在对应的add或者change的时候肯定是不屏蔽的所以在YoumeViewManager中加以下的内容： 123456//添加或者改变的时候是在当前的videoview上修改，所以不屏蔽api.maskVideoByUserId(userID, false);//delete的时候需要屏蔽if(videoView.autoMask &amp;&amp;(renderInfos == null || renderInfos.size() == 0))&#123; api.maskVideoByUserId(videoView.userid, true);&#125;]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现四]]></title>
    <url>%2F2019%2F06%2F10%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[功能需求点击头部结束文字弹出用户提示是否要退出 实现使用Alert实现这个功能，参考https://reactnative.cn/docs/alert.html#docsNav，启动一个提示对话框，包含对应的标题和信息。本接口可以在 iOS 和 Android 上显示一个静态的提示框。如果要在显示提示框的同时接受用户输入一些信息，那你可能需要AlertIOS。 对应我们需求只需要一个静态的提示框就可以了。这个接口在 Android 上最多能指定三个按钮，这三个按钮分别具有“中间态”、“消极态”和“积极态”的概念： 如果你只指定一个按钮，则它具有“积极态”的属性（比如“确定”）；两个按钮，则分别是“消极态”和“积极态”（比如“取消”和“确定”）；三个按钮则意味着“中间态”、“消极态”和“积极态”（比如“稍候再说”，“取消”，“确定”）。我们这个只需要积极态和消极态就可以了。 1234567891011121314151617const &#123; meetingId &#125; = await retrieveUserLoginData();if (meetingId) &#123; Alert.alert( &apos;提示&apos;, &apos;是否确认退出当前视频会议&apos;, [ &#123; text: &apos;取消&apos;, onPress: () =&gt; &#123;&#125; &#125;, &#123; text: &apos;确定&apos;, onPress: async () =&gt; &#123; await this.yim.LeaveChannel(`$&#123;meetingId&#125;`);// IM 退出房间 await this.yim.logout();// IM 退出登录 TalkService.leaveChannel(); const &#123; navigate &#125; = this.context; navigate(&apos;JoinMeeting&apos;); &#125;&#125; ] );&#125;]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现三]]></title>
    <url>%2F2019%2F06%2F10%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[功能需求实现userId和View的一对多，以及保证线程安全，在ViewRenderManager中修改addRender，Remove的实现修改一个人对应的View。 实现首先之前的存储是利用HashMap存储，一个userId对应一个View： 123456789public class RenderInfo &#123; public int rotation; public SurfaceViewRenderer view; public RenderInfo(int rotation, SurfaceViewRenderer view)&#123; this.rotation = rotation; this.view = view; &#125;&#125;private Map&lt;String, RenderInfo&gt; renderers = new HashMap&lt;String, RenderInfo&gt;(); 那么我需要实现一个userId对应多个View，那么我肯定需要拿一个数据结构存储这多个View并且保证线程安全，可以选择ConcurrentHashMap代替HashMap，然后用Vector去存储这多个View。 1private Map&lt;String, Vector&gt; renderers = new ConcurrentHashMap&lt;String, Vector&gt;(); 我们在VideoRendererManager里写增删，然后再外面封装一层YoumeManager实现增删改，最后在YoumeViewManager写业务逻辑时候再调用函数实现功能点。 那我们先修改VideoRendererManager层： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*** 添加渲染源,添加的时候如果这个userId已经存在，就添加到对应的Vector里面，如果不存在* 话就新生成一个Vector，然后put到ConcurrentHashMap里面就可以了。* @param view* @return*/public RenderInfo addRender(String userId, SurfaceViewRenderer view) &#123; //int renderId = api.createRender(userId); RenderInfo info = new RenderInfo(0, view); Vector&lt;RenderInfo&gt; renderInfos = renderers.get(userId); if(renderInfos != null)&#123; renderInfos.add(info); &#125; else&#123; Vector&lt;RenderInfo&gt; renderInfos1 = new Vector&lt;RenderInfo&gt;(); renderInfos1.add(info); renderers.put(userId,renderInfos1); &#125; Log.d(TAG, "addRender userId:"+userId); return info;&#125;/*** get渲染源，以前的话只需要get出来那个userId，所以返回SurfaceViewRenderer就可以了* 现在因为一个userId对应多个View，所以应该返回Vector&lt;SurfaceViewRenderer&gt;，然后* 由于从ConcurrentHashMap里面取出来的是RenderInfo，所以应该把View从RenderInfo* 取出来放到Vector中再返回*/public Vector&lt;SurfaceViewRenderer&gt; getRender(String userId) &#123; Vector&lt;RenderInfo&gt; renderInfos = renderers.get(userId); Vector&lt;SurfaceViewRenderer&gt; surfaceViewRenderers = new Vector&lt;SurfaceViewRenderer&gt;(); if(renderInfos != null)&#123; for(int i=0;i&lt;renderInfos.size();i++)&#123; surfaceViewRenderers.add(renderInfos.get(i).view); &#125; return surfaceViewRenderers; &#125; else &#123; return null; &#125;&#125;/*** 删除的时候，因为每个人有多个View，所以删除的时候要删除对应的userId的对应的那个* RenderInfo，当然如果这个userId对应的View要是为空的时候就应该把这个userId* ConcurrentHashMap里面删除，*/public int deleteRender(String userId,RenderInfo renderInfo) &#123; //int ret = api.deleteRender(renderId); if(renderInfo == null) &#123; renderers.remove(userId); &#125; else&#123; Vector&lt;RenderInfo&gt; renderInfos = renderers.get(userId); if(renderInfos != null) &#123; renderInfos.remove(renderInfo); &#125; &#125; return 0;&#125;同理在渲染的时候之前是直接渲染对应的那个View，现在的话我们需要把这个userId对应的Vector取出来，然后渲染这个Vector。 这样的话最底层的数据修改就完成了，现在修改YoumeManager层： 1234567891011public VideoRendererManager.RenderInfo addRenderInfo(final String userid) &#123; SurfaceViewRenderer sView = new SurfaceViewRenderer(context); return VideoRendererManager.getInstance().addRender(userid,sView);&#125;public void deleteRenderInfo (String userid, VideoRendererManager.RenderInfo renderInfo)&#123; VideoRendererManager.getInstance().deleteRender(userid,renderInfo); if(renderInfo != null &amp;&amp; renderInfo.view != null)&#123; renderInfo.view.release(); &#125;&#125; 再修改YoumeViewManager层： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@ReactProp(name = "options")public void setOptions(final YoumeVideoView videoView, final ReadableMap options) &#123; String userID = options.hasKey("userID") ? options.getString("userID") : ""; //停止在最后一帧画面 boolean pause = options.hasKey("pause") ? options.getBoolean("pause") : false; //隐藏视频组件显示，如果全部都隐藏了，同时会屏蔽视频流接受 boolean hide = options.hasKey("hide") ? options.getBoolean("hide") : false; //在组件销毁时自动屏蔽视频接受 boolean autoMask = options.hasKey("autoMask") ? options.getBoolean("autoMask") : false; Log.d(REACT_COMPONENT_NAME, "setOptions:"+currentCount+ " " + userID + " pause:" + pause + " hide:" + hide); if (userID == null) return; /** 根据业务逻辑，当我们需要改变userId的时候有几种情况，第一个是change，第二个 * 是add，add的话我们就直接调用YoumeManager层的addRenderInfo函数，然后把对应 * 的View绑定到对应的videoView（正在渲染的View）上就可以了。change的话我们正常 * 的逻辑就是我把这个对应的userId的对应的View删了，然后把新的View添加到这个 * userId上去就可以了，当然还需要把之前的View从当前渲染的videoView上取消绑定以 * 及把新的View绑定到哦当前渲染的videoView上。 */ if (videoView.surfaceView != null) &#123; if (!userID.equals(videoView.userid)) &#123; YoumeManager.getInstance().deleteRenderInfo(videoView.userid, videoView.renderInfo); videoView.removeView(); videoView.renderInfo = YoumeManager.getInstance().addRenderInfo(userID); videoView.addView(videoView.renderInfo, userID); setZOrderMediaOverlay(videoView, videoView.zOrderMediaOverlay); &#125; &#125; else &#123; videoView.renderInfo = YoumeManager.getInstance().addRenderInfo(userID); videoView.addView(videoView.renderInfo, userID); &#125; videoView.setPause(pause); videoView.setHide(hide); api.maskVideoByUserId(userID, false); videoView.setAutoMask(autoMask); if(videoView.neetSetZOrder)&#123; videoView.neetSetZOrder = false; setZOrderMediaOverlay(videoView, videoView.zOrderMediaOverlay); &#125;&#125;@Override//销毁实例public void onDropViewInstance(YoumeVideoView videoView) &#123; Log.d(REACT_COMPONENT_NAME, "onDropViewInstance："+ currentCount + " "+ (videoView.userid != null ? videoView.userid:"")); if(videoView.userid != null) &#123; YoumeManager.getInstance().deleteRenderInfo(videoView.userid, videoView.renderInfo); Vector&lt;SurfaceViewRenderer&gt; renderInfos = VideoRendererManager.getInstance().getRender(videoView.userid); if(videoView.autoMask &amp;&amp;(renderInfos == null || renderInfos.size() == 0)) &#123; api.maskVideoByUserId(videoView.userid, true); &#125; &#125; super.onDropViewInstance(videoView);&#125; 这样的话，我们的任务就解决了。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6熟悉]]></title>
    <url>%2F2019%2F06%2F08%2FES6%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Let和Const命令LetES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 123456&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 用let声明的变量不会进行变量提升，我们知道用var声明的变量定义的话是会进行变量提升，即使你在变量定义之前使用也只是用返回一个undefined，但是你要是用let声明的话是会抛出一个错误，因为如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 123456// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; for循环的时候就很适合使用let，但是注意一个点，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。如： 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 let不允许在相同作用域内，重复声明同一个变量，但是允许块级作用域的任意嵌套，然后内层作用域可以定义外层作用域的同名变量。 为什么需要块级作用域？ 第一种场景，内层变量可能会覆盖外层变量。 第二种场景，用来计数的循环变量泄露为全局变量。 块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。但是注意函数声明类似于var，即会提升到全局作用域或函数作用域的头部，同时，函数声明还会提升到所在的块级作用域的头部。比方这个实例： 12345678910111213141516171819// 浏览器的 ES6 环境function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log(&apos;I am inside!&apos;); &#125; &#125; f();&#125;());/* Uncaught TypeError: f is not a function，它会报错，说f并不是函数类型，这是因为上述说的问题，这样声明的情况下，代码等价于下面*/function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log(&apos;I am inside!&apos;); &#125; &#125; f();&#125;());//因此f在定义的时候不是一个函数后序又没有进行函数的声明调用导致报错 所以在块级作用域汇总避免声明函数，如果非要声明的话应该写成函数表达式的形式。另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，而let只能出现在当前作用域的顶层。 Constconst声明一个只读的常量。一旦声明，常量的值就不能改变，并且必须立即初始化。const的作用域与let命令相同：只在声明所在的块级作用域内有效。 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的，但是不能保证这对象或者数组里面的内容不会进行改变，不会变的知识这个地址，对象依旧能够添加新的对象。 如果真的想将对象冻结，应该使用Object.freeze方法。 1234const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 注意：ES6有六种声明变量的方法：let，const，var，function，class，import。 变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解，如下图： 1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值，如果解构不成功，变量的值就等于undefined。 解构赋值允许指定默认值，如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 什么时候能用解构赋值？只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。像set，array，map。对象也可以进行解构赋值。 对象解构赋值的注意点对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。如： 1234let &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;baz // &quot;aaa&quot;foo // error: foo is not defined//foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 对象结构赋值的时候也可以进行嵌套赋值，但是如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。当然对象的解构赋值也可以指定默认值。 除了这些还有： 如果要将一个已经声明的变量用于解构赋值，必须非常小心。 1234567// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;);//为 JavaScript 引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误。 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 解构赋值的圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理，ES6规定了几种不能使用圆括号的情况： （1）变量声明语句（2）函数参数（3）赋值语句的模式 看下实例： 123456789101112131415// 变量声明错误let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;//函数参数// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125;// 赋值语句的模式全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 解构赋值的用处1：交换变量的值 2：从函数返回多个值 3：函数参数的定义（可以方便地将一组参数与变量名对应起来） 4：提取 JSON 数据 5：函数参数的默认值 6：遍历 Map 结构 7：输入模块的指定方法 Module众所周知JavaScript是没有module的概念的，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。在ES6之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器，在ES6中，通过export命令显式指定输出的代码，再通过import命令输入，这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载。但是不是说有这个之后就不需要动态加载了，特别是在浏览器工作的时候有时候是不需要把所有依赖的东西都导入的，可以到你需要的时候导入。 Export一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。export命令除了输出变量，还可以输出函数或类。通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 123456789101112131415161718//输出变量export var year = 1958;var year = 1958;var firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;export &#123; firstName, lastName, year &#125;;//输出函数或者类export function multiply(x, y) &#123; return x * y;&#125;;//重命名function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错。 Importexport命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 import命令具有提升效果，会提升到整个模块的头部，首先执行，因为它是编译时期执行的，所以不能使用表达式和变量并且不能放在判断语句这些里面，这些只有在运行时才能得到结果的语法结构。 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 Export Default它的默认输出是一个函数。 1234567// export-default.jsexport default function () &#123; console.log(&apos;foo&apos;);&#125;// import-default.jsimport customName from &apos;./export-default&apos;;customName(); // &apos;foo&apos; 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。但是注意引入的模块的内容只能字啊import和export内容之间被引用。 Import()前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行所以，下面的代码会报错。 123if (x === 2) &#123; import MyModual from &apos;./myModual&apos;;&#125; 上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。所以引入import()函数以帮助完成动态加载。 import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。 import()返回一个 Promise 对象。 12345678const main = document.querySelector(&apos;main&apos;);import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;) .catch(err =&gt; &#123; main.textContent = err.message; &#125;); 它一般会用于：按需加载，条件加载，动态的模块路径。 Module加载实现浏览器加载HTML 网页中，浏览器通过&lt;script&gt;标签加载 JavaScript 脚本。默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。 12&lt;script src="path/to/myModule.js" defer&gt;&lt;/script&gt;&lt;script src="path/to/myModule.js" async&gt;&lt;/script&gt; defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成）才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type=&quot;module&quot;属性。 1&lt;script type="module" src="./foo.js"&gt;&lt;/script&gt; 浏览器对于带有type=&quot;module&quot;的&lt;script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。 ClassClass概念ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。利用class就很像我们之前在c++，java当中学习的对象。 12345678910class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125;/*constructor方法，这就是构造方法;this关键字则代表实例对象,Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。*/ 注意：类的数据类型就是函数，类本身就指向构造函数。而且类的方法都定义在prototype对象上面。 constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 类必须使用new调用，否则会报错。 类的所有实例共享一个原型对象。 1234var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__/*true，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。*/ 实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 123456789101112131415161718//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty(&apos;x&apos;) // truepoint.hasOwnProperty(&apos;y&apos;) // truepoint.hasOwnProperty(&apos;toString&apos;) // falsepoint.__proto__.hasOwnProperty(&apos;toString&apos;) // true/*上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。*/ 类的属性名，可以采用表达式。12345678910let methodName = &apos;getArea&apos;;class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125;//Square类的方法名getArea，是从表达式得到的。 Class表达式与函数一样，类也可以使用表达式的形式定义。 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。 静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 123456789class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;Foo.classMethod() // &apos;hello&apos;var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 如果静态方法包含this关键字，这个this指的是类，而不是实例 12345678910111213class Foo &#123; static bar() &#123; this.baz(); &#125; static baz() &#123; console.log(&apos;hello&apos;); &#125; baz() &#123; console.log(&apos;world&apos;); &#125;&#125;Foo.bar() // hello/*静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。*/ 父类的静态方法，可以被子类继承。静态方法也是可以从super对象上调用的。 Class继承Class 可以通过extends关键字实现继承 123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + &apos; &apos; + super.toString(); // 调用父类的toString() &#125;&#125; 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 Object.getPrototypeOf方法可以用来从子类上获取父类。可以使用这个方法判断，一个类是否继承了另一个类。 supersuper这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。就是我们上面写的代码中就能看出来。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 12345678910111213class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B();/*子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。*/ 由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 prototype属性和proto属性每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 子类的__proto__属性，表示构造函数的继承，总是指向父类。 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HOOK介绍及理解]]></title>
    <url>%2F2019%2F06%2F08%2FHOOK%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是HOOK，什么时候用？Hook是一个特殊的函数，它可以让你“钩入” React 的特性。它允许让你在不编写 class 的情况下使用 state 以及其他的 React 特性。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。 React 内置了一些像 useState，useEffect这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。 State Hook看实例： 12345678910111213141516import React, &#123; useState &#125; from &apos;react&apos;;function Example() &#123; // 声明一个叫 “count” 的 state 变量。 const [count, setCount] = useState(0); // 声明多个 state 变量！ const [age, setAge] = useState(42); const [fruit, setFruit] = useState(&apos;banana&apos;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useState 就是一个 Hook。通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState。这里用到了数组解构的语法。 useState 唯一的参数就是初始 state，不同于 this.state，这里的 state 不一定要是一个对象。 我们声明了一个叫 count 的 state 变量，然后把它设为 0。React 会在重复渲染时记住它当前的值，并且提供最新的值给我们的函数。我们可以通过调用 setCount 来更新当前的 count。 这样的话，我们在引用这个state变量的时候和更新state的时候就比之前方便很多，如： 123456//在函数中，我们可以直接用 count:&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;//更新的时候&lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me&lt;/button&gt; Effect HOOKEffect Hook可以让你在函数组件中执行副作用操作，使用useEffect来实现。我们可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合，在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。我们来更仔细地看一下他们之间的区别。感觉就是你需不需要返回一个清除的函数。 我们知道在 React 的 class 组件中，render 函数是不应该有任何副作用的。一般来说，在这里执行操作太早了，我们基本上都希望在 React 更新 DOM 之后才执行我们的操作。 不需要清除的Effect HOOK看下实例： 123456789101112131415import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function Example() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 通过使用这个 Hook，会告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。在这个 effect 中，我们设置了 document 的 title 属性。 为什么在组件内部调用 useEffect？将 useEffect 放在组件内部让我们可以在 effect 中直接访问 count state 变量（或其他 props）。 useEffect 会在每次渲染后都执行吗？默认情况下，它在第一次渲染之后和每次更新之后都会执行。你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的时，DOM 都已经更新完毕。 大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffectHook 供你使用 需要清除的Effect HOOK就是我们添加了监听事件或者一些事需要在之后进行清除操作防止引起内存泄露，那么我们就应该返回一个函数，其实是对应着之前说过的组件的生命周期componentWillUnmount不使用Hook的时候是需要在这个函数中调用清操作的。看实例： 123456789101112131415161718import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // Specify how to clean up after this effect: return function cleanup() &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return &apos;Loading...&apos;; &#125; return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;&#125; React 何时清除 effect？React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect之前对上一个 effect 进行清除。 通过跳过Effect进行性能优化在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决： 12345componentDidUpdate(prevProps, prevState) &#123; if (prevState.count !== this.state.count) &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125;&#125; 在Hook中，如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可： 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 仅在 count 更改时更新 但是注意使用这种优化的情况是：你这个 userEffect 依赖了 props 或者state的属性时，由于不想每次组件渲染的时候都执行这个 useEffect，因此可以在数组里面添加 props.name，每次组件渲染的时候，通过看一下 props.name 这个属性的值有没有变化，如果没有变化，就不执行这个 useEffect。这样就减少了这个 useEffect 的执行次数，从而达到了优化性能的作用。 就像官网上说的：如果你要使用此优化方式，请确保数组中包含所有外部作用域中会随时间变化并且在 effect 中使用的变量，否则你的代码会引用到先前渲染中的旧变量 Hook使用的一些规则Hook 本质就是JavaScript 函数，但是在使用它时需要遵循两条规则： 只在最顶层使用 Hook不要在循环，条件或嵌套函数中调用 Hook，确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。 如果需要调用条件循环的话，可以把判断放到Hook的内部： 123456useEffect(function persistForm() &#123; // 👍 将条件判断放置在 effect 中 if (name !== &apos;&apos;) &#123; localStorage.setItem(&apos;formData&apos;, name); &#125; &#125;); 只在 React 函数中调用 Hook不要在普通的 JavaScript 函数中调用 Hook，可以在React的函数组件中调用Hook，或者在自定义Hook中调用其他的Hook。 我们可以在单个组件中使用多个 State Hook 或 Effect Hook。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>HOOK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行报错汇总]]></title>
    <url>%2F2019%2F05%2F29%2F%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1.com.android.builder.testing.api.DeviceException：com.android.ddmlib.InstallException：INSTALL_FAILED_VERSION_DOWNGRADE是因为不在最新版本的RN上构建调试apk，可能在已安装的应用程序内部存在某些版本冲突，尝试在手机端先卸载然后重新运行一下。 2.Problem:Failed to capture fingerprint of output files for task ‘:app:generateDebugBuildConfig’ property ‘sourceOutputDir’ during up-to-date check.解决方法： 1234cd android./gradlew cleancd ..react-native run-android 3.This error is caused by hasteImpl returning the same name for different files.表明你有两个react-native依赖关系。一个在您的主项目，一个你的XXX模块中，从而创造自己的冲突package.json秒。似乎如果你从一个本地路径，它会将它的安装包像node_modules目录。 正如你已经react-native在你的自定义模块的依赖package.json，尝试删除E:cdg-nativeCDGnode_modulesreact-native-XXXnode_modules。我就是不小心在某个文件夹中又运行了一次yarn导入了一些依赖包，删了就可以运行了。 4.无设备连接先运行一下查看连接设备是否有正常设备连接 1adb devices 正常的连接的时候查看一下安装的细节情况： 1gradlew assembleDebug --info 具体的再去细致的看下吧]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现三]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BF%9D%E6%8C%81%E5%B1%8F%E5%B9%95%E5%B8%B8%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[功能需求在我们进行视频的过程中，需要保持屏幕常亮，避免进入锁屏的需要。想法就是在人员加入到频道的时候调用屏幕常亮的方法，然后在离开频道的时候调用去除屏幕常亮的方法。 几种常见的方法FLAG_KEEP_SCREEN_ON它是基于一个activity的方法，它是一个页面 Window 上的一个Flag，使用 addFlags() 方法添加。 1activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); 这里使用完成之后，也是需要取消掉的。取消这个 Flag 使用 clearFlags() 方法来取消。 1activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); keepScreenOn除了给Window添加一个FLAG_KEEP_SCREEN_ON的 Flag 之外，还可以对当前可见的View调用 keepScreenOn() 方法来设置屏幕常亮。它是是 View 对象上的方法。它的原理和FLAG_KEEP_SCREEN_ON一样的，只是它更简单，只需要对某个View设置，如果View可见即生效，否者就不生效。 需要注意的一点，使用keepScreenOn()设置的常亮标识，需要当前View保持屏幕可见才行。所以一般而言，我们会在页面的根布局中，添加此属性。 实际使用首先我需要在Java层实现这个函数，就是使用我们上面说的那个方法，但是在开始的时候是不能在方法内直接调用上面的方法的，因为视图层的更新必须是通过主线程更新的也就是UI线程更新，如果在主线程之外的线程中直接更新页面的话是会抛出以下的异常： 1android.view.ViewRoot$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 解决方法是：https://blog.csdn.net/luckyjda/article/details/8601517 通过Handle和runOnUiThread()去解决，具体的形式可以看链接。 所以在Java层的函数声明是这样的： 12345678910111213141516171819202122232425/** * 开启屏幕常亮 */ @ReactMethod public void keepScreenOn() &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; getCurrentActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125;); &#125; /** * 取消屏幕常亮 */ @ReactMethod public void cancelScreenOn() &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; getCurrentActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125;); &#125; 在Java层调用了之后我们还需要在对应的ts文件进行修改才能使得Js层能够调用这个函数。对应的操作就是对应的ReactNative的插件里面的YoumeVideoEngine.native.ts文件进行如下修改对应我们修改的Java层函数， 1234567public static keepScreenOn() &#123; Youme.keepScreenOn(); &#125; public static cancelScreenOn() &#123; Youme.cancelScreenOn(); &#125; 在此之后我们调用一些命令，把这个ts文件更新到js文件，使得对应的js文件得到修改 12yarnyarn build 做完这些需要的工作我们的接口的工作就已经完成了。 接下来应该做的是在Js层的sdk中调用这个函数， 按着初始的想法我们应该在leaveChannel和joinChannel中调用我们的接口函数： joinChannel中调用： 1YoumeVideoEngine.keepScreenOn(); leaveChannel中调用 1YoumeVideoEngine.cancelScreenOn(); 这样的话整个调用的过程就完成了，能得到预期的视频的时候屏幕常亮的效果。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现二]]></title>
    <url>%2F2019%2F05%2F29%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[功能需求在接收视频的时候，对于所占屏幕较大的采用高清流，所占屏幕较小的采用低清流。 实现首先需要了解一下，这个视频是如何显示的，之前我是以为在这屏幕中，我需要把所有的memberlist的成员都渲染出来，对于渲染的那个userid就不能清楚的理解，后来我知道了，在这个屏幕的渲染中只会渲染两个成员，除了本身之外渲染memberlist的第一个成员。 这样的话，需要完成的点就比较清晰了。在之前已经有一个默认的把两个视频流都接收为低清流的函数。它是遍历了memberlist然后进行处理，那么我可以在memberlist里面多加一个boolean参数：isBigStream，当这个boolean值为true的时候我接收高清流，值为false的时候接收低清流。那么这个函数我就可以修改成（在之前的基础上修改，因为把对象弄错了，memberlist是一个容器，它是一个map，我们定义的isBigStream参数是对象上的）： 1234567891011_updateReceiveStream = ()=&gt;&#123; let streamInfos = []; for (const [k,v] of this.memberList) &#123; if(v.isBigStream) streamInfos.push(&#123;userID:k, streamID: 0 &#125;); else streamInfos.push(&#123;userID:k, streamID: 1 &#125;); &#125; if(streamInfos.length &gt; 0) YoumeVideoEngine.setUsersVideoInfo(streamInfos);&#125; 第一个问题解决了，那么就是第二个问题我如何设置这个参数值，在这里面我了解到在渲染的时候有两个函数，VideoBig组件和``Videosmall组件，它们分别的去渲染大窗口和小窗口，那么我需要在渲染大窗口的时候把这个userid传到函数里面，然后调用这个函数，把这个userid的isBigStream参数设置为true`就可以了。所以是这样调用 VideoBig.js中： 1TalkService.setUserBigStreamStatus(userId); 那么在封装的sdk中，我就需要写这样的一个函数setUserBigStreamStatus，是这样： 12345setUserBigStreamStatus = (userId) =&gt; &#123; this._updateMemberList(userId, &#123; isBigStream: true &#125;); &#125; 但是也出现了一个问题，因为我渲染的是memberlist里面的除了自己的第一个成员，要是我这个渲染的成员离开了视频，那我是不是要把这个离开的成员的userid对应的isBigStream参数重新设置为false，然后把现在渲染的userid的isBigStream参数值设置为true，因此我又加了两个变量，存储之前渲染的userid和现在要渲染的userid，然后在VideoBig.js中调用函数的时候我们把这个参数进行重新赋值和isBigStream参数的设置，基本上是这样： 123456789101112131415161718//添加部分// 存放状态为大流的 userIdthis.prevBigStreamUserId = '';this.currentBigStreamUserId = '';//函数的重新修改setUserBigStreamStatus = (userId) =&gt; &#123; this.prevBigStreamUserId = this.currentBigStreamUserId; this.currentBigStreamUserId = userId; this._updateMemberList(this.prevBigStreamUserId, &#123; isBigStream: false &#125;); this._updateMemberList(this.currentBigStreamUserId, &#123; isBigStream: true &#125;);&#125; 至此我们修改的任务就完成了，虽然不是自己一个人完成的，但是自己一个人确定的具体的思路还是正确的，争取早日自己独立完成功能点的开发。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAM项目功能点实现一]]></title>
    <url>%2F2019%2F05%2F27%2FYAM%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[项目运行步骤先从git上把项目clone下来 1git clone &quot;项目地址的url&quot; 利用VSCode打开项目后，配置好终端，默认的是shell，用git bash的会好用一点。 下载好yarn（一个资源管理器，可以很快导入执行包），在终端中运行命令就可以把项目跑起来了： 12yarnreact-native run-android 功能需求实现成员列表页面的图标渲染，并把这个组件进行封装。 实现首先，已经有一个读取好的memberlist和监听频道中人员变化的函数了。 那么我就需要把数据从这个memberlist中读取出来并显示。基于之前写的那个ReactDemo知道我们需要调用一个函数，并且使用map函数，在函数中把存储的数据显示： 12345678910111213141516171819 function getListItem () &#123; return memberList.map(member =&gt; ( &lt;ListItem key=&#123;member.userId&#125;&gt; &lt;View style=&#123;&#123; flexDirection: 'row' &#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1, flexDirection: 'row'&#125;&#125;&gt; &lt;Text style=&#123;&#123;flex: 3&#125;&#125;&gt; &#123;member.userInfo &amp;&amp; member.userInfo.nick_name&#125;&lt;/Text&gt; &lt;Image source= &#123;member.isMicrophoneOn ? require('./icons/Microphone.png') : require('./icons/Microphone1.png')&#125; /&gt; &lt;Image source= &#123;member.isVideoOn ? require('./icons/Camera.png') : require('./icons/Camera1.png')&#125; /&gt; &lt;/View&gt; &lt;/View&gt; &lt;/ListItem&gt; )); &#125; &lt;View&gt; &lt;List&gt; &#123;getListItem () &#125; &lt;/List&gt;&lt;/View&gt; 这样的话我们就能够读取出信息并基于读取的信息来设定对应的图标。 然后要把这个List封装起来，就需要在我们的components组件文件下定义这个Component。基本的实现其实和我们写好的函数差不多， 12345678910111213141516171819202122232425262728293031323334import React, &#123;useState, useEffect&#125; from 'react';import PropTypes from 'prop-types';import &#123; View, Image &#125; from 'react-native';import &#123; List, ListItem, Text &#125; from 'native-base';export default function EasyList (props)&#123; const &#123; images &#125; = props; const &#123; Microphone, Microphone1, Camera, Camera1 &#125; = images; function getListItem () &#123; return props.memberList.map(member =&gt; ( &lt;ListItem key=&#123;member.userId&#125;&gt; &lt;View style=&#123;&#123; flexDirection: 'row' &#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1, flexDirection: 'row'&#125;&#125;&gt; &lt;Text style=&#123;&#123;flex: 3&#125;&#125;&gt; &#123;member.userInfo &amp;&amp; member.userInfo.nick_name&#125;&lt;/Text&gt; &lt;Image source= &#123;member.isMicrophoneOn ? Microphone : Microphone1&#125; /&gt; &lt;Image source= &#123;member.isVideoOn ? Camera : Camera1&#125; /&gt; &lt;/View&gt; &lt;/View&gt; &lt;/ListItem&gt; )); &#125; return( &lt;List&gt; &#123;getListItem()&#125; &lt;/List&gt; );&#125;EasyList.propTypes = &#123; memberList: PropTypes.array.isRequired, images: PropTypes.object.isRequired&#125;; 我们要知道，组件中调用的资源都是从父组件中传递过来的，所以我们需要把之前的图标也传递过来。 在Image中，我们初步写的函数中调用资源的话是 1source= &#123;...&#125; 那么我们需要把{...}这些资源传递到组件中，因此可以定义一个常量进行传递： 12345678910const images = &#123; Microphone: require('./icons/Microphone.png'), Microphone1: require('./icons/Microphone1.png'), Camera: require('./icons/Camera.png'), Camera1: require('./icons/Camera1.png'),&#125;;&lt;View&gt; &lt;EasyList memberList=&#123;memberList&#125; images=&#123;images&#125; /&gt;&lt;/View&gt; 至于如何读取，在上面的已经写过了，基本上思想是一样的就不重复的叙述了。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客多台电脑]]></title>
    <url>%2F2019%2F05%2F25%2FHexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[在公司用hexo搭好博客之后，突然有个疑问：我想要回到家继续写文章，那换了电脑之后该怎么更新博客呢？然后就开始智障了。通过谷歌，照着弄了好久，才弄好了。 思路：使用git分支。 准备工作和环境要求在这之前，首先你得有台电脑是配置好了的，也就是确保你已经使用hexo在github pages上面部署好你的个人博客，并在本地电脑拥有该博客的部署环境，即类似于以下图片的文件目录 对username.github.io仓库新建分支，并克隆在Github的username.github.io仓库上新建一个xxx分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为xxx，save保存；然后将该仓库克隆（必须要用命令行）到本地，进入该username.github.io文件目录。 完成上面步骤后，在当前目录使用Git Bash执行git branch命令查看当前所在分支，应为新建的分支xxx 将本地博客的部署文件拷贝进username.github.io文件目录并提交将本地博客的部署文件全部拷贝进username.github.io文件目录，将拷贝进来的博客hexo部署环境提交到xxx分支，提交之前需注意：将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。 执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push即可将博客的hexo部署环境提交到GitHub个人仓库的xxx分支。现在可以在GitHub上的*username*.github.io仓库看到两个分支的差异了。 master分支和xxx分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；xxx分支用于备份博客部署文件，供自己维护更新，保证了两者在一个GitHub仓库内互不冲突。至此你搭配好的电脑上的任务就完成了。 新电脑环境部署和更新首先你需要安装一下Hexo： 123npm install hexonpm installnpm install hexo-deployer-git --save 然后将新电脑的生成的ssh key添加到GitHub账户上 在新电脑上克隆username.github.io仓库的xxx分支到本地，此时本地git仓库处于xxx分支 切换到username.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录[也不需要]，所以需要install下. 然后就可以正常的编辑、撰写文章或其他博客更新改动。 依次执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push指令，保证xxx分支版本最新 执行hexo d -g指令（在此之前，有时可能需要执行hexo clean），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！ 注意：每次换电脑进行博客更新时，不管上次在其他电脑有没有更新（就怕更新之后忘了），最好先git pull获取xxx分支的最新版本，之后再进行编辑和提交。反正就是xjb弄就完事了。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习一]]></title>
    <url>%2F2019%2F05%2F25%2FReact%2F</url>
    <content type="text"><![CDATA[React是什么？React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。React 中拥有多种不同类型的组件。 12345678910111213141516171819class Square extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: null, &#125;; &#125; render() &#123; return ( &lt;div className="shopping-list"&gt; &lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Instagram&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;// 用法示例: &lt;Square name="Talk" /&gt; render 方法的返回值描述了你希望在屏幕上看到的内容。render 返回了一个 React 元素，这是一种对渲染内容的轻量级描述。一个组件接收一些参数，我们把这些参数叫做 props，然后通过 render 方法返回需要展示在屏幕上的视图的层次结构。如上面的代码中 Square 组件只会渲染一些内置的 DOM 组件，如&lt;div /&gt;、&lt;li /&gt;等，但是你也可以组合和渲染自定义的 React 组件。 第一个Reactdemo我们要实现一个列表，列表有Name和Job两列，我们能进行delete操作和submit操作。 安装环境要求以及运行环境至少要求：Node.js5.2版本以上 安装React 1npm install -g create-react-app 创建一个对应的目录存放文件，利用cmd命令行cd到对应的目录，执行以下命令： 123npx create-react-app react-tutorialcd react-tutorialnpm start 运行完之后将localhost:3000使用新的React应用程序弹出一个新窗口如下： 这个时候你去对应的react-tutorial文件夹下就能看到对应的文件了，这个时候你就可以打开/src目录，对里面的文件进行操作了，在你打开对应的localhost:3000的时候，在对应的编辑器里面进行操作保存的话对应的网站内容就会即时的进行更新，报错的信息也能很快地看到。 第一次修改尝试我们将里面的对应的App.js文件进行修改 1234567891011import React, &#123; Component &#125; from &apos;react&apos;class App extends Component &#123; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Hello, React!&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;export default App; 运行之后的效果图 我们将组件导出为App并加载index.js。将组件分离到文件中并不是强制性的，但如果不这样做，应用程序将开始变得笨拙和失控，就是对应的功能做到对应的文件里面，维护一个较好的功能树。 创建Table组件，实现放置列表首先创建一个Table.js文件。创建一个组件的方式有两种，一个是类组件，用类组件创建这个Table组件： 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react'class Table extends Component &#123; render() &#123; return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Job&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Charlie&lt;/td&gt; &lt;td&gt;Janitor&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mac&lt;/td&gt; &lt;td&gt;Bouncer&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Dee&lt;/td&gt; &lt;td&gt;Aspiring actress&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Dennis&lt;/td&gt; &lt;td&gt;Bartender&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; ) &#125;&#125;export default Table; 我们创建的这个组件是一个自定义类组件。我们将自定义组件大写，以区别于常规HTML元素。返回App.js，我们可以在表中加载，首先导入它： 1import Table from &apos;./Table&apos; 加载了之后我们才能在App.js文件中使用这个组件，不然是会报错的。那么加载了之后修改对应的render()函数内容 12345return ( &lt;div className=&quot;container&quot;&gt; &lt;Table /&gt; &lt;/div&gt;) 效果图如下： 另一种创建组件的方式是使用ES6箭头函数来创建这些简单的组件。它是一个函数。此组件不使用class关键字。我们修改一下刚才创建Table组件的方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243const TableHeader = () =&gt; &#123; return ( &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Job&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; )&#125;const TableBody = () =&gt; &#123; return ( &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Charlie&lt;/td&gt; &lt;td&gt;Janitor&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mac&lt;/td&gt; &lt;td&gt;Bouncer&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Dee&lt;/td&gt; &lt;td&gt;Aspiring actress&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Dennis&lt;/td&gt; &lt;td&gt;Bartender&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; )&#125;//修改对应的render()函数class Table extends Component &#123; render() &#123; return ( &lt;table&gt; &lt;TableHeader /&gt; &lt;TableBody /&gt; &lt;/table&gt; ) &#125;&#125; 刷新一下结果还是和之前的一样。 利用props和state进行数据的传输我们现在已经有了一个Table组件，但是数据是硬编码的，React的一个很好的点就是数据传输非常的方便，它使用props和state来实现。我们先使用props来进行数据传输。 props首先删除TableBody组件中的所有数据 123const TableBody = () =&gt; &#123; return &lt;tbody /&gt;&#125; 然后我们在它的父组件里面加入数据，并进行数据传输，我们进行数据传输的方式就是使用属性的方式传递给子组件： 123456789101112131415161718192021222324252627class App extends Component &#123; render() &#123; const characters = [ &#123; name: 'Charlie', job: 'Janitor', &#125;, &#123; name: 'Mac', job: 'Bouncer', &#125;, &#123; name: 'Dee', job: 'Aspring actress', &#125;, &#123; name: 'Dennis', job: 'Bartender', &#125;, ] return ( &lt;div className="container"&gt; &lt;Table characterData=&#123;characters&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 传递到了Table组件之后，我们需要把数据从这个组件内拿出来： 1234567891011121314151617181920212223//拿出来的方式通过数组映射返回数组每个对象，将其映射在rows变量中并返回const TableBody = props =&gt; &#123; const rows = props.characterData.map((row, index) =&gt; &#123; return ( &lt;tr key=&#123;index&#125;&gt; &lt;td&gt;&#123;row.name&#125;&lt;/td&gt; &lt;td&gt;&#123;row.job&#125;&lt;/td&gt; &lt;/tr&gt; ) &#125;) return &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt;&#125;class Table extends Component &#123; render() &#123; const &#123; characterData &#125; = this.props return ( &lt;table&gt; &lt;TableHeader /&gt; &lt;TableBody characterData=&#123;characterData&#125; /&gt; &lt;/table&gt; ) &#125;&#125; 这样的话数据传输就做完了，但是props呢，它只能进行读取并不能对于组件的信息进行改动，如果需要改动的话就需要state了，也就是实现我们的delete操作。 state首先需要在父组件里面创建一个state对象。存放我们之前的数据，为了更新状态，我们将使用this.setState()一种内置的方法来操作状态 12345678state = &#123; characters: [ &#123; name: 'Charlie', // the rest of the data &#125;, ], &#125; 我们需要通过一个函数来处理这件事情，filter就是之前在学习JavaScript的一个高阶函数 12345678removeCharacter = (index) =&gt; &#123; const &#123; characters &#125; = this.state this.setState(&#123; characters: characters.filter((character, i) =&gt; &#123; return i !== index &#125;), &#125;)&#125; 同时呢我们也需要把这个函数传给下面对应的组件，在App.js中进行更新： 12345return ( &lt;div className="container"&gt; &lt;Table characterData=&#123;characters&#125; removeCharacter=&#123;this.removeCharacter&#125; /&gt; &lt;/div&gt;) 在Table组件中也需要进行相应的更新操作：首先要提取出正确的数据，然后继续传递给下面的组件TableBody 123456789render() &#123; const &#123; characterData, removeCharacter &#125; = this.props return ( &lt;table&gt; &lt;TableHeader /&gt; &lt;TableBody characterData=&#123;characterData&#125; removeCharacter=&#123;removeCharacter&#125; /&gt; &lt;/table&gt; )&#125; 在TableBody中就需要添加对应的组件并对点击时间进行removeCharacter()方法的处理： 1234567&lt;tr key=&#123;index&#125;&gt; &lt;td&gt;&#123;row.name&#125;&lt;/td&gt; &lt;td&gt;&#123;row.job&#125;&lt;/td&gt; &lt;td&gt; &lt;button onClick=&#123;() =&gt; props.removeCharacter(index)&#125;&gt;Delete&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt; 该onClick函数必须通过一个返回该removeCharacter()方法的函数就实现了我们的需求。对应的效果图如下并且删除了一个Mac 至此初始化和删除操作就搞定了。 表单的提交通过表单的提交我们可以添加对应的数据，首先我们删除之前的数据，使它为空，然后我们创建一个From.js的文件，设置初始状态为Form具有一些空属性的对象，并将该初始状态指定给this.state。 1234567891011import React, &#123; Component &#125; from 'react'class Form extends Component &#123; constructor(props) &#123; super(props) this.initialState = &#123; name: '', job: '', &#125; this.state = this.initialState &#125;&#125; 我们对此表单的想法是每次在表单中更改字段的状态，并且当我们提交时，所有数据将传递到App状态，然后将更新状态Table。 首先我们定义一个函数handleChange ，在Input中添加Onchange属性调用改函数，使得它能获得Input组件输入的数据。 123456789101112131415161718192021222324252627handleChange = (event) =&gt; &#123; const &#123; name, value &#125; = event.target this.setState(&#123; [name]: value, &#125;) &#125;render() &#123; const &#123; name, job &#125; = this.state; return ( &lt;form&gt; &lt;label&gt;Name&lt;/label&gt; &lt;input type="text" name="name" value=&#123;name&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;label&gt;Job&lt;/label&gt; &lt;input type="text" name="job" value=&#123;job&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/form&gt; );&#125; 这个时候，这个表单已经能够成功的提交了。但是还不能渲染到父组件，我们需要做的最后一步就是在App.js文件创建一个名为handleSubmit() 的函数，传递到From.js组件，然后在该组件中调用这个函数，使得我们在App.js中能够成功的实际提交该数据并更新父状态。 App.js 1234567891011121314//我们实际提交该数据并更新父状态handleSubmit = character =&gt; &#123; this.setState(&#123; characters: [...this.state.characters, character] &#125;)&#125;render() &#123; const &#123; characters &#125; = this.state; return ( //使用属性将数据传递给子组件 &lt;div className="container"&gt; &lt;Table characterData=&#123;characters&#125; removeCharacter=&#123;this.removeCharacter&#125;/&gt; &lt;Form handleSubmit=&#123;this.handleSubmit&#125; /&gt; &lt;/div&gt; ) &#125; From.js 12345678onFormSubmit = (event) =&gt; &#123; event.preventDefault(); this.props.handleSubmit(this.state); this.setState(this.initialState); &#125;&lt;button type="submit" value="Submit" onClick=&#123;this.onFormSubmit&#125; &gt; Submit&lt;/button&gt; 差不多这样整个demo就跑通了。 流程是这样的，可能叙述的不是很清楚，大家可以去github上看下源码就能理解了，还是很基础的demo。 https://github.com/xiaorui2/FrontLearn/tree/master/react-tutorial/src]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语法熟悉三]]></title>
    <url>%2F2019%2F05%2F24%2FJs%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%E4%B8%89%2F</url>
    <content type="text"><![CDATA[JavaScript的异步处理AjaxAjax概念与工作流程AJAX 并非编程语言，它通过浏览器内建的 XMLHttpRequest 对象（从 web 服务器请求数据），然后利用JavaScript 和 HTML DOM（显示或使用数据）。它能够不刷新页面更新网页，在页面加载后从服务器请求和接收数据，在后台向服务器发送数据。 它的工作流程：网页中发生一个事件（页面加载、按钮点击） -&gt; JavaScript 创建 XMLHttpRequest 对象 -&gt; XMLHttpRequest 对象向 web 服务器发送请求 -&gt; 服务器处理该请求 -&gt; 服务器将响应发送回网页 -&gt; JavaScript读取响应并执行正确的动作（比如更新页面） 注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 Ajax实例123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt;table,th,td &#123; border : 1px solid black; border-collapse: collapse;&#125;th,td &#123; padding: 5px;&#125;&lt;/style&gt;&lt;body&gt;&lt;button type="button" onclick="loadDoc()"&gt;获取我的音乐列表&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;table id="demo"&gt;&lt;/table&gt;&lt;script&gt;function loadDoc() &#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myFunction(this); &#125; &#125;; xhttp.open("GET", "/demo/music_list.xml", true); xhttp.send();&#125;function myFunction(xml) &#123; var i; var xmlDoc = xml.responseXML; var table="&lt;tr&gt;&lt;th&gt;艺术家&lt;/th&gt;&lt;th&gt;曲目&lt;/th&gt;&lt;/tr&gt;"; var x = xmlDoc.getElementsByTagName("TRACK"); for (i = 0; i &lt;x.length; i++) &#123; table += "&lt;tr&gt;&lt;td&gt;" + x[i].getElementsByTagName("ARTIST")[0].childNodes[0].nodeValue + "&lt;/td&gt;&lt;td&gt;" + x[i].getElementsByTagName("TITLE")[0].childNodes[0].nodeValue + "&lt;/td&gt;&lt;/tr&gt;"; &#125; document.getElementById("demo").innerHTML = table;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; XMLHttpRequest对象方法和属性 方法 描述 new XMLHttpRequest() 创建新的 XMLHttpRequest 对象 getAllResponseHeaders() 返回头部信息 open(method, url, async, user, psw) 规定请求method：请求类型 GET 或 POSTurl：文件位置，使用的是相对路径async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码 send() 将请求发送到服务器，用于 GET 请求 send(string) 将请求发送到服务器，用于 POST 请求 onreadystatechange 定义当 readyState 属性发生变化时被调用的函数 readyState 保存 XMLHttpRequest 的状态。0：请求未初始化1：服务器连接已建立2：请求已收到3：正在处理请求4：请求已完成且响应已就绪 responseText/XML 以字符串/XML返回响应数据 status 返回请求的状态号：200: &quot;OK&quot;403: &quot;Forbidden&quot;404: &quot;Not Found&quot; CORS跨域在Ajax上我们知道输入URL使用的是相对路径，这是浏览器的同源策略导致的，也就是在发送AJAX请求时，URL的域名必须和当前页面完全一致，不然会报错。这也就是跨域 Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。 Promise在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现，上面的Ajax就是典型的异步操作。 Promise是另一种异步的操作 它的处理想法就是先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。 123456789101112131415161718192021222324function test(resolve, reject) &#123; var timeOut = Math.random() * 2; log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () &#123; if (timeOut &lt; 1) &#123; log('call resolve()...'); resolve('200 OK'); &#125; else &#123; log('call reject()...'); reject('timeout in ' + timeOut + ' seconds.'); &#125; &#125;, timeOut * 1000);&#125;var p1 = new Promise(test);//变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象：//如果成功，执行这个函数：var p2 = p1.then(function (result) &#123; console.log('成功：' + result);&#125;);//如果失败，执行这个函数：var p3 = p2.catch(function (reason) &#123; console.log('失败：' + reason);&#125;); 最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了 再看一个： 12345678910111213141516171819202122232425262728293031'use strict';function log(s) &#123; var p = document.createElement('p'); p.innerHTML = s; logging.appendChild(p);&#125;// 0.5秒后返回input*input的计算结果:function multiply(input) &#123; return new Promise(function (resolve, reject) &#123; log('calculating ' + input + ' x ' + input + '...'); setTimeout(resolve, 500, input * input); &#125;);&#125;// 0.5秒后返回input+input的计算结果:function add(input) &#123; return new Promise(function (resolve, reject) &#123; log('calculating ' + input + ' + ' + input + '...'); setTimeout(resolve, 500, input + input); &#125;);&#125;var p = new Promise(function (resolve, reject) &#123; log('start new Promise...'); resolve(123);&#125;);p.then(multiply) .then(add) .then(multiply) .then(add) .then(function (result) &#123; log('Got value: ' + result);&#125;); Promise还可以并行执行异步任务。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运输层]]></title>
    <url>%2F2019%2F05%2F23%2F%E4%BC%A0%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[运输层概念运输层是位于应用层和网络层之间，为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用，主要要理解的就是我们常用的UDP和TCP协议。通常我们知道的TCP它是一个可靠的传输连接，而UDP是一个不可靠的传输连接。 无连接运输：UDPUDP做的事它是基于Internet IP协议，做了（传输层都要做的功能）复用 / 分用，简单的错误检测。它是无连接的，UDP发送方和接收方之间不需要握手，每个UDP段的处理独立于其他段，并且UDP段可能丢失，非按序到达。 UDP为什么存在因为无需要建立连接（减少延迟），实现简单，无需维护连接状态，头部开销少，没有拥塞控制，应用可以更好的控制发送时间和速率。用于DNS，SNMP等。 如何在UDP上实现可靠数据传输在应用层增加可靠性机制，应用特定的错误恢复机制。（在应用层保证数据传输可靠）添加seq/ack机制，确保数据发送到对端，添加发送和接收缓冲区，主要是用户超时重传，添加超时重传机制 详细说明：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。 UDP的数据格式和校验和 可靠的数据传输原理什么叫可靠？数据不错，不丢，不乱。可靠数据传输对应用层，传输层，链路层都很重要。信道的不可靠性决定可靠数据传输协议（rdt）的复杂性。 可靠的数据传输协议基本结构是通过接口来实现的。调用一些 rdt_send()，rdt_rcv() ，deliver_data()这些函数接口。 可靠信道上的可靠数据传输和产生位错误的信道上的可靠数据传输首先底层信道完全可靠（不会发生错误，不会丢弃分组），发送放和接收方的FSM（有限状态自动机）独立。 在会产生错误的信道传输会利用校验和来检测位错误，发送ACK（接收方显示的告知发送发分组已经正确的接收）或者NAK（错误的接收）当发现错误的时候会利用重传机制重传分组。 从可靠数据传输流水线可靠数据传输Rdt2.1：如何解决重复分组问题：给每个分组增加序列号，接收方丢弃重复分组。应对ACK/NAK破坏或者被损坏的情况。 Rdt2.2：无NAK消息协议，与Rdt2.1功能相同，但是只使用ACK。如何实现？接收方通过ACK告知最后一个被正确接收的分组，在ACK消息中显示的加入被确认分组的序列号。发送发收到重复的ACK之后，采取和收到NAK的动作一样。 Rdt3.0：如果信道既可能发生错误也可能丢失分组，那么校验和+序列号+ACK+重传就不够用了（比方说ACK消息丢失了，发送方就一直在等待）解决方法也很简单：给发送方设置一个合理的时间，如果没有收到ACK就重传。但是这个合理的时间是很难确定的。那么就是需要设置定时器。Rdt3.0能够正常工作，但是性能很差。主要是由于停等协议导致的。 基于Rdt3.0，可以不使用停等协议，允许发送方发送多个分组而无需等待确认，只要最后能收获到ACK确认的技术就是流水线。可因此也需要增加一些内容： 允许发送发在收到ACK之前连续发送多个分组，需要更大的序列号范围；发送方和接收方需要更大存储空间以缓存分组；出现错误时候的处理：滑动窗口协议（主要是回退N步和选择重传） 滑动窗口协议1比特滑动窗口协议（停等协议）当发送窗口和接收窗口的大小固定为1时，滑动窗口协议退化为停等协议。该协议规定发送方每发送一帧后就要停下来，等待接收方已正确接收的确认（ACK）返回后才能继续发送下一帧。由于接收方需要判断接收到的帧是新发的帧还是重新发送的帧，因此发送方要为每一个帧加一个序号。由于停等协议规定只有一帧完全发送成功后才能发送新的帧，因而只用一比特来编号就够了，具有累计确认机制。 回退N帧协议发送窗口大于1，接收窗口大于1， 由于停等协议要为每一个帧进行确认后才继续发送下一帧，大大降低了信道利用率，因此又提出了后退n协议。后退n协议中，发送方在发完一个数据帧后，不停下来等待应答帧，而是连续发送若干个数据帧，即使在连续发送过程中收到了接收方发来的应答帧，也可以继续发送。且发送方在每发送完一个数据帧时都要设置超时定时器。只要在所设置的超时时间内仍收到确认帧，就要重发相应的数据帧。如：当发送方发送了N个帧后，若发现该N帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不重新发送出错帧及其后的N帧。 选择重传协议发送窗口大于1，接收窗口大于1。在后退n协议中，接收方若发现错误帧就不再接收后续的帧，即使是正确到达的帧，这显然是一种浪费。另一种效率更高的策略是当接收方发现某帧出错后，其后继续送来的正确的帧虽然不能立即递交给接收方的高层，但接收方仍可收下来，存放在接收缓冲区中，同时要求发送方重新传送出错的那一帧。一旦收到重新传来的帧后，就可以原已存于缓冲区中的其余帧一并按正确的顺序递交高层。这种方法称为选择重发(SELECTICE REPEAT)。显然，选择重发减少了浪费，但要求接收方有足够大的缓冲区空间。 有连接运输：TCPTCP特点它是一个点到点的通信机制，只能有一个发送方和一个接收方；它提供是一个可靠的，按序的字节流机制；使用流水线机制，通过拥塞控制和流量控制的机制设置窗口尺寸；发送方和接收方都有缓存；它是一个全双工，能双向传输数据的面向连接的通信，通信双方必须在发送数据之前建立连接，连接状态只能在连接的两端维护，不能在沿途的结点维护状态。 TCP报文段结构 源地址端口，目的端口地址 序号：TCP传输保证连接性，发送的每个字节都要编上号 确认号：接收方期望从对方接受的字节编号。如果报文段的接收方成功的接受了对方发过来的编号x的字节，那么返回x+1作为确认号，确认号可以和数据捎带一起发送） 控制：定义了6中不同的控制位或者标志位：URG:紧急数据标志位，ACK：确认标志位，PSH：请求推送位，接收端应尽快把数据传送给应用层，RST：连接复位，通常，如果TCP收到的一个分段明显不属于该主机的任何一个连接，则向远程发送一个复位包，SYN：建立连接，让连接双方同步序列号，FIN：释放连接 检验和：TCP的使用检验和是强制性的,UDP使用检验和是可选的。在计算检验和是报文段要附加相同的伪首部，对于TCP来说伪首部的协议字段的值是6 TCP实现可靠数据传输TCP在IP层提供的不可靠服务基础上实现的可靠数据传输，使用流水线机制，累积确认机制，单一的重传计时器。触发重传的事件：超时，收到重复的ACK。 快速重传机制TCP实现中，如果发生超时时间，超时时间间隔会重新设置，即将超时时间间隔加倍，导致其很大，重发丢失分组的时间会等待很久的时间。可以通过重复ACK检测检测分组丢失，Sender收到同一个数据的3个ACK，则假定该数据之后的段已经丢失，即在定时器超时之前进行重传。 TCP流量控制接收方为TCP连接分配buffer 如果上层应用处理buffer中的数据较慢，发送方在这个机制下发送方不会传输的太多太快以至于淹没接收方（buffer溢出）实现的时候就是Received在Segment的头部字段中将RcvWindow告诉Sender，Sender限制自己发送的但还没收到ACK的数据不超过接收方的空闲RECWindow的尺寸。但是如果Received告知Sender RcvWindow=0是，发送方仍然可以发送一个很少的数据段，从而更新RcvWindow的值 TCP拥塞控制首先，拥塞控制和流量控制是不一样的。拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程。流量控制是点对点通信量的控制，是一个端到端的问题，主要就是抑制发送端发送数据的速率，以便接收端来得及接收。 拥塞的标志：重传计时器超时，接收到三个重复确认。 发送方维持一个叫做拥塞窗口的状态变量。拥塞窗口的大小取决于网络的拥塞程度，且动态地在变化，我们使用TCP拥塞控制算法，该算法包括：慢开始和拥塞避免以及快速恢复。 慢启动和拥塞避免慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大（指数的增长）逐渐增加拥塞窗口的大小。拥塞避免则是让拥塞窗口缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞控制窗口加一 为了防止拥塞窗口增长过大引起网络拥塞，设置一个慢开始门限（ssthresh状态变量）当拥塞窗口＜ssthresh，使用慢开始算法（指数增长）当拥塞窗口=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法（线性增长）当拥塞窗口＞ssthresh，使用拥塞避免算法 但是无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。 快速恢复与快速重传配合使用采用快速恢复算法时，慢开始只在TCP连接建立时和网络出现超时时才使用。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。 TCP连接管理TCP的三次握手 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x（随机数）； 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置ACK为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y； 客户端收到服务器的SYN+ACK报文段。然后将ACK设置为y+1，向服务器发送ACK报文段， 为什么需要三次握手？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 TCP的四次挥手 为什需要四次挥手？ TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 为什么TCP采用随机初始序列号在TCP的三次握手中，后采用随机产生的初始化序列号进行请求，这样做主要是出于网络安全的因素着想。如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段。 客户端和服务器最多能发送和接收多少TCP连接数？对于服务器，每一个TCP连接都要占一个文件描述符，一旦这个文件描述符使用完了，就会返回错误。我们知道操作系统上端口号1024以下是系统保留的，从1024-65535是用户使用的。由于每个TCP连接都要占一个端口号，所以我们最多可以有60000多个并发连接？但是事实并不是这样。 我们还知道对于TCP连接是由：原IP，原端口，目的IP，目的端口。但是监听server端TCP连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因为它是固定在本地的端口上去监听，所以最大TCP连接为：客户端ip数×客户端port数. 而对于客户端，网络通信过程中服务端监听一个固定的端口,客户端主动发起连接请求后要经过三次握手才能与服务器建立起一个TCP连接.客户端每次发起一个TCP连接时,系统会随机选取一个空闲的端口,该端口是独占的不能与其他TCP连接共享,因此理论上一台机器有多少空闲的端口,就能对外发起多少个TCP连接。根据TCP/IP协议,端口port使用16位无符号整数unsigned short来存储,因此本地端口一共有2^16=65536个,即0-65535,其中0~1023是预留端口,0有特殊含义不能使用,1024以下端口都是超级管理员用户(如root)才可以使用,因此就算使用root权限,一台机器最多能使用的端口也只有65535个。但是一台机器最多只能利用28232个端口.]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React长列表优化方案]]></title>
    <url>%2F2019%2F05%2F23%2FReactNative%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[考虑问题我有一个列表，这个列表里面我需要存放10000条数据，我要使得这个列表进行滑动的时候比较流畅，也就是渲染的效果ok。 对这个问题分析一下，我们知道DOM结构如果过大, 网页就会出现用户操作体验上的问题, 比如滚动, 点击操作，会导致渲染的不够及时情况发生。 解决方案解决方案的话就是对于列表形态的数据展示的按需渲染。这种方式是指根据容器元素的高度以及列表项元素的高度来显示长列表数据中的某一个部分，而不是去完整地渲染长列表。通俗的说就是我就渲染我可见的区域的组件，也就是虚拟列表，它是一种根据滚动容器元素的可视区域来渲染长列表数据中某一个部分数据的技术。 实现虚拟列表就是在处理用户滚动时，要改变列表在可视区域的渲染部分，其具体步骤如下结合图片理解一下： 计算当前可见区域起始数据的 startIndex 计算当前可见区域结束数据的 endIndex 计算当前可见区域的数据，并渲染到页面中 计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上 计算 endIndex对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到列表上。 在React上就是使用react-window 和 react-virtualized是热门的虚拟滚动库，而在ReactNative中，我们可以使用Flatlist和Sectionlist组件，这两个组件呢是继承于VirtualizedLis，这个组件的思想也就是维护活动项的有限渲染窗口并用适当大小的空白空间替换渲染窗口之外的所有项，大大提高了大型列表的内存消耗和性能。这样已经能满足大多数情况下的使用，但是这个有一个问题就是当我们更快地滚动时会暂时看到空白内容。我测试了一下，大部分的软件在滑动过快的时候也就会出现加载上的情况等待加载。 所以使用Flatlist和Sectionlist组件能解决常用的长列表问题，至于Flatlist内容的更多优化，可以参考http://yangguang1029.github.io/2018/12/20/rn-improve-flatlist/]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css概念和基础语法]]></title>
    <url>%2F2019%2F05%2F23%2FCss%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Css概念它是一个层叠样式表，存储着很多的样式，而样式定义着如何显示Html元素，因此解决了内容与表现分离的问题，就是我Html只需要写内容，然后用Css来控制它的表现。 当同一个Html元素被不止一个样式定义的时候，会根据优先级高低控制，优先级从高到低依次是： 内联样式（在 Html元素内部）-&gt; 内部样式表（位于 &lt;head&gt; 标签内部）-&gt; 外部样式表 -&gt; 浏览器缺省设置 Css基础Css语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 选择器通常是您需要改变样式的 Html元素。每条声明由一个属性和一个值组成。属性就是希望设置的样式属性。你也可以对选择器进行分组，如下： 123h1,h2,h3,h4,h5,h6 &#123; color: green; &#125; Css的选择器派生选择器用于根据文档的上下文关系来确定某个标签的样式，比方说希望列表中的strong元素变为斜体字，那么我选择器就写成li strong {...}，这样的话只有 li元素中的strong元素的样式为斜体字，不在li元素内部的就还是正常的粗体字. id选择器id 选择器以&quot;#&quot; 来定义。可以独立的调用如：#red {color:red;}。它可以利用派生选择器的思想进行联合使用，比方： 12345#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em; &#125; 那么上面的样式只会应用于出现在id 是 sidebar 的元素内的段落。 注意：id属性只能在每个 Html 文档中出现一次。 类选择器它以一个点号显示： 1234.center &#123;text-align: center&#125;&lt;h1 class="center"&gt;This heading will be center-aligned&lt;/h1&gt; 注意：类名的第一个字符不能使用数字。 属性选择器它以为拥有指定属性的HTML 元素设置样式，而不仅限于class和 id属性，对带有指定属性的HTML 元素设置样式。它还可以绑定值： 12345&lt;!-- 不带后面的等号内容的时候就是为所有带有 title 属性的所有元素设置样式 --&gt;[title=W3School]&#123;border:5px solid blue;&#125; 属性选择器在为不带有 class 或id的表单设置样式时特别有用，如设置表单的样式 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;input[type="text"]&#123; width:150px; display:block; margin-bottom:10px; background-color:yellow; font-family: Verdana, Arial;&#125;input[type="button"]&#123; width:120px; margin-left:35px; display:block; font-family: Verdana, Arial;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form name="input" action="" method="get"&gt;&lt;input type="text" name="Name" value="Bill" size="20"&gt;&lt;input type="text" name="Name" value="Gates" size="20"&gt;&lt;input type="button" value="Example Button"&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 如何插入一个样式表外部样式表个页面使用 &lt;link&gt;标签链接到样式表。&lt;link&gt;标签在（文档的）头部： 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;&lt;/head&gt; 内部样式表当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 &lt;style&gt;标签在文档头部定义内部样式表，就像这样: 1234567&lt;head&gt;&lt;style type="text/css"&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125; body &#123;background-image: url("images/back40.gif");&#125;&lt;/style&gt;&lt;/head&gt; 内联样式当样式仅需要在一个元素上应用一次时。 123&lt;p style="color: sienna; margin-left: 20px"&gt;This is a paragraph&lt;/p&gt; 注意：如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。相同的时候按优先级来选择继承。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html语法熟悉]]></title>
    <url>%2F2019%2F05%2F23%2FHtml%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Html基础Html 标题Heading是通过 &lt;h1&gt; - &lt;h6&gt; 等标签进行定义的 12&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;h2&gt;This is a heading&lt;/h2&gt; Html段落它是通过 &lt;p&gt;标签进行定义的 1&lt;p&gt;This is a paragraph.&lt;/p&gt; Html折行通过&lt;br/&gt;实现折行 1&lt;p&gt;This is&lt;br /&gt;a para&lt;br /&gt;graph with line breaks&lt;/p&gt; Html水平线是通过&lt;hr/&gt;用于在页面中创建水平线 12&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;hr/&gt; Html链接1&lt;a href="http://www.w3school.com.cn"&gt;This is a link&lt;/a&gt; Html图像通过&lt;img&gt;标签进行定义的，可以定义它的大小，位置等，还有一个代替文本 1&lt;img src="w3school.jpg" width="104" height="142" alt="Big Boat"&gt; Html元素是从开始标签到结束标签的所有代码。 12345&lt;html&gt;&lt;body&gt;&lt;p&gt;This is my first paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 以上实例就是有三个元素，&lt;html&gt;元素，&lt;body&gt; 元素，&lt;p&gt;元素。对应的元素内容就是body元素，p元素和This is my first paragraph。 Html属性可以给Html元素提供更多的信息，并且属性总是在 Html元素的开始标签中规定。比方说它可以定义这个元素在哪个位置呈现，背景颜色是什么，是否加个链接，样式是什么这些的。列一点： 属性 值 描述 class classname 规定元素的类名（classname） id id 规定元素的唯一 id style style_definition 规定元素的行内样式（inline style） title text 规定元素的额外信息（可在工具提示中显示） 注意Html的style属性可以直接使用 style 属性直接将样式添加到 HTML元素，也可以间接地在独立的样式表中（CSS 文件）进行定义。比方说设置一下字体，大小，颜色等： 12345&lt;html&gt;&lt;body&gt;&lt;p style=&quot;font-family:arial;color:red;font-size:20px;&quot;&gt;A paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Html文本格式化对应标签： 标签 描述 &lt;b&gt; 定义粗体文本。 &lt;big&gt; 定义大号字。 &lt;i&gt; 定义斜体字。 &lt;small&gt; 定义小号字。 &lt;strong&gt; 定义加重语气。 &lt;sub&gt; 定义下标字。 &lt;sup&gt; 定义上标字。 &lt;ins&gt; 定义插入字。 Html引用是通过&lt;q&gt;元素定义短的引用， &lt;blockquote&gt;元素定义被引用的节且会进行缩进处理。 Html缩进利用&lt;abbr&gt; 。 Html&lt;address&gt;元素定义文档或文章的联系信息（作者/拥有者）。且此元素通常以斜体显示。大多数浏览器会在此元素前后添加折行。 Html的计算机代码格式对于计算机代码格式利用&lt;kbd&gt;（定义键盘输入）, &lt;samp&gt;（定义计算机输出示例）, &lt;pre&gt;（定义预格式化文本）以及 &lt;code&gt;（定义计算机代码文本）元素，如： 1234567891011&lt;p&gt;Coding Example:&lt;/p&gt;&lt;code&gt;&lt;pre&gt;var person = &#123; firstName:"Bill", lastName:"Gates", age:50, eyeColor:"blue"&#125;&lt;/pre&gt;&lt;/code&gt; Html链接它的name属性，它规定了锚的名称，当使用命名锚时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接。如： 123456首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：&lt;a name="tips"&gt;基本的注意事项 - 有用的提示&lt;/a&gt;然后，我们可以在同一个文档中创建指向该锚的链接：&lt;a href="#tips"&gt;有用的提示&lt;/a&gt;也可以在其他页面中创建指向该锚的链接&lt;a href="http://www.w3school.com.cn/html/html_links.asp#tips"&gt;有用的提示&lt;/a&gt; Html列表： 标签 描述 &lt;ol&gt; 定义有序列表。 &lt;li&gt; 定义列表项。 &lt;ul&gt; 定义无序列表。 &lt;dl&gt; 自定义列表 &lt;dt&gt; 自定义项目 &lt;dd&gt; 自定义描述 Html的&lt;div&gt;元素它是一个块级元素(块级元素在浏览器显示时，通常会以新行来开始（和结束）)可用于组合其他Html元素的容器。 Html的类和布局对 HTML 进行分类（设置类），使我们能够为元素的类定义 CSS 样式。为相同的类设置相同的样式，或者为不同的类设置不同的样式。联合&lt;div&gt;理解，&lt;div&gt;把这个html分块了，有的块样式相同有的不相同就可以使用相同的类或者不同的类，如： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.cities &#123; background-color:black; color:white; margin:20px; padding:20px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="cities"&gt;&lt;h2&gt;London&lt;/h2&gt;&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;/div&gt;&lt;div class="cities"&gt;&lt;h2&gt;Paris&lt;/h2&gt;&lt;p&gt;Paris is the capital and most populous city of France.&lt;/p&gt;&lt;/div&gt;&lt;div class="cities"&gt;&lt;h2&gt;Tokyo&lt;/h2&gt;&lt;p&gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area,and the most populous metropolitan area in the world.&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 同理Html的 &lt;span&gt; 元素是行内元素，能够用作文本的容器。设置 &lt;span&gt;元素的类，能够为相同的&lt;span&gt;元素设置相同的样式。 布局的话就是Html和Css的联合使用了，利用Html语言对我们需要呈现的内容就行分块，然后Css对于这些分好的块填充样式，包括放哪。这样的结合之后就可以写出一个静态的页面了。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接下来三个月事情安排]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%8E%A5%E4%B8%8B%E6%9D%A5%E4%B8%89%E4%B8%AA%E6%9C%88%E4%BA%8B%E6%83%85%E5%AE%89%E6%8E%92%2F</url>
    <content type="text"><![CDATA[这次我选择去深圳，做一个前端的实习，前端对于我来说是一个很陌生的环境，其实想去找后台的工作，但我对于后台也不是很熟悉，只是对语言熟悉一些，具体的业务和开发流程熟悉的不够，所以我想多尝试一下。除了项目上的更多的熟悉，基础的知识方面也不能忘，这是对自己的要求，好好准备三个月冲刺一下准备秋招。不让任何人失望，不让自己最后觉得自己没有拼尽全力。加油，自己！ 打算完成的事情（不断更新）： 1.实习时候前端安排到的学习任务，项目任务。在步入正轨的时候尝试的去接触一下后台开发 2.SpringBoot学习，花一个月的时间把牛客高级项目课的内容搞定，理解的那种，所有的内容记录好博客。（这玩意等到自己熟悉了前端的这块内容之后再去看） 3.计算机网络自定向下，主要是传输层那块的内容，网络编程，学习内容记录 4.操作系统设计与实现，熟悉进程线程的那块 5.高性能Mysql，redis，牛客网的sql题，特别是数据库的索引那块内容 6.Java语言和JavaScript语言的熟悉，用Java语言去刷LeetCode，保持自己的做题能力，每天完成5道简单题，2-3进阶题，记录自己的结题思路。（做题数这块要改一下，还是和SpringBoot学习一样，现在一天做个一两道等到步入正轨的时候开始按计划完成一定的数量） 7.看一些之前自己没看的文学书：围城，我们仨，充实一下自己内心，改一下自己急躁的性格 8.关注助理的事情，把最后几个月的学生工作做好结尾]]></content>
      <categories>
        <category>事务安排和感想</category>
      </categories>
      <tags>
        <tag>安排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理机调度和死锁]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[概念在多道程序环境下，进程数目往往多于处理机数目，致使它们竞争使用处理机。这就要求系统能按某种算法，动态地把处理机分配给就绪队列中的一个进程，使之执行。一个作业从提交开始，往往要经历三级调度：高级调度、中级调度、低级调度。 高级调度：调度对象是作业。 中级调度：提高内存利用率和系统吞吐量。 低级调度：它所调度的对象是进程。进程调度是最基本的一种调度。进程调度方式有两种调度方式：非抢占方式和抢占方式（基于优先权，短作业优先，时间片原则）。 作业调度和进程调度的区别作业调度为进程活动做准备，进程调度使进程活动起来 作业调度次数少，进程调度次数多 有的系统不设作业调度，但进程调度必不可少 进程调度算法FCFS先来先服务该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。FCFS 算法比较有利于长作业(进程)，而不利于短作业(进程)。 短作业优先短作业优先调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。 高优先权优先调度算法（动态优先权）动态优先级调度算法是指在创建进程之初，先赋予其一个优先级，然后其值随着进程的推进或等待时间的增加而改变，以便获得更好的调度性能。例如，可以规定在就绪队列中的进程随其等待的时间的正常，使其优先级相应提高。若所有的进程都具有相同的优先级初值，则最先进入就绪队列的进程会因为其优先级变得最高，而优先获得处理机，这相当于FCFS算法。若所有的就绪进程具有各不相同的优先级初值，那么对于优先级初值低的进程，在等待了足够的时间后，也可以获得处理机。 基于时间片的轮转调度算法在分时系统中，为保证能及时响应用户的请求，必须采用基于时间片的轮转式进程调度算法。每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。 死锁产生死锁原因竞争资源（多个进程竞争共享的资源），进程间推进顺序非法（进程请求和释放的资源顺序不当） 产生死锁的条件互斥条件，请求和保持条件，不剥夺条件，环路等待条件。 处理死锁的几种条件预防死锁，避免死锁，检测死锁，解除死锁。 银行家算法它是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。 安全序列是指一个进程序列{P1，…，Pn}是安全的，即对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。（即在分配过程中，不会出现某一进程后续需要的资源量比其他所有进程及当前剩余资源量总和还大的情况）注：存在安全序列则系统是安全的，如果不存在则系统不安全，但不安全状态不一定引起死锁。 原理过程：系统给当前进程分配资源时，先检查是否安全：在满足当前的进程X资源申请后，是否还能有足够的资源去满足下一个距最大资源需求最近的进程（如某进程最大需要5个单位资源，已拥有1个，还尚需4个），若可以满足，则继续检查下一个距最大资源需求最近的进程，若均能满足所有进程，则表示为安全，可以允许给当前进程X分配其所需的资源申请，否则让该进程X进入等待。（注：检查过程中，每拟满足一个进程，则进行下个检查时，当前可用资源为回收上一个进程资源的总值，每满足一个进程表示此进程已结束，资源可回收。） 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;string&gt;using namespace std;const int maxnsource = 100;const int maxnprocess = 50;int available[maxnsource];//可以使用的资源。int max[maxnprocess][maxnprocess];//最大需求矩阵。int allocation[maxnprocess][maxnprocess];//已经分配的矩阵。int need[maxnprocess][maxnprocess];//还需要的矩阵。int requestsource[maxnprocess][maxnprocess];//进程请求的矩阵。int finish[maxnprocess];//进程是否能得到足够的资源使其结束。int n, m;int i, j;int p[maxnsource];//记录进程号int safe()//判断是否为安全的&#123; int cnt = 0; int flag = 0; int temp[maxnsource]; for (i = 0; i &lt; n; i++) temp[i] = available[i]; for (i = 0; i &lt; m; i++) &#123; if (finish[i] == 0) &#123; for (j = 0; j &lt; n; j++) &#123; if (need[i][j] &gt; temp[j]) break; &#125; if (j == n) &#123; finish[i] = 1; for (int k = 0; k &lt; n; k++) temp[k] += allocation[i][k]; p[cnt++] = i; i = -1;//这里不是0,重置之后i++会变为1，就错了。 &#125; else continue; if (cnt == m) &#123; cout &lt;&lt; "系统是安全的" &lt;&lt; endl; cout &lt;&lt; "安全序列:" &lt;&lt; endl; for (i = 0; i&lt;cnt; i++) &#123; cout &lt;&lt; p[i]; if (i != cnt - 1) &#123; cout &lt;&lt; "--&gt;"; &#125; &#125; cout &lt;&lt; "" &lt;&lt; endl; return 1; &#125; &#125; &#125; cout &lt;&lt; "系统是不安全的" &lt;&lt; endl; return 0;&#125;void bank()//银行家算法&#123; int cur; while (1) &#123; cout &lt;&lt; "输入要申请资源的进程号" &lt;&lt; endl; cin &gt;&gt; cur; cout&lt;&lt; "输入进程所请求的各资源的数量" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) cin &gt;&gt; requestsource[cur][i]; for (int i = 0; i &lt; n; i++) &#123; if (requestsource[cur][i] &gt; need[cur][i]) &#123; cout &lt;&lt; "输入的请求数超过进程的需求量!请重新输入!" &lt;&lt; endl; continue; &#125; if (requestsource[cur][i] &gt; available[i]) &#123; cout &lt;&lt; "输入的请求数超过系统有的资源数!请重新输入!" &lt;&lt; endl; continue; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; available[i] -= requestsource[cur][i]; allocation[cur][i] += requestsource[cur][i]; need[cur][i] -= requestsource[cur][i]; &#125; for (int i = 0; i &lt; m; i++) finish[i] = 0; if (safe()) &#123; cout &lt;&lt; "同意分配请求!" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "您的请求被拒绝!" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; available[i] += requestsource[cur][i]; allocation[cur][i] -= requestsource[cur][i]; need[cur][i] += requestsource[cur][i]; &#125; for (int i = 0; i &lt; m; i++) finish[i] = 0; string s; cout &lt;&lt; "是否还想再次请求分配吗?如果想，请输入YES" &lt;&lt; endl; cin &gt;&gt; s; if (s == "YES") continue; else break; &#125; &#125;&#125;int main()&#123; memset(finish, 0, sizeof(finish)); cout &lt;&lt; "输入进程的数量:"; cin &gt;&gt; m; cout &lt;&lt; "输入资源的种类:"; cin &gt;&gt; n; cout &lt;&lt; "输入每个进程最多所需要的资源数："; for (i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; max[i][j]; cout &lt;&lt; "输入每个进程已经分配的资源数："; for (i = 0; i &lt; m; i++) &#123; for (j = 0; j &lt; n; j++) &#123; cin &gt;&gt; allocation[i][j]; need[i][j] = max[i][j] - allocation[i][j]; if (need[i][j] &lt; 0) &#123; cout &lt;&lt; "输入的第" &lt;&lt; i + 1 &lt;&lt; "个进程所拥有的第" &lt;&lt; j + 1 &lt;&lt; "个资源数 错误,请重新输入:" &lt;&lt; endl; j--; continue; &#125; &#125; &#125; cout &lt;&lt; "输入各资源现有的资源数："; for (i = 0; i &lt; n; i++) cin &gt;&gt; available[i]; /*for (i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; max[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125; for (i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; allocation[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125; for (i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; need[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125;*/ safe(); bank(); return 0;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程（持续更新）]]></title>
    <url>%2F2019%2F05%2F22%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概念与区别从本质上来说，一个进程就是一个正在执行的程序，它是系统进行资源分配和调度的基本单位，是操作系统结构的基础。每个进程都有自己的地址空间，包括可执行程序，程序的数据，栈，一组寄存器（程序计算器，栈指针以及其他运行程序需要的信息 线程有时被称为轻量级进程，是程序执行的最小执行流，它是进程的一个实体，是系统独立调度和分派的基本单位 进程和线程的区别： 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。 资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程 执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 线程是处理器调度的基本单位，但是进程不是。 两者均可并发执行。 进程进程的创建和终止进程的创建主要有四个原因：系统初始化，正在运行的进程执行了创建进程的系统调用，用户请求创建一个进程以及批处理作业的初始化。 常见的就是一个进程调用了fork()函数创建新的进程。 进程终止的一些原因：工作完成正常退出，出错退出，严重错误，被其他进程杀死。 进程的状态和控制原语进程有三种状态：运行态，阻塞态，就绪态。这三种状态的转换是： 就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。 阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。 运行：当一个进程在处理机上运行时，则称该进程处于运行状态。 注意不可能存在直接从阻塞态转换到执行态。 除了这三个基本状态还有一个挂起状态，新建状态，终止状态。 引起挂起状态的原因：终端用户的请求，父进程请求，负荷调节的需要，操作系统的需要。 用于控制进程的原语有： 创建原语（Create）：创建一个就绪状态的进程，使进程从创建状态变迁为就绪状态。 阻塞原语（Block）：使进程从执行状态变迁为阻塞状态。 唤醒原语（Wakeup）：使进程从阻塞状态变迁为就绪状态。 挂起原语（Suspend）：将指定的进程或处于阻塞的进程挂起]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语法熟悉二]]></title>
    <url>%2F2019%2F05%2F22%2FJs%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%891%2F</url>
    <content type="text"><![CDATA[JavaScript输出使用window.alert()12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;window.alert(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用innerHTML写入Html元素如需访问 HTML 元素，JavaScript 可使用 document.getElementById(id) 方法。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt; document.getElementById(&quot;demo&quot;).innerHTML = 5 + 6;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; console.log()写入控制台12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;console.log(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用document.write()写入Html元素12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;document.write(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 但是在 HTML 文档完全加载后使用 document.write()将删除所有已有的 HTML，所以只用于测试 什么时候产生NaN表达式计算一个表达式中如果有减号 (-)、乘号 (*) 或 除号 (/) 等运算符时，JS 引擎在计算之前，会试图将表达式的每个分项转化为 Number 类型（使用 Number(x) 做转换）。如果转换失败，表达式将返回 NaN 。 123456100 - '2a' ; // NaN'100' / '20a'; // NaN'20a' * 5 ; // NaNundefined - 1; // NaN, Number(undefined) == NaN[] * 20 ; // 0, Number([]) == 0null - 5; // -5, Number(null) == 0 类型转换直接使用 parseInt，parseFloat 或 Number 将一个非数字的值转化为数字时，表达式返回 NaN ,但是对于 数字+字符的值，其转化结果会有所不同，Number 转换的是整个值，而不是部分值；parseInt 和 parseFloat 只转化第一个无效字符之前的字符串。 另外，一元加操作符也可以实现与 Number 相同的作用。 ： 123456789101112'abc' - 3 // NaNparseInt('abc') // NaNparseFloat('abc') // NaNNumber('abc') // NaNNumber('123abc'); // NaNparseInt('123abc'); // 123parseInt('123abc45'); // 123parseFloat('123.45abc');// 123.45+ '12abc'; // NaN+ '123'; // 123+ '123.78'; // 123.78+ 'abc'; // NaN 三个标准对象DateDate对象用来表示日期和时间。Date常用的一些函数： 123456789101112131415var now = new Date();//获取系统当前时间now; now.getFullYear(); // 2019, 获得now这个Date的年份now.getMonth(); // 4, 获得now这个Date的月份，注意月份范围是0~11，4表示五月now.getDate(); // 22, 获得now这个Date的日期，表示24号now.getDay(); // 3, 获得now这个Date的星期几，表示星期三now.getHours(); // 18, 获得now这个Date的小时，24小时制now.getMinutes(); // 30, 获得now这个Date的分钟now.getSeconds(); // 22, 获得now这个Date的秒数now.getMilliseconds(); // 426, 获得now这个Date的毫秒数now.getTime(); // 1558521017632, 以number形式表示的时间戳，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数，时间戳可以精确地表示一个时刻，并且与时区无关var d = new Date(2015, 5, 19, 20, 15, 30, 123);//创建一个自己要求的Dated; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)var d = Date.parse('2015-06-24T19:49:22.875+08:00');//创建一个自己要求的Date的第二种方法d; // 1435146562875 注意 JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 Json首先Json是一种数据传输的格式。 其次把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串。对应的如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。 序列化是通过JSON.stringify(JavaScirpt的对象)来实现的。这个函数有三个参数，第一个就是我们要序列化的JavaScript的对象，第二个参数是用来控制如何筛选对象的键值，比方可以传函数，传要取出来的属性，第三个是控制的转换后的格式。如果我们还想要精确控制如何序列化一个对象的话如xiaoming，可以给xiaoming定义一个toJSON()的方法，直接返回JSON应该序列化的数据： 12345678910111213141516var xiaoming = &#123; name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\"W3C\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'], toJSON: function () &#123; return &#123; // 只输出name和age，并且改变了key： 'Name': this.name, 'Age': this.age &#125;; &#125;&#125;;JSON.stringify(xiaoming); // '&#123;"Name":"小明","Age":14&#125;' 反序列化是通过用JSON.parse()把它变成一个JavaScript对象，同时这个函数还可以接收一个函数作为参数，用来转换解析出的属性： 1234567var obj = JSON.parse('&#123;"name":"小明","age":14&#125;', function (key, value) &#123; if (key === 'name') &#123; return value + '同学'; &#125; return value;&#125;);console.log(JSON.stringify(obj)); // &#123;name: '小明同学', age: 14&#125; RegExp(待补)面向对象创建对象JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。形成一个原型链，当我们要访问一个对象的一个属性的时候，就会通过这个原型链查找，如果一直找到Object.prototype对象，都还没有找到，就只能返回undefined。 比方说我们创建了一个Array对象，我们可以得到其对应的原型链如下： 12var arr = [1, 2, 3];arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null 我们这个arr对象，能调用arr，Array.prototype，Object.prototype上定义的所有的方法。 构造函数，除了直接用{...}创建一个函数之外，还可以通过构造函数创建对象 123456789function Student(name) &#123; this.name = name; this.hello = function () &#123; alert('Hello, ' + this.name + '!'); &#125;&#125;var xiaoming = new Student('小明');xiaoming.name; // '小明'xiaoming.hello(); // Hello, 小明! 这是一个普通函数，但是在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象,注意，如果不写new，这就是一个普通函数，它返回undefined。 class继承在ES6开始引入了class这个概念，就很类似Java的class对象了，例如： 12345678class Student &#123; constructor(name) &#123;//构造函数 this.name = name; &#125; hello() &#123;//普通函数 alert('Hello, ' + this.name + '!'); &#125;&#125; 继承的话和Java也很像，利用extends关键字 123456789class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 错误处理错误捕获这个和Java也很像，利用try ... catch捕获。 如果代码发生了错误，又没有被try ... catch捕获，那么，程序执行流程会跳转到哪呢？如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。 利用try ... catch捕获错误1234567891011121314151617181920function main(s) &#123; console.log('BEGIN main()'); try &#123; foo(s); &#125; catch (e) &#123; console.log('出错了：' + e); &#125; console.log('END main()');&#125;function foo(s) &#123; console.log('BEGIN foo()'); bar(s); console.log('END foo()');&#125;function bar(s) &#123; console.log('BEGIN bar()'); console.log('length = ' + s.length); console.log('END bar()');&#125;main(null);]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative（一）]]></title>
    <url>%2F2019%2F05%2F22%2FReactNative%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[搭建第一个ReactNative项目环境要求需要Node，Python2，Jdk，Android Studio，Android SDK。 注：学会通过Chocolatey（一种流行的Windows程序包管理器）安装Node和Python2以及Jdk。 配置环境变量添加ANDROID_HOME 在Windows控制面板中的“ 系统和安全”下打开“系统”窗格，然后单击“ 更改设置…”。打开“ 高级”选项卡，然后单击“ 环境变量…”。单击New …以创建ANDROID_HOME指向Android SDK路径的新用户变量 将平台工具添加到Path 在Windows控制面板中的“ 系统和安全”下打开“系统”窗格，然后单击“ 更改设置…”。打开“ 高级”选项卡，然后单击“ 环境变量…”。选择Path变量，然后单击“ 编辑”。单击“ 新建”，将平台工具的路径添加到列表中。 此文件夹的默认位置是： 1c:\Users\YOUR_USERNAME\AppData\Local\Android\Sdk\platform-tools 跑Demo利用cmd命令行界面生成一个名为AwesomeProject的新React Native项目 1react-native init AwesomeProject 利用Android Studio打开这个项目，并跑好虚拟机。 然后在命令行运行 12cd AwesomeProjectreact-native run-android 如果设置都是正确的话，你就能得到以下界面：（这样的话第一个demo就跑通了，要修改的话就在App.js文件修改即可，刷新的话使用ctrl+m或者双击RR 基础知识简单的组件介绍学习过Html的话会熟悉很多，ReactNative提供很多的内置组件像&lt;Text&gt;，&lt;View&gt;，&lt;Button&gt;这些，当然你也可以自己定义自己的组件，如下，这样的话我们就定义好了自己的组件Greeting。 123456789class Greeting extends Component&#123; render()&#123; return ( &lt;View style=&#123;styles.instructions&#125;&gt; &lt;Text&gt; Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 大多数组件在创建时可以使用不同的参数进行自定义。调用这些创建参数props。 比方说利用组件Image创建图像，可以使用命名的道具source来控制它显示的图像。 12345678910111213141516import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render() &#123; let pic=&#123; uri : 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg' &#125;; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt;Hello World!&lt;/Text&gt; &lt;Image source=&#123;pic&#125; style=&#123;styles.iamge1&#125;/&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 这个是内置组件自带的道具，那么要是我们自己定义的组件的话想用props也是可以的。如下 自己定义的组件，通过在下面组件的调用的时候传入参数，利用this.props来调用显示。道具的概念就是对于组件使用不同的参数进行自定义的操作。像正常组件Text调用的style，Image调用source的这些都是道具也就是props。（个人感觉把道具和props连在一起理解会好一些） 1234567891011121314151617181920212223import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';class Greeting extends Component&#123; render()&#123; return ( &lt;View style=&#123;styles.instructions&#125;&gt; &lt;Text&gt; Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default class App extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center', top: 50&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 对于每个组件的话是有两个控制组件的参数：props和state。props由父项设置，它们在组件的整个生命周期内都是固定的。对于即将发生变化的数据，我们必须使用state，利用setstate来重新渲染。假设我们想要制作一直闪烁的文本的话代码如下： 123456789101112131415161718192021222324252627282930313233import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';class Greeting extends Component&#123; constructor(props)&#123; super(props); this.state= &#123;isShowingText :true&#125;; setInterval(() =&gt; ( this.setState(previousState =&gt; ( &#123;isShowingText: !previousState.isShowingText&#125; )) ),1000); &#125; render()&#123; if(!this.state.isShowingText)&#123; return null; &#125; return( &lt;Text&gt;&#123;this.props.name&#125;&lt;/Text&gt; ); &#125;&#125;export default class App extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center', top: 50&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 但是在实际应用中，会调用Redux或者Mobx等状态容器来控制数据流。（还没用过，口嗨一下） 样式和组件大小所有核心组件都接受名为的道具style，就是当一个组件需要写的道具过多的时候，就用样式来代替它。如下：（复制下教程的代码，自己写的因为堆积内容过多） 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View &#125; from 'react-native';const styles = StyleSheet.create(&#123; bigBlue: &#123; color: 'blue', fontWeight: 'bold', fontSize: 30, &#125;, red: &#123; color: 'red', &#125;,&#125;);export default class LotsOfStyles extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt; &lt;Text style=&#123;styles.bigBlue&#125;&gt;just bigBlue&lt;/Text&gt; &lt;Text style=&#123;[styles.bigBlue, styles.red]&#125;&gt;bigBlue, then red&lt;/Text&gt; &lt;Text style=&#123;[styles.red, styles.bigBlue]&#125;&gt;red, then bigBlue&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; LotsOfStyles); 组件大小的话是用width和height样式来控制的 1234567891011121314import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, View &#125; from 'react-native';export default class FixedDimensionsBasics extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 100, height: 100, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 150, height: 150, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; FixedDimensionsBasics); 利用Flexbox进行布局和Flex尺寸组件可以使用Flexbox算法指定其子项的布局，常用flexDirection，alignItems以及justifyContent。不同的又有一些对应的参数值 1234567891011121314import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render()&#123; return( &lt;View style=&#123;&#123;flex: 1,flexDirection: 'column',justifyContent: 'flex-end'&#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;flex: 2, height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;flex: 3, height: 50, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 我们看到第一个View有个flex的参数设置为1，它告诉组件填充所有可用空间，在具有相同父级的其他组件之间平均共享。孩子所占用的分量根据孩子的flex值进行相比分配，但是注意如果组件的父级具有大于0的维度，则组件只能展开以填充可用空间。如果父组件没有固定的width和height或flex，则父组件的维度为0，flex子组件将不可见。也就是如果父组件的flex为0了，或者只给了width或者heigth它的子组件是没办法显示的。 处理文本输入和处理接触文本输入利用TextInput组件，它是一个允许用户输入文本的基本组件，它有onChangeText和onSubmitEditing这两个props。假设用户键入时，您将其单词翻译成其他语言。在这种新语言中，每个单词用$$$代替。（还不是很理解和这个函数的写法，后续学习补一下） 1234567891011121314151617181920212223import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; constructor(props)&#123; super(props); this.state= &#123;text: ''&#125;; &#125; render()&#123; return( &lt;View style=&#123;&#123;padding:10&#125;&#125;&gt; &lt;TextInput style=&#123;&#123;height: 40&#125;&#125; placeholder="Type here to translate!" onChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125; /&gt; &lt;Text style=&#123;&#123;padding: 10,fontSize: 42&#125;&#125;&gt; &#123;this.state.text.split(' ').map((word) =&gt; word &amp;&amp; '$$$').join(' ')&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 处理接触的话是利用Button这个组件还有一些处理常见的手势组件（没看），简单看一下接触的处理。可触摸的组件有多种返回类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; onPressButton()&#123; Alert.alert('you tapped the button'); &#125; onLongPresssButton()&#123; Alert.alert('you press the button longer'); &#125; render()&#123; return( &lt;View style=&#123;styles.container&#125;&gt; //当用户按下按钮时，视图的背景将变暗。 &lt;TouchableHighlight onPress=&#123;this.onPressButton&#125; underlayColor='white'&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableHighlight&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; //通过降低按钮的不透明度来提供反馈，从而允许在用户按下时看到背景 &lt;TouchableOpacity onPress=&#123;this.onPressButton&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableOpacity&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; //显示响应用户触摸的墨水表面反应涟漪 &lt;TouchableNativeFeedback onPress=&#123;this.onPressButton&#125; background=&#123;Platform.OS === 'android' ? TouchableNativeFeedback.SelectableBackground() : ''&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableNativeFeedback&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableNativeFeedback&gt; //处理点击手势但不希望显示任何反馈 &lt;TouchableWithoutFeedback onPress=&#123;this.onPressButton&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableWithoutFeedback&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableWithoutFeedback&gt; //在之前的视图变暗的基础上加上了一个长按的操作 &lt;TouchableHighlight onPress=&#123;this.onPressButton&#125; onLongPress=&#123;this.onLongPresssButton&#125; underlayColor="white"&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Touchable with Long Press&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 滚动条和列表视图ScrollView一个通用的滚动容器，可以放置多个component或者 views，通过参数控制是横着还是竖着。 123456789101112131415161718192021222324import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; //实现一个界面放两个滚动条 render() &#123; render() &#123; return ( &lt;View&gt; &lt;ScrollView horizontal&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Scroll me plz&lt;/Text&gt; &lt;/ScrollView&gt; &lt;ScrollView&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;If you like&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Scrolling down&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;What's the best&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Framework around?&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:80&#125;&#125;&gt;React Native&lt;/Text&gt; &lt;/ScrollView&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); React Native提供了一套用于显示数据列表的组件：FlatList和SectionList。列表视图最常见的用途之一是显示从服务器获取的数据。 FlatList组件显示一个滚动列表，它唯一呈现当前在屏幕上显示的元素，而不是一次显示所有元素。它有两个道具：data和renderItem。data是列表的信息来源。renderItem从源中获取一个项目并返回要呈现的格式化组件。 12345678910111213141516171819202122232425import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render()&#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123;[ &#123;key: 'Devin'&#125;, &#123;key: 'Jackson'&#125;, &#123;key: 'James'&#125;, &#123;key: 'Joel'&#125;, &#123;key: 'John'&#125;, &#123;key: 'Jillian'&#125;, &#123;key: 'Jimmy'&#125;, &#123;key: 'Julie'&#125;, ]&#125; //renderItem这个不是很懂，看懂了再解释 renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item.key&#125;&lt;/Text&gt;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 如果将一组数据分解为逻辑部分，可能使用部分标题，那么就使用SectionList 1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, SectionList, StyleSheet, Text, View &#125; from 'react-native';export default class SectionListBasics extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;SectionList sections=&#123;[ &#123;title: 'D', data: ['Devin']&#125;, &#123;title: 'J', data: ['Jackson', 'James', 'Jillian', 'Jimmy', 'Joel', 'John', 'Julie']&#125;, ]&#125; renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item&#125;&lt;/Text&gt;&#125; renderSectionHeader=&#123;(&#123;section&#125;) =&gt; &lt;Text style=&#123;styles.sectionHeader&#125;&gt;&#123;section.title&#125;&lt;/Text&gt;&#125; keyExtractor=&#123;(item, index) =&gt; index&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, paddingTop: 22 &#125;, sectionHeader: &#123; paddingTop: 2, paddingLeft: 10, paddingRight: 10, paddingBottom: 2, fontSize: 14, fontWeight: 'bold', backgroundColor: 'rgba(247,247,247,1.0)', &#125;, item: &#123; padding: 10, fontSize: 18, height: 44, &#125;,&#125;)AppRegistry.registerComponent('AwesomeProject', () =&gt; SectionListBasics);]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语法熟悉一]]></title>
    <url>%2F2019%2F05%2F21%2FJs%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Js基本语法在哪里引入Js代码？1）首先JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到&lt;head&gt;中，我们看到网页的源码的时候被&lt;script&gt;...&lt;/script&gt;包含的代码就是JavaScript代码，它会直接被浏览器执行。 2）单独的写一个 .js文件，然后在HTML中通过&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;引入这个文件。这样的话是方便多个网页应用到了同一份Js文件。 数据类型，运算符以及变量的申明1）Js的数据类型主要有Number，布尔值，字符串。JavaScript不区分整数和浮点数，统一用Number表示。 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity Number可以直接做四则运算，规则和数学一致。 注意一个点：字符串也可以使用加号，但是字符串将被级联但是注意字符串和数字相加会返回一个字符串，例如： 1234var x = "8" + 3 + 5;//输出结果：835var x = 3 + 5 + "8";//输出结果88 布尔值的话只能有false，true两种。 字符串的话就跟Java，c++的都差不多，不过JavaScript中以单引号’或双引号”括起来的任意文本都是字符串。 2）运算符：&amp;&amp;运算，||运算，!运算，比较运算符。基本上都差不多，但是要注意的是相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 通常的话我们是坚持使用===。 另外是NaN这个特殊的Number，它和其他所有的值都不相等，包括本身。唯一能判断NaN的方法是通过isNaN()函数。 3）变量的申明方式 变量名的要求：变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。 12345678910var age = 15;var arr = [1, 2, 3.14, 'Hello', null, true];//JavaScript的数组可以包括任意数据类型var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;;//申明JavaScript的对象，它是由键-值组成的无序集合，引用的话和Java差不多，用对象变量.属性名的方式 同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，注意在JavaScript中通过赋值可以修改变量的数据类型，JavaScript是一个动态的语言。像Java这种静态的语言就不能这样的进行赋值。 注意：不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。 字符串在前面我们看到字符串就是用&#39;&#39;或&quot;&quot;括起来的字符。跟c++一样有转义字符，具体的熟悉一下就行。 通过+来连接字符串。 通过s.length来获取字符的长度 通过下标索引获取字符串某个指定位置的字符，索引号从0开始，需要注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果，如下： 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写： indexOf()会搜索指定字符串出现的位置（字符串第一个出现该字符的位置） substring()返回指定索引区间的子串 split()把字符串转换为数组 1234var txt = "a,b,c,d,e"; // 字符串txt.split(","); // 用逗号分隔txt.split(" "); // 用空格分隔txt.split("|"); // 用竖线分隔 数组和对象通过arr.length获取数组长度，直接给Array的length赋一个新的值会导致Array大小的变化如： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] 和字符串不同，数组可以通过下表索引修改对应的元素值。但是要是索引超过范围的话同样会导致数组大小的变化。 通过indexOf()来搜索一个指定的元素的位置（同字符串第一个出现该字符的位置） slice()截取Array的部分元素，然后返回一个新的Array push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉 往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉 sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置 reverse()把整个Array反转 splice()方法可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素 concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array，并不是修改当前的数组。 join()方法能把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。 练习：在新生欢迎会上，你已经拿到了新同学的名单，请排序后显示：欢迎XXX，XXX，XXX和XXX同学！： 1234'use strict';var arr = ['小明', '小红', '大军', '阿黄'];arr.sort();console.log(`欢迎$&#123;arr[0]&#125;,$&#123;arr[1]&#125;,$&#123;arr[2]&#125;和$&#123;arr[3]&#125;同学!`); JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,可以通过delete删除属性，赋值增加属性如： 1234567891011var xiaoming = &#123; name: '小明', score: null&#125;;xiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 利用in操作符检测是否拥有一个属性，但是注意所有对象最终都会在原型链上指向object，所以我们定义的对象都有object对象的属性，所以要判断一个属性是否是我们定义的对象拥有的，而不是继承得到的，可以用hasOwnProperty()方法 容器和一些控制语句条件判断if...else，这些都差不多，就是逻辑的判断。 练习：小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖 用if...else...判断并显示结果： 12345678910111213141516'use strict';var height = parseFloat(prompt('请输入身高(m):'));var weight = parseFloat(prompt('请输入体重(kg):'));var bmi=weight/height/height;if (bmi &lt; 18.5) &#123; console.log('过轻');&#125; else if (bmi &lt;= 25) &#123; console.log('正常');&#125; else if (bmi &lt; 28) &#123; console.log('过重');&#125; else if (bmi &lt; 32) &#123; console.log('肥胖');&#125; else &#123; console.log('严重肥胖');&#125; 循环也是一样利用for或者while或者do...while 练习: 利用for循环计算1 * 2 * 3 * ... * 10的结果： 123456789101112'use strict';var x = 1;var i;for (i=1;i&lt;=10;i++)&#123; x*=i;&#125;if (x === 3628800) &#123; console.log('1 x 2 x 3 x ... x 10 = ' + x);&#125;else &#123; console.log('计算错误');&#125; 请利用循环遍历数组中的每个名字，并显示Hello, xxx!： 12345678910111213'use strict';var arr = ['Bart', 'Lisa', 'Adam'];arr.sort(); // 正序//倒序arr.reverse();for(var i=0;i&lt;arr.length;i++)&#123; console.log(`Hello,$&#123;arr[i]&#125;`);&#125;var i=0;while(i&lt;arr.length)&#123; console.log(`Hello,$&#123;arr[i]&#125;`); i++;&#125; Map和Set容器 Map是一组键值对的结构，利用key和value。常用的函数有set，delete，get。用法都差不多。 set一组key的集合且不重复，常用的函数有delete，add。 iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for ... of循环来遍历。因为遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。如： 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 或者通过forEach()方法循环，forEach()有三个参数 1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，可以忽略。 Js 函数函数函数定义如下： 123456789101112131415function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;//或者另一种var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;;//注意这比上面多一个等号 JavaScript在调用参数的时候允许任意个参数调用，不管传多还是传少都不会报错。因此JavaScript提供了一个关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array，利用它可以判断传入参数的个数。 之后JavaScript又引入了rest参数，rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。如 1234567891011121314151617function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] 练习： 请用rest参数编写一个sum()函数，接收任意个参数并返回它们的和： 1234567891011121314151617181920212223242526'use strict';function sum(...rest) &#123; var arr = []; arr = rest; //获取所有的参数，以数组显示保存在arr数组中 var result = 0; for(var i = 0; i &lt; arr.length; i++)&#123; result = result + arr[i]; &#125; return result;&#125; // 测试:var i, args = [];for (i=1; i&lt;=100; i++) &#123; args.push(i);&#125;if (sum() !== 0) &#123; console.log('测试失败: sum() = ' + sum());&#125; else if (sum(1) !== 1) &#123; console.log('测试失败: sum(1) = ' + sum(1));&#125; else if (sum(2, 3) !== 5) &#123; console.log('测试失败: sum(2, 3) = ' + sum(2, 3));&#125; else if (sum.apply(null, args) !== 5050) &#123; console.log('测试失败: sum(1, 2, 3, ..., 100) = ' + sum.apply(null, args));&#125; else &#123; console.log('测试通过!');&#125; 定义一个计算圆面积的函数area_of_circle()，它有两个参数： r: 表示圆的半径； pi: 表示π的值，如果不传，则默认3.14 12345678910111213141516171819202122'use strict';function area_of_circle(r, pi) &#123; var area; if (arguments.length == 2) &#123; area = pi * r * r; &#125; else if (arguments.length &lt; 2)&#123; pi = 3.14; area = pi * r * r; &#125; else&#123; console.log("arguments number must be 1 or 2."); return ; &#125; return r * r * (pi || 3.14);&#125;// 测试:if (area_of_circle(2) === 12.56 &amp;&amp; area_of_circle(2, 3.1416) === 12.5664) &#123; console.log('测试通过');&#125; else &#123; console.log('测试失败');&#125; 函数变量作用域以及解析赋值在JavaScript中，用var申明的变量实际上是有作用域的。一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量，但是由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量。但是如果内部函数和外部函数的变量名重名的情况下在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。看样例： 1234567891011121314function foo() &#123; var x = 1; function bar() &#123; var x = 'A'; console.log('x in bar() = ' + x); // 'A' &#125; console.log('x in foo() = ' + x); // 1 bar();&#125;foo();/*结果为x in foo() = 1x in bar() = A*/ 而且JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部，也就是所有的变量都会在函数初步就定义了。 同时JavaScript默认有一个全局对象window，不在任何函数内定义的变量就具有全局作用域，全局作用域的变量实际上被绑定到window的一个属性。我们在之前说过函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象，其实我们每次直接调用的alert()函数其实也是window的一个变量。 所以JavaScript中任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。 因此在这个基础上，个人感觉引用了c++的using namespace std命名空间的概念，在JavaScript中有一个名字空间，因为全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，就会造成命名冲突，解决的方式就是把自己的所有变量和函数绑定到一个全局变量里面会减少全局变量冲突的几率。 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 解构赋值：在ES6后引入了这个解构赋值，直接对于多个变量同时赋值如： 1234567var [x, y, z] = ['hello', 'JavaScript', 'ES6'];// x, y, z分别被赋值为数组对应元素:console.log('x = ' + x + ', y = ' + y + ', z = ' + z);/*结果为x = hello, y = JavaScript, z = ES6*/根据数组的格式进行嵌套赋值，但是要注意嵌套层次和位置要保持一致 同理解构赋值也能对对象进行同样的操作如： 12345678910111213141516171819var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: &#123; city: 'Beijing', street: 'No.1 Road', zipcode: '100001' &#125;&#125;;var &#123;name, address: &#123;city, zip&#125;&#125; = person;name; // '小明'city; // 'Beijing'zip; // undefined, 因为属性名是zipcode而不是zip// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:address; // Uncaught ReferenceError: address is not defined//当然可以赋默认值避免了不存在的属性返回undefined的问题 方法和高阶函数在一个对象中绑定函数，那么就成为这个对象的方法，如 1234567891011var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 在函数内部this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性，但是我们要注意this这个指向，最好是在引用函数之前就把这个this给记录下来如that，然后在方法内定义其他的函数，用that去代替this；或者呢用aplpy函数去修复，apply它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。同样有个call函数。 一个很重要的点高阶函数： 什么叫高阶函数？高阶函数指最少满足下列条件之一的函数：函数可以作为参数传递，函数可以作为返回值输出。（理解的不够，再细致的理解再补） map/reduce函数：它们都是Array中定义的，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果，比方说我要得到一个数组中每个数的平方： 12345678'use strict';function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); //map()传入的参数是pow(),是函数本身console.log(results);// [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce函数的话是把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，实际能做的事情是对一个数组进行重复的处理，比方说求和，求积，如： 1234567891011121314’use strict';function product(arr) &#123; var ans=arr.reduce(function(x,y)&#123; return x*y; &#125;); return ans;&#125;// 测试:if (product([1, 2, 3, 4]) === 24 &amp;&amp; product([0, 1, 2]) === 0 &amp;&amp; product([99, 88, 77, 66]) === 44274384) &#123; console.log('测试通过!');&#125;else &#123; console.log('测试失败!');&#125; 把[1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场： 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x * 10 + y;&#125;); // 13579 练习： 不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数： 1234567891011121314151617181920212223'use strict';function string2int(s) &#123; var arr= []; for(let i=0;i&lt;s.length;i++) arr[i]=s[i]-'0'; var ans=arr.reduce(function (x, y) &#123; return x * 10 + y; &#125;); return ans;&#125;// 测试:if (string2int('0') === 0 &amp;&amp; string2int('12345') === 12345 &amp;&amp; string2int('12300') === 12300) &#123; if (string2int.toString().indexOf('parseInt') !== -1) &#123; console.log('请勿使用parseInt()!'); &#125; else if (string2int.toString().indexOf('Number') !== -1) &#123; console.log('请勿使用Number()!'); &#125; else &#123; console.log('测试通过!'); &#125;&#125;else &#123; console.log('测试失败!');&#125; 请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]，输出：[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]。 1234567891011121314'use strict';function normalize(arr) &#123; return arr.map(function(x) &#123; return x[0].toUpperCase() + x.substring(1).toLowerCase() &#125;);&#125;// 测试:if (normalize(['adam', 'LISA', 'barT']).toString() === ['Adam', 'Lisa', 'Bart'].toString()) &#123; console.log('测试通过!');&#125;else &#123; console.log('测试失败!');&#125; 小明希望利用map()把字符串变成整数，他写的代码很简洁： 123456'use strict';var arr = ['1', '2', '3'];var r;r = arr.map(parseInt);console.log(r);结果竟然是1, NaN, NaN，小明百思不得其解，请帮他找到原因并修正代码。 这个主要是parseInt的一些误区，后序会写篇来介绍这个，先暂时性看这个理解一下https://blog.csdn.net/wjl84945979/article/details/56478927 filter函数filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。类似一个筛选的功能，例如：在一个Array中，删掉偶数，只保留奇数 12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (element, index, self) &#123; return element% 2 !== 0;&#125;);r; // [1, 5, 9, 15] 看上面的调用filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身。 练习： 请尝试用filter()筛选出素数： 1234567891011121314151617181920212223242526272829303132333435'use strict';function get_primes(arr) &#123; var ans=arr.filter(function (element,index,self) &#123; if(element&lt;2 ) return false; else&#123; var flag=false; for(let i=2;i&lt;element;i++)&#123; if(element%i===0)&#123; flag=true; break; &#125; &#125; if(flag) return false; else return true; &#125; &#125;); return ans;&#125;// 测试:var x, r, arr = [];for (x = 1; x &lt; 100; x++) &#123; arr.push(x);&#125;r = get_primes(arr);if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) &#123; console.log('测试通过!');&#125; else &#123; console.log('测试失败: ' + r.toString());&#125;]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
</search>
