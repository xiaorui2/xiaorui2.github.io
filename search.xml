<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReactNative（一）]]></title>
    <url>%2F2019%2F05%2F22%2FReactNative%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[搭建第一个ReactNative项目环境要求需要Node，Python2，Jdk，Android Studio，Android SDK。 注：学会通过Chocolatey（一种流行的Windows程序包管理器）安装Node和Python2以及Jdk。 配置环境变量添加ANDROID_HOME 在Windows控制面板中的“ 系统和安全”下打开“系统”窗格，然后单击“ 更改设置…”。打开“ 高级”选项卡，然后单击“ 环境变量…”。单击New …以创建ANDROID_HOME指向Android SDK路径的新用户变量 将平台工具添加到Path 在Windows控制面板中的“ 系统和安全”下打开“系统”窗格，然后单击“ 更改设置…”。打开“ 高级”选项卡，然后单击“ 环境变量…”。选择Path变量，然后单击“ 编辑”。单击“ 新建”，将平台工具的路径添加到列表中。 此文件夹的默认位置是： 1c:\Users\YOUR_USERNAME\AppData\Local\Android\Sdk\platform-tools 跑Demo利用cmd命令行界面生成一个名为AwesomeProject的新React Native项目 1react-native init AwesomeProject 利用Android Studio打开这个项目，并跑好虚拟机。 然后在命令行运行 12cd AwesomeProjectreact-native run-android 如果设置都是正确的话，你就能得到以下界面：（这样的话第一个demo就跑通了，要修改的话就在App.js文件修改即可，刷新的话使用ctrl+m或者双击RR 基础知识简单的组件介绍学习过Html的话会熟悉很多，ReactNative提供很多的内置组件像&lt;Text&gt;，&lt;View&gt;，&lt;Button&gt;这些，当然你也可以自己定义自己的组件，如下，这样的话我们就定义好了自己的组件Greeting。 123456789class Greeting extends Component&#123; render()&#123; return ( &lt;View style=&#123;styles.instructions&#125;&gt; &lt;Text&gt; Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 大多数组件在创建时可以使用不同的参数进行自定义。调用这些创建参数props。 比方说利用组件Image创建图像，可以使用命名的道具source来控制它显示的图像。 12345678910111213141516import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render() &#123; let pic=&#123; uri : 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg' &#125;; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt;Hello World!&lt;/Text&gt; &lt;Image source=&#123;pic&#125; style=&#123;styles.iamge1&#125;/&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 这个是内置组件自带的道具，那么要是我们自己定义的组件的话想用props也是可以的。如下 自己定义的组件，通过在下面组件的调用的时候传入参数，利用this.props来调用显示。道具的概念就是对于组件使用不同的参数进行自定义的操作。像正常组件Text调用的style，Image调用source的这些都是道具也就是props。（个人感觉把道具和props连在一起理解会好一些） 1234567891011121314151617181920212223import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';class Greeting extends Component&#123; render()&#123; return ( &lt;View style=&#123;styles.instructions&#125;&gt; &lt;Text&gt; Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default class App extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center', top: 50&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 对于每个组件的话是有两个控制组件的参数：props和state。props由父项设置，它们在组件的整个生命周期内都是固定的。对于即将发生变化的数据，我们必须使用state，利用setstate来重新渲染。假设我们想要制作一直闪烁的文本的话代码如下： 123456789101112131415161718192021222324252627282930313233import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';class Greeting extends Component&#123; constructor(props)&#123; super(props); this.state= &#123;isShowingText :true&#125;; setInterval(() =&gt; ( this.setState(previousState =&gt; ( &#123;isShowingText: !previousState.isShowingText&#125; )) ),1000); &#125; render()&#123; if(!this.state.isShowingText)&#123; return null; &#125; return( &lt;Text&gt;&#123;this.props.name&#125;&lt;/Text&gt; ); &#125;&#125;export default class App extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center', top: 50&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 但是在实际应用中，会调用Redux或者Mobx等状态容器来控制数据流。（还没用过，口嗨一下） 样式和组件大小所有核心组件都接受名为的道具style，就是当一个组件需要写的道具过多的时候，就用样式来代替它。如下：（复制下教程的代码，自己写的因为堆积内容过多） 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View &#125; from 'react-native';const styles = StyleSheet.create(&#123; bigBlue: &#123; color: 'blue', fontWeight: 'bold', fontSize: 30, &#125;, red: &#123; color: 'red', &#125;,&#125;);export default class LotsOfStyles extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt; &lt;Text style=&#123;styles.bigBlue&#125;&gt;just bigBlue&lt;/Text&gt; &lt;Text style=&#123;[styles.bigBlue, styles.red]&#125;&gt;bigBlue, then red&lt;/Text&gt; &lt;Text style=&#123;[styles.red, styles.bigBlue]&#125;&gt;red, then bigBlue&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; LotsOfStyles); 组件大小的话是用width和height样式来控制的 1234567891011121314import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, View &#125; from 'react-native';export default class FixedDimensionsBasics extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 100, height: 100, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 150, height: 150, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; FixedDimensionsBasics); 利用Flexbox进行布局和Flex尺寸组件可以使用Flexbox算法指定其子项的布局，常用flexDirection，alignItems以及justifyContent。不同的又有一些对应的参数值 1234567891011121314import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render()&#123; return( &lt;View style=&#123;&#123;flex: 1,flexDirection: 'column',justifyContent: 'flex-end'&#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;flex: 2, height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;flex: 3, height: 50, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 我们看到第一个View有个flex的参数设置为1，它告诉组件填充所有可用空间，在具有相同父级的其他组件之间平均共享。孩子所占用的分量根据孩子的flex值进行相比分配，但是注意如果组件的父级具有大于0的维度，则组件只能展开以填充可用空间。如果父组件没有固定的width和height或flex，则父组件的维度为0，flex子组件将不可见。也就是如果父组件的flex为0了，或者只给了width或者heigth它的子组件是没办法显示的。 处理文本输入和处理接触文本输入利用TextInput组件，它是一个允许用户输入文本的基本组件，它有onChangeText和onSubmitEditing这两个props。假设用户键入时，您将其单词翻译成其他语言。在这种新语言中，每个单词用$$$代替。（还不是很理解和这个函数的写法，后续学习补一下） 1234567891011121314151617181920212223import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; constructor(props)&#123; super(props); this.state= &#123;text: ''&#125;; &#125; render()&#123; return( &lt;View style=&#123;&#123;padding:10&#125;&#125;&gt; &lt;TextInput style=&#123;&#123;height: 40&#125;&#125; placeholder="Type here to translate!" onChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125; /&gt; &lt;Text style=&#123;&#123;padding: 10,fontSize: 42&#125;&#125;&gt; &#123;this.state.text.split(' ').map((word) =&gt; word &amp;&amp; '$$$').join(' ')&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 处理接触的话是利用Button这个组件还有一些处理常见的手势组件（没看），简单看一下接触的处理。可触摸的组件有多种返回类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; onPressButton()&#123; Alert.alert('you tapped the button'); &#125; onLongPresssButton()&#123; Alert.alert('you press the button longer'); &#125; render()&#123; return( &lt;View style=&#123;styles.container&#125;&gt; //当用户按下按钮时，视图的背景将变暗。 &lt;TouchableHighlight onPress=&#123;this.onPressButton&#125; underlayColor='white'&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableHighlight&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; //通过降低按钮的不透明度来提供反馈，从而允许在用户按下时看到背景 &lt;TouchableOpacity onPress=&#123;this.onPressButton&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableOpacity&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; //显示响应用户触摸的墨水表面反应涟漪 &lt;TouchableNativeFeedback onPress=&#123;this.onPressButton&#125; background=&#123;Platform.OS === 'android' ? TouchableNativeFeedback.SelectableBackground() : ''&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableNativeFeedback&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableNativeFeedback&gt; //处理点击手势但不希望显示任何反馈 &lt;TouchableWithoutFeedback onPress=&#123;this.onPressButton&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableWithoutFeedback&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableWithoutFeedback&gt; //在之前的视图变暗的基础上加上了一个长按的操作 &lt;TouchableHighlight onPress=&#123;this.onPressButton&#125; onLongPress=&#123;this.onLongPresssButton&#125; underlayColor="white"&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Touchable with Long Press&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 滚动条和列表视图ScrollView一个通用的滚动容器，可以放置多个component或者 views，通过参数控制是横着还是竖着。 123456789101112131415161718192021222324import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; //实现一个界面放两个滚动条 render() &#123; render() &#123; return ( &lt;View&gt; &lt;ScrollView horizontal&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Scroll me plz&lt;/Text&gt; &lt;/ScrollView&gt; &lt;ScrollView&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;If you like&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Scrolling down&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;What's the best&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Framework around?&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:80&#125;&#125;&gt;React Native&lt;/Text&gt; &lt;/ScrollView&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); React Native提供了一套用于显示数据列表的组件：FlatList和SectionList。列表视图最常见的用途之一是显示从服务器获取的数据。 FlatList组件显示一个滚动列表，它唯一呈现当前在屏幕上显示的元素，而不是一次显示所有元素。它有两个道具：data和renderItem。data是列表的信息来源。renderItem从源中获取一个项目并返回要呈现的格式化组件。 12345678910111213141516171819202122232425import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render()&#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123;[ &#123;key: 'Devin'&#125;, &#123;key: 'Jackson'&#125;, &#123;key: 'James'&#125;, &#123;key: 'Joel'&#125;, &#123;key: 'John'&#125;, &#123;key: 'Jillian'&#125;, &#123;key: 'Jimmy'&#125;, &#123;key: 'Julie'&#125;, ]&#125; //renderItem这个不是很懂，看懂了再解释 renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item.key&#125;&lt;/Text&gt;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 如果将一组数据分解为逻辑部分，可能使用部分标题，那么就使用SectionList 1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, SectionList, StyleSheet, Text, View &#125; from 'react-native';export default class SectionListBasics extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;SectionList sections=&#123;[ &#123;title: 'D', data: ['Devin']&#125;, &#123;title: 'J', data: ['Jackson', 'James', 'Jillian', 'Jimmy', 'Joel', 'John', 'Julie']&#125;, ]&#125; renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item&#125;&lt;/Text&gt;&#125; renderSectionHeader=&#123;(&#123;section&#125;) =&gt; &lt;Text style=&#123;styles.sectionHeader&#125;&gt;&#123;section.title&#125;&lt;/Text&gt;&#125; keyExtractor=&#123;(item, index) =&gt; index&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, paddingTop: 22 &#125;, sectionHeader: &#123; paddingTop: 2, paddingLeft: 10, paddingRight: 10, paddingBottom: 2, fontSize: 14, fontWeight: 'bold', backgroundColor: 'rgba(247,247,247,1.0)', &#125;, item: &#123; padding: 10, fontSize: 18, height: 44, &#125;,&#125;)AppRegistry.registerComponent('AwesomeProject', () =&gt; SectionListBasics);]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语法熟悉一（语法和函数）]]></title>
    <url>%2F2019%2F05%2F21%2FJs%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Js基本语法 在哪里引入Js代码？ 1）首先JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到&lt;head&gt;中，我们看到网页的源码的时候被&lt;script&gt;...&lt;/script&gt;包含的代码就是JavaScript代码，它会直接被浏览器执行。 2）单独的写一个 .js文件，然后在HTML中通过&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;引入这个文件。这样的话是方便多个网页应用到了同一份Js文件。 数据类型，运算符以及变量的申明 1）Js的数据类型主要有Number，布尔值，字符串。JavaScript不区分整数和浮点数，统一用Number表示。 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity Number可以直接做四则运算，规则和数学一致。 布尔值的话只能有false，true两种。 字符串的话就跟Java，c++的都差不多，不过JavaScript中以单引号’或双引号”括起来的任意文本都是字符串。 2）运算符：&amp;&amp;运算，||运算，!运算，比较运算符。基本上都差不多，但是要注意的是相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 通常的话我们是坚持使用===。 另外是NaN这个特殊的Number，它和其他所有的值都不相等，包括本身。唯一能判断NaN的方法是通过isNaN()函数。 3）变量的申明方式 变量名的要求：变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。 12345678910var age = 15;var arr = [1, 2, 3.14, 'Hello', null, true];//JavaScript的数组可以包括任意数据类型var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;;//申明JavaScript的对象，它是由键-值组成的无序集合，引用的话和Java差不多，用对象变量.属性名的方式 同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，注意在JavaScript中通过赋值可以修改变量的数据类型，JavaScript是一个动态的语言。像Java这种静态的语言就不能这样的进行赋值。 注意：不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。 字符串 在前面我们看到字符串就是用&#39;&#39;或&quot;&quot;括起来的字符。跟c++一样有转义字符，具体的熟悉一下就行。 通过+来连接字符串。 通过s.length来获取字符的长度 通过下标索引获取字符串某个指定位置的字符，索引号从0开始，需要注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果，如下： 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写： indexOf()会搜索指定字符串出现的位置（字符串第一个出现该字符的位置） substring()返回指定索引区间的子串 数组和对象 通过arr.length获取数组长度，直接给Array的length赋一个新的值会导致Array大小的变化如： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] 和字符串不同，数组可以通过下表索引修改对应的元素值。但是要是索引超过范围的话同样会导致数组大小的变化。 通过indexOf()来搜索一个指定的元素的位置（同字符串第一个出现该字符的位置） slice()截取Array的部分元素，然后返回一个新的Array push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉 往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉 sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置 reverse()把整个Array反转 splice()方法可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素 concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array，并不是修改当前的数组。 join()方法能把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。 练习：在新生欢迎会上，你已经拿到了新同学的名单，请排序后显示：欢迎XXX，XXX，XXX和XXX同学！： 1234'use strict';var arr = ['小明', '小红', '大军', '阿黄'];arr.sort();console.log(`欢迎$&#123;arr[0]&#125;,$&#123;arr[1]&#125;,$&#123;arr[2]&#125;和$&#123;arr[3]&#125;同学!`); JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,可以通过delete删除属性，赋值增加属性如： 1234567891011var a = &#123; name: '小明', score: null&#125;;xiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 利用in操作符检测是否拥有一个属性，但是注意所有对象最终都会在原型链上指向object，所以我们定义的对象都有object对象的属性，所以要判断一个属性是否是我们定义的对象拥有的，而不是继承得到的，可以用hasOwnProperty()方法 容器和一些控制语句 条件判断if...else，这些都差不多，就是逻辑的判断。 练习：小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖 用if...else...判断并显示结果： 12345678910111213141516'use strict';var height = parseFloat(prompt('请输入身高(m):'));var weight = parseFloat(prompt('请输入体重(kg):'));var bmi=weight/height/height;if (bmi &lt; 18.5) &#123; console.log('过轻');&#125; else if (bmi &lt;= 25) &#123; console.log('正常');&#125; else if (bmi &lt; 28) &#123; console.log('过重');&#125; else if (bmi &lt; 32) &#123; console.log('肥胖');&#125; else &#123; console.log('严重肥胖');&#125; 循环也是一样利用for或者while或者do...while 练习: 利用for循环计算1 * 2 * 3 * ... * 10的结果： 123456789101112'use strict';var x = 1;var i;for (i=1;i&lt;=10;i++)&#123; x*=i;&#125;if (x === 3628800) &#123; console.log('1 x 2 x 3 x ... x 10 = ' + x);&#125;else &#123; console.log('计算错误');&#125; 请利用循环遍历数组中的每个名字，并显示Hello, xxx!： 12345678910111213'use strict';var arr = ['Bart', 'Lisa', 'Adam'];arr.sort(); // 正序//倒序arr.reverse();for(var i=0;i&lt;arr.length;i++)&#123; console.log(`Hello,$&#123;arr[i]&#125;`);&#125;var i=0;while(i&lt;arr.length)&#123; console.log(`Hello,$&#123;arr[i]&#125;`); i++;&#125; Map和Set容器 Map是一组键值对的结构，利用key和value。常用的函数有set，delete，get。用法都差不多。 set一组key的集合且不重复，常用的函数有delete，add。 iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for ... of循环来遍历。因为遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。如： 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 或者通过forEach()方法循环，forEach()有三个参数 1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，可以忽略。 Js 函数 函数 函数定义如下： 123456789101112131415function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;//或者另一种var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;;//注意这比上面多一个等号 JavaScript在调用参数的时候允许任意个参数调用，不管传多还是传少都不会报错。因此JavaScript提供了一个关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array，利用它可以判断传入参数的个数。 之后JavaScript又引入了rest参数，rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。如 1234567891011121314151617function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] 练习： 请用rest参数编写一个sum()函数，接收任意个参数并返回它们的和： 1234567891011121314151617181920212223242526'use strict';function sum(...rest) &#123; var arr = []; arr = rest; //获取所有的参数，以数组显示保存在arr数组中 var result = 0; for(var i = 0; i &lt; arr.length; i++)&#123; result = result + arr[i]; &#125; return result;&#125; // 测试:var i, args = [];for (i=1; i&lt;=100; i++) &#123; args.push(i);&#125;if (sum() !== 0) &#123; console.log('测试失败: sum() = ' + sum());&#125; else if (sum(1) !== 1) &#123; console.log('测试失败: sum(1) = ' + sum(1));&#125; else if (sum(2, 3) !== 5) &#123; console.log('测试失败: sum(2, 3) = ' + sum(2, 3));&#125; else if (sum.apply(null, args) !== 5050) &#123; console.log('测试失败: sum(1, 2, 3, ..., 100) = ' + sum.apply(null, args));&#125; else &#123; console.log('测试通过!');&#125; 定义一个计算圆面积的函数area_of_circle()，它有两个参数： r: 表示圆的半径； pi: 表示π的值，如果不传，则默认3.14 12345678910111213141516171819202122'use strict';function area_of_circle(r, pi) &#123; var area; if (arguments.length == 2) &#123; area = pi * r * r; &#125; else if (arguments.length &lt; 2)&#123; pi = 3.14; area = pi * r * r; &#125; else&#123; console.log("arguments number must be 1 or 2."); return ; &#125; return r * r * (pi || 3.14);&#125;// 测试:if (area_of_circle(2) === 12.56 &amp;&amp; area_of_circle(2, 3.1416) === 12.5664) &#123; console.log('测试通过');&#125; else &#123; console.log('测试失败');&#125; 函数变量作用域以及解析赋值 在JavaScript中，用var申明的变量实际上是有作用域的。一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量，但是由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量。但是如果内部函数和外部函数的变量名重名的情况下在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。看样例： 1234567891011121314function foo() &#123; var x = 1; function bar() &#123; var x = 'A'; console.log('x in bar() = ' + x); // 'A' &#125; console.log('x in foo() = ' + x); // 1 bar();&#125;foo();/*结果为x in foo() = 1x in bar() = A*/ 而且JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部，也就是所有的变量都会在函数初步就定义了。 同时JavaScript默认有一个全局对象window，不在任何函数内定义的变量就具有全局作用域，全局作用域的变量实际上被绑定到window的一个属性。我们在之前说过函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象，其实我们每次直接调用的alert()函数其实也是window的一个变量。 所以JavaScript中任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。 因此在这个基础上，个人感觉引用了c++的using namespace std命名空间的概念，在JavaScript中有一个名字空间，因为全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，就会造成命名冲突，解决的方式就是把自己的所有变量和函数绑定到一个全局变量里面会减少全局变量冲突的几率。 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 解构赋值：在ES6后引入了这个解构赋值，直接对于多个变量同时赋值如： 1234567var [x, y, z] = ['hello', 'JavaScript', 'ES6'];// x, y, z分别被赋值为数组对应元素:console.log('x = ' + x + ', y = ' + y + ', z = ' + z);/*结果为x = hello, y = JavaScript, z = ES6*/根据数组的格式进行嵌套赋值，但是要注意嵌套层次和位置要保持一致 同理解构赋值也能对对象进行同样的操作如： 12345678910111213141516171819var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: &#123; city: 'Beijing', street: 'No.1 Road', zipcode: '100001' &#125;&#125;;var &#123;name, address: &#123;city, zip&#125;&#125; = person;name; // '小明'city; // 'Beijing'zip; // undefined, 因为属性名是zipcode而不是zip// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:address; // Uncaught ReferenceError: address is not defined//当然可以赋默认值避免了不存在的属性返回undefined的问题 方法和高阶函数 在一个对象中绑定函数，那么就成为这个对象的方法，如 1234567891011var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 在函数内部this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性，但是我们要注意this这个指向，最好是在引用函数之前就把这个this给记录下来如that，然后在方法内定义其他的函数，用that去代替this；或者呢用aplpy函数去修复，apply它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。同样有个call函数。 一个很重要的点高阶函数： 什么叫高阶函数？高阶函数指最少满足下列条件之一的函数：函数可以作为参数传递，函数可以作为返回值输出。（理解的不够，再细致的理解再补） map/reduce函数：它们都是Array中定义的，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果，比方说我要得到一个数组中每个数的平方： 12345678'use strict';function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); //map()传入的参数是pow(),是函数本身console.log(results);// [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce函数的话是把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，实际能做的事情是对一个数组进行重复的处理，比方说求和，求积，如： 1234567891011121314’use strict';function product(arr) &#123; var ans=arr.reduce(function(x,y)&#123; return x*y; &#125;); return ans;&#125;// 测试:if (product([1, 2, 3, 4]) === 24 &amp;&amp; product([0, 1, 2]) === 0 &amp;&amp; product([99, 88, 77, 66]) === 44274384) &#123; console.log('测试通过!');&#125;else &#123; console.log('测试失败!');&#125; 把[1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场： 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x * 10 + y;&#125;); // 13579 练习： 不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数： 1234567891011121314151617181920212223'use strict';function string2int(s) &#123; var arr= []; for(let i=0;i&lt;s.length;i++) arr[i]=s[i]-'0'; var ans=arr.reduce(function (x, y) &#123; return x * 10 + y; &#125;); return ans;&#125;// 测试:if (string2int('0') === 0 &amp;&amp; string2int('12345') === 12345 &amp;&amp; string2int('12300') === 12300) &#123; if (string2int.toString().indexOf('parseInt') !== -1) &#123; console.log('请勿使用parseInt()!'); &#125; else if (string2int.toString().indexOf('Number') !== -1) &#123; console.log('请勿使用Number()!'); &#125; else &#123; console.log('测试通过!'); &#125;&#125;else &#123; console.log('测试失败!');&#125; 请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]，输出：[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]。 1234567891011121314'use strict';function normalize(arr) &#123; return arr.map(function(x) &#123; return x[0].toUpperCase() + x.substring(1).toLowerCase() &#125;);&#125;// 测试:if (normalize(['adam', 'LISA', 'barT']).toString() === ['Adam', 'Lisa', 'Bart'].toString()) &#123; console.log('测试通过!');&#125;else &#123; console.log('测试失败!');&#125; 小明希望利用map()把字符串变成整数，他写的代码很简洁： 123456'use strict';var arr = ['1', '2', '3'];var r;r = arr.map(parseInt);console.log(r);结果竟然是1, NaN, NaN，小明百思不得其解，请帮他找到原因并修正代码。 这个主要是parseInt的一些误区，后序会写篇来介绍这个，先暂时性看这个理解一下https://blog.csdn.net/wjl84945979/article/details/56478927 filter函数filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。类似一个筛选的功能，例如：在一个Array中，删掉偶数，只保留奇数 12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (element, index, self) &#123; return element% 2 !== 0;&#125;);r; // [1, 5, 9, 15] 看上面的调用filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身。 练习： 请尝试用filter()筛选出素数： 1234567891011121314151617181920212223242526272829303132333435'use strict';function get_primes(arr) &#123; var ans=arr.filter(function (element,index,self) &#123; if(element&lt;2 ) return false; else&#123; var flag=false; for(let i=2;i&lt;element;i++)&#123; if(element%i===0)&#123; flag=true; break; &#125; &#125; if(flag) return false; else return true; &#125; &#125;); return ans;&#125;// 测试:var x, r, arr = [];for (x = 1; x &lt; 100; x++) &#123; arr.push(x);&#125;r = get_primes(arr);if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) &#123; console.log('测试通过!');&#125; else &#123; console.log('测试失败: ' + r.toString());&#125;]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
</search>
