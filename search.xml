<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ada]]></title>
    <url>%2F2019%2F05%2F25%2Fada%2F</url>
    <content type="text"><![CDATA[gagag]]></content>
  </entry>
  <entry>
    <title><![CDATA[React]]></title>
    <url>%2F2019%2F05%2F25%2FReact%2F</url>
    <content type="text"><![CDATA[dfafaf]]></content>
  </entry>
  <entry>
    <title><![CDATA[Js语法熟悉三]]></title>
    <url>%2F2019%2F05%2F24%2FJs%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%E4%B8%89%2F</url>
    <content type="text"><![CDATA[JavaScript的异步处理AjaxAjax概念与工作流程AJAX 并非编程语言，它通过浏览器内建的 XMLHttpRequest 对象（从 web 服务器请求数据），然后利用JavaScript 和 HTML DOM（显示或使用数据）。它能够不刷新页面更新网页，在页面加载后从服务器请求和接收数据，在后台向服务器发送数据。 它的工作流程：网页中发生一个事件（页面加载、按钮点击） -&gt; JavaScript 创建 XMLHttpRequest 对象 -&gt; XMLHttpRequest 对象向 web 服务器发送请求 -&gt; 服务器处理该请求 -&gt; 服务器将响应发送回网页 -&gt; JavaScript读取响应并执行正确的动作（比如更新页面） 注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 Ajax实例123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt;table,th,td &#123; border : 1px solid black; border-collapse: collapse;&#125;th,td &#123; padding: 5px;&#125;&lt;/style&gt;&lt;body&gt;&lt;button type="button" onclick="loadDoc()"&gt;获取我的音乐列表&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;table id="demo"&gt;&lt;/table&gt;&lt;script&gt;function loadDoc() &#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myFunction(this); &#125; &#125;; xhttp.open("GET", "/demo/music_list.xml", true); xhttp.send();&#125;function myFunction(xml) &#123; var i; var xmlDoc = xml.responseXML; var table="&lt;tr&gt;&lt;th&gt;艺术家&lt;/th&gt;&lt;th&gt;曲目&lt;/th&gt;&lt;/tr&gt;"; var x = xmlDoc.getElementsByTagName("TRACK"); for (i = 0; i &lt;x.length; i++) &#123; table += "&lt;tr&gt;&lt;td&gt;" + x[i].getElementsByTagName("ARTIST")[0].childNodes[0].nodeValue + "&lt;/td&gt;&lt;td&gt;" + x[i].getElementsByTagName("TITLE")[0].childNodes[0].nodeValue + "&lt;/td&gt;&lt;/tr&gt;"; &#125; document.getElementById("demo").innerHTML = table;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; XMLHttpRequest对象方法和属性 方法 描述 new XMLHttpRequest() 创建新的 XMLHttpRequest 对象 getAllResponseHeaders() 返回头部信息 open(method, url, async, user, psw) 规定请求method：请求类型 GET 或 POSTurl：文件位置，使用的是相对路径async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码 send() 将请求发送到服务器，用于 GET 请求 send(string) 将请求发送到服务器，用于 POST 请求 onreadystatechange 定义当 readyState 属性发生变化时被调用的函数 readyState 保存 XMLHttpRequest 的状态。0：请求未初始化1：服务器连接已建立2：请求已收到3：正在处理请求4：请求已完成且响应已就绪 responseText/XML 以字符串/XML返回响应数据 status 返回请求的状态号：200: &quot;OK&quot;403: &quot;Forbidden&quot;404: &quot;Not Found&quot; CORS跨域在Ajax上我们知道输入URL使用的是相对路径，这是浏览器的同源策略导致的，也就是在发送AJAX请求时，URL的域名必须和当前页面完全一致，不然会报错。这也就是跨域 Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。 Promise在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现，上面的Ajax就是典型的异步操作。 Promise是另一种异步的操作 它的处理想法就是先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。 123456789101112131415161718192021222324function test(resolve, reject) &#123; var timeOut = Math.random() * 2; log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () &#123; if (timeOut &lt; 1) &#123; log('call resolve()...'); resolve('200 OK'); &#125; else &#123; log('call reject()...'); reject('timeout in ' + timeOut + ' seconds.'); &#125; &#125;, timeOut * 1000);&#125;var p1 = new Promise(test);//变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象：//如果成功，执行这个函数：var p2 = p1.then(function (result) &#123; console.log('成功：' + result);&#125;);//如果失败，执行这个函数：var p3 = p2.catch(function (reason) &#123; console.log('失败：' + reason);&#125;); 最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了 再看一个： 12345678910111213141516171819202122232425262728293031'use strict';function log(s) &#123; var p = document.createElement('p'); p.innerHTML = s; logging.appendChild(p);&#125;// 0.5秒后返回input*input的计算结果:function multiply(input) &#123; return new Promise(function (resolve, reject) &#123; log('calculating ' + input + ' x ' + input + '...'); setTimeout(resolve, 500, input * input); &#125;);&#125;// 0.5秒后返回input+input的计算结果:function add(input) &#123; return new Promise(function (resolve, reject) &#123; log('calculating ' + input + ' + ' + input + '...'); setTimeout(resolve, 500, input + input); &#125;);&#125;var p = new Promise(function (resolve, reject) &#123; log('start new Promise...'); resolve(123);&#125;);p.then(multiply) .then(add) .then(multiply) .then(add) .then(function (result) &#123; log('Got value: ' + result);&#125;); Promise还可以并行执行异步任务。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运输层]]></title>
    <url>%2F2019%2F05%2F23%2F%E4%BC%A0%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[运输层概念运输层是位于应用层和网络层之间，为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用，主要要理解的就是我们常用的UDP和TCP协议。通常我们知道的TCP它是一个可靠的传输连接，而UDP是一个不可靠的传输连接。 无连接运输：UDPUDP做的事它是基于Internet IP协议，做了（传输层都要做的功能）复用 / 分用，简单的错误检测。它是无连接的，UDP发送方和接收方之间不需要握手，每个UDP段的处理独立于其他段，并且UDP段可能丢失，非按序到达。 UDP为什么存在因为无需要建立连接（减少延迟），实现简单，无需维护连接状态，头部开销少，没有拥塞控制，应用可以更好的控制发送时间和速率。用于DNS，SNMP等。 如何在UDP上实现可靠数据传输在应用层增加可靠性机制，应用特定的错误恢复机制。（在应用层保证数据传输可靠）添加seq/ack机制，确保数据发送到对端，添加发送和接收缓冲区，主要是用户超时重传，添加超时重传机制 详细说明：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。 UDP的数据格式和校验和 可靠的数据传输原理什么叫可靠？数据不错，不丢，不乱。可靠数据传输对应用层，传输层，链路层都很重要。信道的不可靠性决定可靠数据传输协议（rdt）的复杂性。 可靠的数据传输协议基本结构是通过接口来实现的。调用一些 rdt_send()，rdt_rcv() ，deliver_data()这些函数接口。 可靠信道上的可靠数据传输和产生位错误的信道上的可靠数据传输首先底层信道完全可靠（不会发生错误，不会丢弃分组），发送放和接收方的FSM（有限状态自动机）独立。 在会产生错误的信道传输会利用校验和来检测位错误，发送ACK（接收方显示的告知发送发分组已经正确的接收）或者NAK（错误的接收）当发现错误的时候会利用重传机制重传分组。 从可靠数据传输流水线可靠数据传输Rdt2.1：如何解决重复分组问题：给每个分组增加序列号，接收方丢弃重复分组。应对ACK/NAK破坏或者被损坏的情况。 Rdt2.2：无NAK消息协议，与Rdt2.1功能相同，但是只使用ACK。如何实现？接收方通过ACK告知最后一个被正确接收的分组，在ACK消息中显示的加入被确认分组的序列号。发送发收到重复的ACK之后，采取和收到NAK的动作一样。 Rdt3.0：如果信道既可能发生错误也可能丢失分组，那么校验和+序列号+ACK+重传就不够用了（比方说ACK消息丢失了，发送方就一直在等待）解决方法也很简单：给发送方设置一个合理的时间，如果没有收到ACK就重传。但是这个合理的时间是很难确定的。那么就是需要设置定时器。Rdt3.0能够正常工作，但是性能很差。主要是由于停等协议导致的。 基于Rdt3.0，可以不使用停等协议，允许发送方发送多个分组而无需等待确认，只要最后能收获到ACK确认的技术就是流水线。可因此也需要增加一些内容： 允许发送发在收到ACK之前连续发送多个分组，需要更大的序列号范围；发送方和接收方需要更大存储空间以缓存分组；出现错误时候的处理：滑动窗口协议（主要是回退N步和选择重传） 滑动窗口协议1比特滑动窗口协议（停等协议）当发送窗口和接收窗口的大小固定为1时，滑动窗口协议退化为停等协议。该协议规定发送方每发送一帧后就要停下来，等待接收方已正确接收的确认（ACK）返回后才能继续发送下一帧。由于接收方需要判断接收到的帧是新发的帧还是重新发送的帧，因此发送方要为每一个帧加一个序号。由于停等协议规定只有一帧完全发送成功后才能发送新的帧，因而只用一比特来编号就够了，具有累计确认机制。 回退N帧协议发送窗口大于1，接收窗口大于1， 由于停等协议要为每一个帧进行确认后才继续发送下一帧，大大降低了信道利用率，因此又提出了后退n协议。后退n协议中，发送方在发完一个数据帧后，不停下来等待应答帧，而是连续发送若干个数据帧，即使在连续发送过程中收到了接收方发来的应答帧，也可以继续发送。且发送方在每发送完一个数据帧时都要设置超时定时器。只要在所设置的超时时间内仍收到确认帧，就要重发相应的数据帧。如：当发送方发送了N个帧后，若发现该N帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不重新发送出错帧及其后的N帧。 选择重传协议发送窗口大于1，接收窗口大于1。在后退n协议中，接收方若发现错误帧就不再接收后续的帧，即使是正确到达的帧，这显然是一种浪费。另一种效率更高的策略是当接收方发现某帧出错后，其后继续送来的正确的帧虽然不能立即递交给接收方的高层，但接收方仍可收下来，存放在接收缓冲区中，同时要求发送方重新传送出错的那一帧。一旦收到重新传来的帧后，就可以原已存于缓冲区中的其余帧一并按正确的顺序递交高层。这种方法称为选择重发(SELECTICE REPEAT)。显然，选择重发减少了浪费，但要求接收方有足够大的缓冲区空间。 有连接运输：TCPTCP特点它是一个点到点的通信机制，只能有一个发送方和一个接收方；它提供是一个可靠的，按序的字节流机制；使用流水线机制，通过拥塞控制和流量控制的机制设置窗口尺寸；发送方和接收方都有缓存；它是一个全双工，能双向传输数据的面向连接的通信，通信双方必须在发送数据之前建立连接，连接状态只能在连接的两端维护，不能在沿途的结点维护状态。 TCP报文段结构 源地址端口，目的端口地址 序号：TCP传输保证连接性，发送的每个字节都要编上号 确认号：接收方期望从对方接受的字节编号。如果报文段的接收方成功的接受了对方发过来的编号x的字节，那么返回x+1作为确认号，确认号可以和数据捎带一起发送） 控制：定义了6中不同的控制位或者标志位：URG:紧急数据标志位，ACK：确认标志位，PSH：请求推送位，接收端应尽快把数据传送给应用层，RST：连接复位，通常，如果TCP收到的一个分段明显不属于该主机的任何一个连接，则向远程发送一个复位包，SYN：建立连接，让连接双方同步序列号，FIN：释放连接 检验和：TCP的使用检验和是强制性的,UDP使用检验和是可选的。在计算检验和是报文段要附加相同的伪首部，对于TCP来说伪首部的协议字段的值是6 TCP实现可靠数据传输TCP在IP层提供的不可靠服务基础上实现的可靠数据传输，使用流水线机制，累积确认机制，单一的重传计时器。触发重传的事件：超时，收到重复的ACK。 快速重传机制TCP实现中，如果发生超时时间，超时时间间隔会重新设置，即将超时时间间隔加倍，导致其很大，重发丢失分组的时间会等待很久的时间。可以通过重复ACK检测检测分组丢失，Sender收到同一个数据的3个ACK，则假定该数据之后的段已经丢失，即在定时器超时之前进行重传。 TCP流量控制接收方为TCP连接分配buffer 如果上层应用处理buffer中的数据较慢，发送方在这个机制下发送方不会传输的太多太快以至于淹没接收方（buffer溢出）实现的时候就是Received在Segment的头部字段中将RcvWindow告诉Sender，Sender限制自己发送的但还没收到ACK的数据不超过接收方的空闲RECWindow的尺寸。但是如果Received告知Sender RcvWindow=0是，发送方仍然可以发送一个很少的数据段，从而更新RcvWindow的值 TCP拥塞控制首先，拥塞控制和流量控制是不一样的。拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程。流量控制是点对点通信量的控制，是一个端到端的问题，主要就是抑制发送端发送数据的速率，以便接收端来得及接收。 拥塞的标志：重传计时器超时，接收到三个重复确认。 发送方维持一个叫做拥塞窗口的状态变量。拥塞窗口的大小取决于网络的拥塞程度，且动态地在变化，我们使用TCP拥塞控制算法，该算法包括：慢开始和拥塞避免以及快速恢复。 慢启动和拥塞避免慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大（指数的增长）逐渐增加拥塞窗口的大小。拥塞避免则是让拥塞窗口缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞控制窗口加一 为了防止拥塞窗口增长过大引起网络拥塞，设置一个慢开始门限（ssthresh状态变量）当拥塞窗口＜ssthresh，使用慢开始算法（指数增长）当拥塞窗口=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法（线性增长）当拥塞窗口＞ssthresh，使用拥塞避免算法 但是无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。 快速恢复与快速重传配合使用采用快速恢复算法时，慢开始只在TCP连接建立时和网络出现超时时才使用。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。 TCP连接管理TCP的三次握手 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x（随机数）； 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置ACK为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y； 客户端收到服务器的SYN+ACK报文段。然后将ACK设置为y+1，向服务器发送ACK报文段， 为什么需要三次握手？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 TCP的四次挥手 为什需要四次挥手？ TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 为什么TCP采用随机初始序列号在TCP的三次握手中，后采用随机产生的初始化序列号进行请求，这样做主要是出于网络安全的因素着想。如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段。 客户端和服务器最多能发送和接收多少TCP连接数？对于服务器，每一个TCP连接都要占一个文件描述符，一旦这个文件描述符使用完了，就会返回错误。我们知道操作系统上端口号1024以下是系统保留的，从1024-65535是用户使用的。由于每个TCP连接都要占一个端口号，所以我们最多可以有60000多个并发连接？但是事实并不是这样。 我们还知道对于TCP连接是由：原IP，原端口，目的IP，目的端口。但是监听server端TCP连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因为它是固定在本地的端口上去监听，所以最大TCP连接为：客户端ip数×客户端port数. 而对于客户端，网络通信过程中服务端监听一个固定的端口,客户端主动发起连接请求后要经过三次握手才能与服务器建立起一个TCP连接.客户端每次发起一个TCP连接时,系统会随机选取一个空闲的端口,该端口是独占的不能与其他TCP连接共享,因此理论上一台机器有多少空闲的端口,就能对外发起多少个TCP连接。根据TCP/IP协议,端口port使用16位无符号整数unsigned short来存储,因此本地端口一共有2^16=65536个,即0-65535,其中0~1023是预留端口,0有特殊含义不能使用,1024以下端口都是超级管理员用户(如root)才可以使用,因此就算使用root权限,一台机器最多能使用的端口也只有65535个。但是一台机器最多只能利用28232个端口.]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React长列表优化方案]]></title>
    <url>%2F2019%2F05%2F23%2FReactNative%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[考虑问题我有一个列表，这个列表里面我需要存放10000条数据，我要使得这个列表进行滑动的时候比较流畅，也就是渲染的效果ok。 对这个问题分析一下，我们知道DOM结构如果过大, 网页就会出现用户操作体验上的问题, 比如滚动, 点击操作，会导致渲染的不够及时情况发生。 解决方案解决方案的话就是对于列表形态的数据展示的按需渲染。这种方式是指根据容器元素的高度以及列表项元素的高度来显示长列表数据中的某一个部分，而不是去完整地渲染长列表。通俗的说就是我就渲染我可见的区域的组件，也就是虚拟列表，它是一种根据滚动容器元素的可视区域来渲染长列表数据中某一个部分数据的技术。 实现虚拟列表就是在处理用户滚动时，要改变列表在可视区域的渲染部分，其具体步骤如下结合图片理解一下： 计算当前可见区域起始数据的 startIndex 计算当前可见区域结束数据的 endIndex 计算当前可见区域的数据，并渲染到页面中 计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上 计算 endIndex对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到列表上。 在React上就是使用react-window 和 react-virtualized是热门的虚拟滚动库，而在ReactNative中，我们可以使用Flatlist和Sectionlist组件，这两个组件呢是继承于VirtualizedLis，这个组件的思想也就是维护活动项的有限渲染窗口并用适当大小的空白空间替换渲染窗口之外的所有项，大大提高了大型列表的内存消耗和性能。这样已经能满足大多数情况下的使用，但是这个有一个问题就是当我们更快地滚动时会暂时看到空白内容。我测试了一下，大部分的软件在滑动过快的时候也就会出现加载上的情况等待加载。 所以使用Flatlist和Sectionlist组件能解决常用的长列表问题，至于Flatlist内容的更多优化，可以参考http://yangguang1029.github.io/2018/12/20/rn-improve-flatlist/]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css语法熟悉]]></title>
    <url>%2F2019%2F05%2F23%2FCss%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Css概念它是一个层叠样式表，存储着很多的样式，而样式定义着如何显示Html元素，因此解决了内容与表现分离的问题，就是我Html只需要写内容，然后用Css来控制它的表现。 当同一个Html元素被不止一个样式定义的时候，会根据优先级高低控制，优先级从高到低依次是： 内联样式（在 Html元素内部）-&gt; 内部样式表（位于 &lt;head&gt; 标签内部）-&gt; 外部样式表 -&gt; 浏览器缺省设置 Css基础Css语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 选择器通常是您需要改变样式的 Html元素。每条声明由一个属性和一个值组成。属性就是希望设置的样式属性。你也可以对选择器进行分组，如下： 123h1,h2,h3,h4,h5,h6 &#123; color: green; &#125; Css的选择器派生选择器用于根据文档的上下文关系来确定某个标签的样式，比方说希望列表中的strong元素变为斜体字，那么我选择器就写成li strong {...}，这样的话只有 li元素中的strong元素的样式为斜体字，不在li元素内部的就还是正常的粗体字. id选择器id 选择器以&quot;#&quot; 来定义。可以独立的调用如：#red {color:red;}。它可以利用派生选择器的思想进行联合使用，比方： 12345#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em; &#125; 那么上面的样式只会应用于出现在id 是 sidebar 的元素内的段落。 注意：id属性只能在每个 Html 文档中出现一次。 类选择器它以一个点号显示： 1234.center &#123;text-align: center&#125;&lt;h1 class="center"&gt;This heading will be center-aligned&lt;/h1&gt; 注意：类名的第一个字符不能使用数字。 属性选择器它以为拥有指定属性的HTML 元素设置样式，而不仅限于class和 id属性，对带有指定属性的HTML 元素设置样式。它还可以绑定值： 12345&lt;!-- 不带后面的等号内容的时候就是为所有带有 title 属性的所有元素设置样式 --&gt;[title=W3School]&#123;border:5px solid blue;&#125; 属性选择器在为不带有 class 或id的表单设置样式时特别有用，如设置表单的样式 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;input[type="text"]&#123; width:150px; display:block; margin-bottom:10px; background-color:yellow; font-family: Verdana, Arial;&#125;input[type="button"]&#123; width:120px; margin-left:35px; display:block; font-family: Verdana, Arial;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form name="input" action="" method="get"&gt;&lt;input type="text" name="Name" value="Bill" size="20"&gt;&lt;input type="text" name="Name" value="Gates" size="20"&gt;&lt;input type="button" value="Example Button"&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 如何插入一个样式表外部样式表个页面使用 &lt;link&gt;标签链接到样式表。&lt;link&gt;标签在（文档的）头部： 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;&lt;/head&gt; 内部样式表当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 &lt;style&gt;标签在文档头部定义内部样式表，就像这样: 1234567&lt;head&gt;&lt;style type="text/css"&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125; body &#123;background-image: url("images/back40.gif");&#125;&lt;/style&gt;&lt;/head&gt; 内联样式当样式仅需要在一个元素上应用一次时。 123&lt;p style="color: sienna; margin-left: 20px"&gt;This is a paragraph&lt;/p&gt; 注意：如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。相同的时候按优先级来选择继承。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html语法熟悉]]></title>
    <url>%2F2019%2F05%2F23%2FHtml%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Html基础Html 标题Heading是通过 &lt;h1&gt; - &lt;h6&gt; 等标签进行定义的 12&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;h2&gt;This is a heading&lt;/h2&gt; Html段落它是通过 &lt;p&gt;标签进行定义的 1&lt;p&gt;This is a paragraph.&lt;/p&gt; Html折行通过&lt;br/&gt;实现折行 1&lt;p&gt;This is&lt;br /&gt;a para&lt;br /&gt;graph with line breaks&lt;/p&gt; Html水平线是通过&lt;hr/&gt;用于在页面中创建水平线 12&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;hr/&gt; Html链接1&lt;a href="http://www.w3school.com.cn"&gt;This is a link&lt;/a&gt; Html图像通过&lt;img&gt;标签进行定义的，可以定义它的大小，位置等，还有一个代替文本 1&lt;img src="w3school.jpg" width="104" height="142" alt="Big Boat"&gt; Html元素是从开始标签到结束标签的所有代码。 12345&lt;html&gt;&lt;body&gt;&lt;p&gt;This is my first paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 以上实例就是有三个元素，&lt;html&gt;元素，&lt;body&gt; 元素，&lt;p&gt;元素。对应的元素内容就是body元素，p元素和This is my first paragraph。 Html属性可以给Html元素提供更多的信息，并且属性总是在 Html元素的开始标签中规定。比方说它可以定义这个元素在哪个位置呈现，背景颜色是什么，是否加个链接，样式是什么这些的。列一点： 属性 值 描述 class classname 规定元素的类名（classname） id id 规定元素的唯一 id style style_definition 规定元素的行内样式（inline style） title text 规定元素的额外信息（可在工具提示中显示） 注意Html的style属性可以直接使用 style 属性直接将样式添加到 HTML元素，也可以间接地在独立的样式表中（CSS 文件）进行定义。比方说设置一下字体，大小，颜色等： 12345&lt;html&gt;&lt;body&gt;&lt;p style=&quot;font-family:arial;color:red;font-size:20px;&quot;&gt;A paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Html文本格式化对应标签： 标签 描述 &lt;b&gt; 定义粗体文本。 &lt;big&gt; 定义大号字。 &lt;i&gt; 定义斜体字。 &lt;small&gt; 定义小号字。 &lt;strong&gt; 定义加重语气。 &lt;sub&gt; 定义下标字。 &lt;sup&gt; 定义上标字。 &lt;ins&gt; 定义插入字。 Html引用是通过&lt;q&gt;元素定义短的引用， &lt;blockquote&gt;元素定义被引用的节且会进行缩进处理。 Html缩进利用&lt;abbr&gt; 。 Html&lt;address&gt;元素定义文档或文章的联系信息（作者/拥有者）。且此元素通常以斜体显示。大多数浏览器会在此元素前后添加折行。 Html的计算机代码格式对于计算机代码格式利用&lt;kbd&gt;（定义键盘输入）, &lt;samp&gt;（定义计算机输出示例）, &lt;pre&gt;（定义预格式化文本）以及 &lt;code&gt;（定义计算机代码文本）元素，如： 1234567891011&lt;p&gt;Coding Example:&lt;/p&gt;&lt;code&gt;&lt;pre&gt;var person = &#123; firstName:"Bill", lastName:"Gates", age:50, eyeColor:"blue"&#125;&lt;/pre&gt;&lt;/code&gt; Html链接它的name属性，它规定了锚的名称，当使用命名锚时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接。如： 123456首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：&lt;a name="tips"&gt;基本的注意事项 - 有用的提示&lt;/a&gt;然后，我们可以在同一个文档中创建指向该锚的链接：&lt;a href="#tips"&gt;有用的提示&lt;/a&gt;也可以在其他页面中创建指向该锚的链接&lt;a href="http://www.w3school.com.cn/html/html_links.asp#tips"&gt;有用的提示&lt;/a&gt; Html列表： 标签 描述 &lt;ol&gt; 定义有序列表。 &lt;li&gt; 定义列表项。 &lt;ul&gt; 定义无序列表。 &lt;dl&gt; 自定义列表 &lt;dt&gt; 自定义项目 &lt;dd&gt; 自定义描述 Html的&lt;div&gt;元素它是一个块级元素(块级元素在浏览器显示时，通常会以新行来开始（和结束）)可用于组合其他Html元素的容器。 Html的类和布局对 HTML 进行分类（设置类），使我们能够为元素的类定义 CSS 样式。为相同的类设置相同的样式，或者为不同的类设置不同的样式。联合&lt;div&gt;理解，&lt;div&gt;把这个html分块了，有的块样式相同有的不相同就可以使用相同的类或者不同的类，如： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.cities &#123; background-color:black; color:white; margin:20px; padding:20px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="cities"&gt;&lt;h2&gt;London&lt;/h2&gt;&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;/div&gt;&lt;div class="cities"&gt;&lt;h2&gt;Paris&lt;/h2&gt;&lt;p&gt;Paris is the capital and most populous city of France.&lt;/p&gt;&lt;/div&gt;&lt;div class="cities"&gt;&lt;h2&gt;Tokyo&lt;/h2&gt;&lt;p&gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area,and the most populous metropolitan area in the world.&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 同理Html的 &lt;span&gt; 元素是行内元素，能够用作文本的容器。设置 &lt;span&gt;元素的类，能够为相同的&lt;span&gt;元素设置相同的样式。 布局的话就是Html和Css的联合使用了，利用Html语言对我们需要呈现的内容就行分块，然后Css对于这些分好的块填充样式，包括放哪。这样的结合之后就可以写出一个静态的页面了。]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接下来三个月事情安排]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%8E%A5%E4%B8%8B%E6%9D%A5%E4%B8%89%E4%B8%AA%E6%9C%88%E4%BA%8B%E6%83%85%E5%AE%89%E6%8E%92%2F</url>
    <content type="text"><![CDATA[这次我选择去深圳，做一个前端的实习，前端对于我来说是一个很陌生的环境，其实想去找后台的工作，但我对于后台也不是很熟悉，只是对语言熟悉一些，具体的业务和开发流程熟悉的不够，所以我想多尝试一下。除了项目上的更多的熟悉，基础的知识方面也不能忘，这是对自己的要求，好好准备三个月冲刺一下准备秋招。不让任何人失望，不让自己最后觉得自己没有拼尽全力。加油，自己！ 打算完成的事情（不断更新）： 1.实习时候前端安排到的学习任务，项目任务。在步入正轨的时候尝试的去接触一下后台开发 2.SpringBoot学习，花一个月的时间把牛客高级项目课的内容搞定，理解的那种，所有的内容记录好博客。（这玩意等到自己熟悉了前端的这块内容之后再去看） 3.计算机网络自定向下，主要是传输层那块的内容，网络编程，学习内容记录 4.操作系统设计与实现，熟悉进程线程的那块 5.高性能Mysql，redis，牛客网的sql题，特别是数据库的索引那块内容 6.Java语言和JavaScript语言的熟悉，用Java语言去刷LeetCode，保持自己的做题能力，每天完成5道简单题，2-3进阶题，记录自己的结题思路。（做题数这块要改一下，还是和SpringBoot学习一样，现在一天做个一两道等到步入正轨的时候开始按计划完成一定的数量） 7.看一些之前自己没看的文学书：围城，我们仨，充实一下自己内心，改一下自己急躁的性格 8.关注助理的事情，把最后几个月的学生工作做好结尾]]></content>
      <categories>
        <category>事务安排和感想</category>
      </categories>
      <tags>
        <tag>安排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理机调度和死锁]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[概念在多道程序环境下，进程数目往往多于处理机数目，致使它们竞争使用处理机。这就要求系统能按某种算法，动态地把处理机分配给就绪队列中的一个进程，使之执行。一个作业从提交开始，往往要经历三级调度：高级调度、中级调度、低级调度。 高级调度：调度对象是作业。 中级调度：提高内存利用率和系统吞吐量。 低级调度：它所调度的对象是进程。进程调度是最基本的一种调度。进程调度方式有两种调度方式：非抢占方式和抢占方式（基于优先权，短作业优先，时间片原则）。 作业调度和进程调度的区别作业调度为进程活动做准备，进程调度使进程活动起来 作业调度次数少，进程调度次数多 有的系统不设作业调度，但进程调度必不可少 进程调度算法FCFS先来先服务该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。FCFS 算法比较有利于长作业(进程)，而不利于短作业(进程)。 短作业优先短作业优先调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。 高优先权优先调度算法（动态优先权）动态优先级调度算法是指在创建进程之初，先赋予其一个优先级，然后其值随着进程的推进或等待时间的增加而改变，以便获得更好的调度性能。例如，可以规定在就绪队列中的进程随其等待的时间的正常，使其优先级相应提高。若所有的进程都具有相同的优先级初值，则最先进入就绪队列的进程会因为其优先级变得最高，而优先获得处理机，这相当于FCFS算法。若所有的就绪进程具有各不相同的优先级初值，那么对于优先级初值低的进程，在等待了足够的时间后，也可以获得处理机。 基于时间片的轮转调度算法在分时系统中，为保证能及时响应用户的请求，必须采用基于时间片的轮转式进程调度算法。每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。 死锁产生死锁原因竞争资源（多个进程竞争共享的资源），进程间推进顺序非法（进程请求和释放的资源顺序不当） 产生死锁的条件互斥条件，请求和保持条件，不剥夺条件，环路等待条件。 处理死锁的几种条件预防死锁，避免死锁，检测死锁，解除死锁。 银行家算法它是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。 安全序列是指一个进程序列{P1，…，Pn}是安全的，即对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。（即在分配过程中，不会出现某一进程后续需要的资源量比其他所有进程及当前剩余资源量总和还大的情况）注：存在安全序列则系统是安全的，如果不存在则系统不安全，但不安全状态不一定引起死锁。 原理过程：系统给当前进程分配资源时，先检查是否安全：在满足当前的进程X资源申请后，是否还能有足够的资源去满足下一个距最大资源需求最近的进程（如某进程最大需要5个单位资源，已拥有1个，还尚需4个），若可以满足，则继续检查下一个距最大资源需求最近的进程，若均能满足所有进程，则表示为安全，可以允许给当前进程X分配其所需的资源申请，否则让该进程X进入等待。（注：检查过程中，每拟满足一个进程，则进行下个检查时，当前可用资源为回收上一个进程资源的总值，每满足一个进程表示此进程已结束，资源可回收。） 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;string&gt;using namespace std;const int maxnsource = 100;const int maxnprocess = 50;int available[maxnsource];//可以使用的资源。int max[maxnprocess][maxnprocess];//最大需求矩阵。int allocation[maxnprocess][maxnprocess];//已经分配的矩阵。int need[maxnprocess][maxnprocess];//还需要的矩阵。int requestsource[maxnprocess][maxnprocess];//进程请求的矩阵。int finish[maxnprocess];//进程是否能得到足够的资源使其结束。int n, m;int i, j;int p[maxnsource];//记录进程号int safe()//判断是否为安全的&#123; int cnt = 0; int flag = 0; int temp[maxnsource]; for (i = 0; i &lt; n; i++) temp[i] = available[i]; for (i = 0; i &lt; m; i++) &#123; if (finish[i] == 0) &#123; for (j = 0; j &lt; n; j++) &#123; if (need[i][j] &gt; temp[j]) break; &#125; if (j == n) &#123; finish[i] = 1; for (int k = 0; k &lt; n; k++) temp[k] += allocation[i][k]; p[cnt++] = i; i = -1;//这里不是0,重置之后i++会变为1，就错了。 &#125; else continue; if (cnt == m) &#123; cout &lt;&lt; "系统是安全的" &lt;&lt; endl; cout &lt;&lt; "安全序列:" &lt;&lt; endl; for (i = 0; i&lt;cnt; i++) &#123; cout &lt;&lt; p[i]; if (i != cnt - 1) &#123; cout &lt;&lt; "--&gt;"; &#125; &#125; cout &lt;&lt; "" &lt;&lt; endl; return 1; &#125; &#125; &#125; cout &lt;&lt; "系统是不安全的" &lt;&lt; endl; return 0;&#125;void bank()//银行家算法&#123; int cur; while (1) &#123; cout &lt;&lt; "输入要申请资源的进程号" &lt;&lt; endl; cin &gt;&gt; cur; cout&lt;&lt; "输入进程所请求的各资源的数量" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) cin &gt;&gt; requestsource[cur][i]; for (int i = 0; i &lt; n; i++) &#123; if (requestsource[cur][i] &gt; need[cur][i]) &#123; cout &lt;&lt; "输入的请求数超过进程的需求量!请重新输入!" &lt;&lt; endl; continue; &#125; if (requestsource[cur][i] &gt; available[i]) &#123; cout &lt;&lt; "输入的请求数超过系统有的资源数!请重新输入!" &lt;&lt; endl; continue; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; available[i] -= requestsource[cur][i]; allocation[cur][i] += requestsource[cur][i]; need[cur][i] -= requestsource[cur][i]; &#125; for (int i = 0; i &lt; m; i++) finish[i] = 0; if (safe()) &#123; cout &lt;&lt; "同意分配请求!" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "您的请求被拒绝!" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; available[i] += requestsource[cur][i]; allocation[cur][i] -= requestsource[cur][i]; need[cur][i] += requestsource[cur][i]; &#125; for (int i = 0; i &lt; m; i++) finish[i] = 0; string s; cout &lt;&lt; "是否还想再次请求分配吗?如果想，请输入YES" &lt;&lt; endl; cin &gt;&gt; s; if (s == "YES") continue; else break; &#125; &#125;&#125;int main()&#123; memset(finish, 0, sizeof(finish)); cout &lt;&lt; "输入进程的数量:"; cin &gt;&gt; m; cout &lt;&lt; "输入资源的种类:"; cin &gt;&gt; n; cout &lt;&lt; "输入每个进程最多所需要的资源数："; for (i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; max[i][j]; cout &lt;&lt; "输入每个进程已经分配的资源数："; for (i = 0; i &lt; m; i++) &#123; for (j = 0; j &lt; n; j++) &#123; cin &gt;&gt; allocation[i][j]; need[i][j] = max[i][j] - allocation[i][j]; if (need[i][j] &lt; 0) &#123; cout &lt;&lt; "输入的第" &lt;&lt; i + 1 &lt;&lt; "个进程所拥有的第" &lt;&lt; j + 1 &lt;&lt; "个资源数 错误,请重新输入:" &lt;&lt; endl; j--; continue; &#125; &#125; &#125; cout &lt;&lt; "输入各资源现有的资源数："; for (i = 0; i &lt; n; i++) cin &gt;&gt; available[i]; /*for (i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; max[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125; for (i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; allocation[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125; for (i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; need[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125;*/ safe(); bank(); return 0;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程（持续更新）]]></title>
    <url>%2F2019%2F05%2F22%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概念与区别从本质上来说，一个进程就是一个正在执行的程序，它是系统进行资源分配和调度的基本单位，是操作系统结构的基础。每个进程都有自己的地址空间，包括可执行程序，程序的数据，栈，一组寄存器（程序计算器，栈指针以及其他运行程序需要的信息 线程有时被称为轻量级进程，是程序执行的最小执行流，它是进程的一个实体，是系统独立调度和分派的基本单位 进程和线程的区别： 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。 资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程 执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 线程是处理器调度的基本单位，但是进程不是。 两者均可并发执行。 进程进程的创建和终止进程的创建主要有四个原因：系统初始化，正在运行的进程执行了创建进程的系统调用，用户请求创建一个进程以及批处理作业的初始化。 常见的就是一个进程调用了fork()函数创建新的进程。 进程终止的一些原因：工作完成正常退出，出错退出，严重错误，被其他进程杀死。 进程的状态和控制原语进程有三种状态：运行态，阻塞态，就绪态。这三种状态的转换是： 就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。 阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。 运行：当一个进程在处理机上运行时，则称该进程处于运行状态。 注意不可能存在直接从阻塞态转换到执行态。 除了这三个基本状态还有一个挂起状态，新建状态，终止状态。 引起挂起状态的原因：终端用户的请求，父进程请求，负荷调节的需要，操作系统的需要。 用于控制进程的原语有： 创建原语（Create）：创建一个就绪状态的进程，使进程从创建状态变迁为就绪状态。 阻塞原语（Block）：使进程从执行状态变迁为阻塞状态。 唤醒原语（Wakeup）：使进程从阻塞状态变迁为就绪状态。 挂起原语（Suspend）：将指定的进程或处于阻塞的进程挂起]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语法熟悉二]]></title>
    <url>%2F2019%2F05%2F22%2FJs%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%891%2F</url>
    <content type="text"><![CDATA[JavaScript输出使用window.alert()12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;window.alert(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用innerHTML写入Html元素如需访问 HTML 元素，JavaScript 可使用 document.getElementById(id) 方法。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt; document.getElementById(&quot;demo&quot;).innerHTML = 5 + 6;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; console.log()写入控制台12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;console.log(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用document.write()写入Html元素12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;document.write(5 + 6);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 但是在 HTML 文档完全加载后使用 document.write()将删除所有已有的 HTML，所以只用于测试 什么时候产生NaN表达式计算一个表达式中如果有减号 (-)、乘号 (*) 或 除号 (/) 等运算符时，JS 引擎在计算之前，会试图将表达式的每个分项转化为 Number 类型（使用 Number(x) 做转换）。如果转换失败，表达式将返回 NaN 。 123456100 - '2a' ; // NaN'100' / '20a'; // NaN'20a' * 5 ; // NaNundefined - 1; // NaN, Number(undefined) == NaN[] * 20 ; // 0, Number([]) == 0null - 5; // -5, Number(null) == 0 类型转换直接使用 parseInt，parseFloat 或 Number 将一个非数字的值转化为数字时，表达式返回 NaN ,但是对于 数字+字符的值，其转化结果会有所不同，Number 转换的是整个值，而不是部分值；parseInt 和 parseFloat 只转化第一个无效字符之前的字符串。 另外，一元加操作符也可以实现与 Number 相同的作用。 ： 123456789101112'abc' - 3 // NaNparseInt('abc') // NaNparseFloat('abc') // NaNNumber('abc') // NaNNumber('123abc'); // NaNparseInt('123abc'); // 123parseInt('123abc45'); // 123parseFloat('123.45abc');// 123.45+ '12abc'; // NaN+ '123'; // 123+ '123.78'; // 123.78+ 'abc'; // NaN 三个标准对象DateDate对象用来表示日期和时间。Date常用的一些函数： 123456789101112131415var now = new Date();//获取系统当前时间now; now.getFullYear(); // 2019, 获得now这个Date的年份now.getMonth(); // 4, 获得now这个Date的月份，注意月份范围是0~11，4表示五月now.getDate(); // 22, 获得now这个Date的日期，表示24号now.getDay(); // 3, 获得now这个Date的星期几，表示星期三now.getHours(); // 18, 获得now这个Date的小时，24小时制now.getMinutes(); // 30, 获得now这个Date的分钟now.getSeconds(); // 22, 获得now这个Date的秒数now.getMilliseconds(); // 426, 获得now这个Date的毫秒数now.getTime(); // 1558521017632, 以number形式表示的时间戳，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数，时间戳可以精确地表示一个时刻，并且与时区无关var d = new Date(2015, 5, 19, 20, 15, 30, 123);//创建一个自己要求的Dated; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)var d = Date.parse('2015-06-24T19:49:22.875+08:00');//创建一个自己要求的Date的第二种方法d; // 1435146562875 注意 JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 Json首先Json是一种数据传输的格式。 其次把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串。对应的如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。 序列化是通过JSON.stringify(JavaScirpt的对象)来实现的。这个函数有三个参数，第一个就是我们要序列化的JavaScript的对象，第二个参数是用来控制如何筛选对象的键值，比方可以传函数，传要取出来的属性，第三个是控制的转换后的格式。如果我们还想要精确控制如何序列化一个对象的话如xiaoming，可以给xiaoming定义一个toJSON()的方法，直接返回JSON应该序列化的数据： 12345678910111213141516var xiaoming = &#123; name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\"W3C\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'], toJSON: function () &#123; return &#123; // 只输出name和age，并且改变了key： 'Name': this.name, 'Age': this.age &#125;; &#125;&#125;;JSON.stringify(xiaoming); // '&#123;"Name":"小明","Age":14&#125;' 反序列化是通过用JSON.parse()把它变成一个JavaScript对象，同时这个函数还可以接收一个函数作为参数，用来转换解析出的属性： 1234567var obj = JSON.parse('&#123;"name":"小明","age":14&#125;', function (key, value) &#123; if (key === 'name') &#123; return value + '同学'; &#125; return value;&#125;);console.log(JSON.stringify(obj)); // &#123;name: '小明同学', age: 14&#125; RegExp(待补)面向对象创建对象JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。形成一个原型链，当我们要访问一个对象的一个属性的时候，就会通过这个原型链查找，如果一直找到Object.prototype对象，都还没有找到，就只能返回undefined。 比方说我们创建了一个Array对象，我们可以得到其对应的原型链如下： 12var arr = [1, 2, 3];arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null 我们这个arr对象，能调用arr，Array.prototype，Object.prototype上定义的所有的方法。 构造函数，除了直接用{...}创建一个函数之外，还可以通过构造函数创建对象 123456789function Student(name) &#123; this.name = name; this.hello = function () &#123; alert('Hello, ' + this.name + '!'); &#125;&#125;var xiaoming = new Student('小明');xiaoming.name; // '小明'xiaoming.hello(); // Hello, 小明! 这是一个普通函数，但是在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象,注意，如果不写new，这就是一个普通函数，它返回undefined。 class继承在ES6开始引入了class这个概念，就很类似Java的class对象了，例如： 12345678class Student &#123; constructor(name) &#123;//构造函数 this.name = name; &#125; hello() &#123;//普通函数 alert('Hello, ' + this.name + '!'); &#125;&#125; 继承的话和Java也很像，利用extends关键字 123456789class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 错误处理错误捕获这个和Java也很像，利用try ... catch捕获。 如果代码发生了错误，又没有被try ... catch捕获，那么，程序执行流程会跳转到哪呢？如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。 利用try ... catch捕获错误1234567891011121314151617181920function main(s) &#123; console.log('BEGIN main()'); try &#123; foo(s); &#125; catch (e) &#123; console.log('出错了：' + e); &#125; console.log('END main()');&#125;function foo(s) &#123; console.log('BEGIN foo()'); bar(s); console.log('END foo()');&#125;function bar(s) &#123; console.log('BEGIN bar()'); console.log('length = ' + s.length); console.log('END bar()');&#125;main(null);]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative（一）]]></title>
    <url>%2F2019%2F05%2F22%2FReactNative%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[搭建第一个ReactNative项目环境要求需要Node，Python2，Jdk，Android Studio，Android SDK。 注：学会通过Chocolatey（一种流行的Windows程序包管理器）安装Node和Python2以及Jdk。 配置环境变量添加ANDROID_HOME 在Windows控制面板中的“ 系统和安全”下打开“系统”窗格，然后单击“ 更改设置…”。打开“ 高级”选项卡，然后单击“ 环境变量…”。单击New …以创建ANDROID_HOME指向Android SDK路径的新用户变量 将平台工具添加到Path 在Windows控制面板中的“ 系统和安全”下打开“系统”窗格，然后单击“ 更改设置…”。打开“ 高级”选项卡，然后单击“ 环境变量…”。选择Path变量，然后单击“ 编辑”。单击“ 新建”，将平台工具的路径添加到列表中。 此文件夹的默认位置是： 1c:\Users\YOUR_USERNAME\AppData\Local\Android\Sdk\platform-tools 跑Demo利用cmd命令行界面生成一个名为AwesomeProject的新React Native项目 1react-native init AwesomeProject 利用Android Studio打开这个项目，并跑好虚拟机。 然后在命令行运行 12cd AwesomeProjectreact-native run-android 如果设置都是正确的话，你就能得到以下界面：（这样的话第一个demo就跑通了，要修改的话就在App.js文件修改即可，刷新的话使用ctrl+m或者双击RR 基础知识简单的组件介绍学习过Html的话会熟悉很多，ReactNative提供很多的内置组件像&lt;Text&gt;，&lt;View&gt;，&lt;Button&gt;这些，当然你也可以自己定义自己的组件，如下，这样的话我们就定义好了自己的组件Greeting。 123456789class Greeting extends Component&#123; render()&#123; return ( &lt;View style=&#123;styles.instructions&#125;&gt; &lt;Text&gt; Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 大多数组件在创建时可以使用不同的参数进行自定义。调用这些创建参数props。 比方说利用组件Image创建图像，可以使用命名的道具source来控制它显示的图像。 12345678910111213141516import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render() &#123; let pic=&#123; uri : 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg' &#125;; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt;Hello World!&lt;/Text&gt; &lt;Image source=&#123;pic&#125; style=&#123;styles.iamge1&#125;/&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 这个是内置组件自带的道具，那么要是我们自己定义的组件的话想用props也是可以的。如下 自己定义的组件，通过在下面组件的调用的时候传入参数，利用this.props来调用显示。道具的概念就是对于组件使用不同的参数进行自定义的操作。像正常组件Text调用的style，Image调用source的这些都是道具也就是props。（个人感觉把道具和props连在一起理解会好一些） 1234567891011121314151617181920212223import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';class Greeting extends Component&#123; render()&#123; return ( &lt;View style=&#123;styles.instructions&#125;&gt; &lt;Text&gt; Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default class App extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center', top: 50&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 对于每个组件的话是有两个控制组件的参数：props和state。props由父项设置，它们在组件的整个生命周期内都是固定的。对于即将发生变化的数据，我们必须使用state，利用setstate来重新渲染。假设我们想要制作一直闪烁的文本的话代码如下： 123456789101112131415161718192021222324252627282930313233import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';class Greeting extends Component&#123; constructor(props)&#123; super(props); this.state= &#123;isShowingText :true&#125;; setInterval(() =&gt; ( this.setState(previousState =&gt; ( &#123;isShowingText: !previousState.isShowingText&#125; )) ),1000); &#125; render()&#123; if(!this.state.isShowingText)&#123; return null; &#125; return( &lt;Text&gt;&#123;this.props.name&#125;&lt;/Text&gt; ); &#125;&#125;export default class App extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center', top: 50&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 但是在实际应用中，会调用Redux或者Mobx等状态容器来控制数据流。（还没用过，口嗨一下） 样式和组件大小所有核心组件都接受名为的道具style，就是当一个组件需要写的道具过多的时候，就用样式来代替它。如下：（复制下教程的代码，自己写的因为堆积内容过多） 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View &#125; from 'react-native';const styles = StyleSheet.create(&#123; bigBlue: &#123; color: 'blue', fontWeight: 'bold', fontSize: 30, &#125;, red: &#123; color: 'red', &#125;,&#125;);export default class LotsOfStyles extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt; &lt;Text style=&#123;styles.bigBlue&#125;&gt;just bigBlue&lt;/Text&gt; &lt;Text style=&#123;[styles.bigBlue, styles.red]&#125;&gt;bigBlue, then red&lt;/Text&gt; &lt;Text style=&#123;[styles.red, styles.bigBlue]&#125;&gt;red, then bigBlue&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; LotsOfStyles); 组件大小的话是用width和height样式来控制的 1234567891011121314import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, View &#125; from 'react-native';export default class FixedDimensionsBasics extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 100, height: 100, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 150, height: 150, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; FixedDimensionsBasics); 利用Flexbox进行布局和Flex尺寸组件可以使用Flexbox算法指定其子项的布局，常用flexDirection，alignItems以及justifyContent。不同的又有一些对应的参数值 1234567891011121314import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render()&#123; return( &lt;View style=&#123;&#123;flex: 1,flexDirection: 'column',justifyContent: 'flex-end'&#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;flex: 2, height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;flex: 3, height: 50, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 我们看到第一个View有个flex的参数设置为1，它告诉组件填充所有可用空间，在具有相同父级的其他组件之间平均共享。孩子所占用的分量根据孩子的flex值进行相比分配，但是注意如果组件的父级具有大于0的维度，则组件只能展开以填充可用空间。如果父组件没有固定的width和height或flex，则父组件的维度为0，flex子组件将不可见。也就是如果父组件的flex为0了，或者只给了width或者heigth它的子组件是没办法显示的。 处理文本输入和处理接触文本输入利用TextInput组件，它是一个允许用户输入文本的基本组件，它有onChangeText和onSubmitEditing这两个props。假设用户键入时，您将其单词翻译成其他语言。在这种新语言中，每个单词用$$$代替。（还不是很理解和这个函数的写法，后续学习补一下） 1234567891011121314151617181920212223import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; constructor(props)&#123; super(props); this.state= &#123;text: ''&#125;; &#125; render()&#123; return( &lt;View style=&#123;&#123;padding:10&#125;&#125;&gt; &lt;TextInput style=&#123;&#123;height: 40&#125;&#125; placeholder="Type here to translate!" onChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125; /&gt; &lt;Text style=&#123;&#123;padding: 10,fontSize: 42&#125;&#125;&gt; &#123;this.state.text.split(' ').map((word) =&gt; word &amp;&amp; '$$$').join(' ')&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 处理接触的话是利用Button这个组件还有一些处理常见的手势组件（没看），简单看一下接触的处理。可触摸的组件有多种返回类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; onPressButton()&#123; Alert.alert('you tapped the button'); &#125; onLongPresssButton()&#123; Alert.alert('you press the button longer'); &#125; render()&#123; return( &lt;View style=&#123;styles.container&#125;&gt; //当用户按下按钮时，视图的背景将变暗。 &lt;TouchableHighlight onPress=&#123;this.onPressButton&#125; underlayColor='white'&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableHighlight&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; //通过降低按钮的不透明度来提供反馈，从而允许在用户按下时看到背景 &lt;TouchableOpacity onPress=&#123;this.onPressButton&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableOpacity&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; //显示响应用户触摸的墨水表面反应涟漪 &lt;TouchableNativeFeedback onPress=&#123;this.onPressButton&#125; background=&#123;Platform.OS === 'android' ? TouchableNativeFeedback.SelectableBackground() : ''&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableNativeFeedback&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableNativeFeedback&gt; //处理点击手势但不希望显示任何反馈 &lt;TouchableWithoutFeedback onPress=&#123;this.onPressButton&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableWithoutFeedback&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableWithoutFeedback&gt; //在之前的视图变暗的基础上加上了一个长按的操作 &lt;TouchableHighlight onPress=&#123;this.onPressButton&#125; onLongPress=&#123;this.onLongPresssButton&#125; underlayColor="white"&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Touchable with Long Press&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 滚动条和列表视图ScrollView一个通用的滚动容器，可以放置多个component或者 views，通过参数控制是横着还是竖着。 123456789101112131415161718192021222324import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; //实现一个界面放两个滚动条 render() &#123; render() &#123; return ( &lt;View&gt; &lt;ScrollView horizontal&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Scroll me plz&lt;/Text&gt; &lt;/ScrollView&gt; &lt;ScrollView&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;If you like&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Scrolling down&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;What's the best&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;Framework around?&lt;/Text&gt; &lt;Text style=&#123;&#123;fontSize:80&#125;&#125;&gt;React Native&lt;/Text&gt; &lt;/ScrollView&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); React Native提供了一套用于显示数据列表的组件：FlatList和SectionList。列表视图最常见的用途之一是显示从服务器获取的数据。 FlatList组件显示一个滚动列表，它唯一呈现当前在屏幕上显示的元素，而不是一次显示所有元素。它有两个道具：data和renderItem。data是列表的信息来源。renderItem从源中获取一个项目并返回要呈现的格式化组件。 12345678910111213141516171819202122232425import React, &#123;Component&#125; from 'react';import &#123;FlatList, ScrollView, Platform, StyleSheet, Text, View, AppRegistry, Image, TextInput, Button, Alert, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback&#125; from 'react-native';export default class App extends Component &#123; render()&#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123;[ &#123;key: 'Devin'&#125;, &#123;key: 'Jackson'&#125;, &#123;key: 'James'&#125;, &#123;key: 'Joel'&#125;, &#123;key: 'John'&#125;, &#123;key: 'Jillian'&#125;, &#123;key: 'Jimmy'&#125;, &#123;key: 'Julie'&#125;, ]&#125; //renderItem这个不是很懂，看懂了再解释 renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item.key&#125;&lt;/Text&gt;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('AwesomeProject', () =&gt; App); 如果将一组数据分解为逻辑部分，可能使用部分标题，那么就使用SectionList 1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, SectionList, StyleSheet, Text, View &#125; from 'react-native';export default class SectionListBasics extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;SectionList sections=&#123;[ &#123;title: 'D', data: ['Devin']&#125;, &#123;title: 'J', data: ['Jackson', 'James', 'Jillian', 'Jimmy', 'Joel', 'John', 'Julie']&#125;, ]&#125; renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item&#125;&lt;/Text&gt;&#125; renderSectionHeader=&#123;(&#123;section&#125;) =&gt; &lt;Text style=&#123;styles.sectionHeader&#125;&gt;&#123;section.title&#125;&lt;/Text&gt;&#125; keyExtractor=&#123;(item, index) =&gt; index&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, paddingTop: 22 &#125;, sectionHeader: &#123; paddingTop: 2, paddingLeft: 10, paddingRight: 10, paddingBottom: 2, fontSize: 14, fontWeight: 'bold', backgroundColor: 'rgba(247,247,247,1.0)', &#125;, item: &#123; padding: 10, fontSize: 18, height: 44, &#125;,&#125;)AppRegistry.registerComponent('AwesomeProject', () =&gt; SectionListBasics);]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语法熟悉一]]></title>
    <url>%2F2019%2F05%2F21%2FJs%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[Js基本语法在哪里引入Js代码？1）首先JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到&lt;head&gt;中，我们看到网页的源码的时候被&lt;script&gt;...&lt;/script&gt;包含的代码就是JavaScript代码，它会直接被浏览器执行。 2）单独的写一个 .js文件，然后在HTML中通过&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;引入这个文件。这样的话是方便多个网页应用到了同一份Js文件。 数据类型，运算符以及变量的申明1）Js的数据类型主要有Number，布尔值，字符串。JavaScript不区分整数和浮点数，统一用Number表示。 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity Number可以直接做四则运算，规则和数学一致。 注意一个点：字符串也可以使用加号，但是字符串将被级联但是注意字符串和数字相加会返回一个字符串，例如： 1234var x = "8" + 3 + 5;//输出结果：835var x = 3 + 5 + "8";//输出结果88 布尔值的话只能有false，true两种。 字符串的话就跟Java，c++的都差不多，不过JavaScript中以单引号’或双引号”括起来的任意文本都是字符串。 2）运算符：&amp;&amp;运算，||运算，!运算，比较运算符。基本上都差不多，但是要注意的是相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 通常的话我们是坚持使用===。 另外是NaN这个特殊的Number，它和其他所有的值都不相等，包括本身。唯一能判断NaN的方法是通过isNaN()函数。 3）变量的申明方式 变量名的要求：变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。 12345678910var age = 15;var arr = [1, 2, 3.14, 'Hello', null, true];//JavaScript的数组可以包括任意数据类型var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;;//申明JavaScript的对象，它是由键-值组成的无序集合，引用的话和Java差不多，用对象变量.属性名的方式 同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，注意在JavaScript中通过赋值可以修改变量的数据类型，JavaScript是一个动态的语言。像Java这种静态的语言就不能这样的进行赋值。 注意：不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。 字符串在前面我们看到字符串就是用&#39;&#39;或&quot;&quot;括起来的字符。跟c++一样有转义字符，具体的熟悉一下就行。 通过+来连接字符串。 通过s.length来获取字符的长度 通过下标索引获取字符串某个指定位置的字符，索引号从0开始，需要注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果，如下： 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写： indexOf()会搜索指定字符串出现的位置（字符串第一个出现该字符的位置） substring()返回指定索引区间的子串 split()把字符串转换为数组 1234var txt = "a,b,c,d,e"; // 字符串txt.split(","); // 用逗号分隔txt.split(" "); // 用空格分隔txt.split("|"); // 用竖线分隔 数组和对象通过arr.length获取数组长度，直接给Array的length赋一个新的值会导致Array大小的变化如： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] 和字符串不同，数组可以通过下表索引修改对应的元素值。但是要是索引超过范围的话同样会导致数组大小的变化。 通过indexOf()来搜索一个指定的元素的位置（同字符串第一个出现该字符的位置） slice()截取Array的部分元素，然后返回一个新的Array push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉 往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉 sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置 reverse()把整个Array反转 splice()方法可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素 concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array，并不是修改当前的数组。 join()方法能把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。 练习：在新生欢迎会上，你已经拿到了新同学的名单，请排序后显示：欢迎XXX，XXX，XXX和XXX同学！： 1234'use strict';var arr = ['小明', '小红', '大军', '阿黄'];arr.sort();console.log(`欢迎$&#123;arr[0]&#125;,$&#123;arr[1]&#125;,$&#123;arr[2]&#125;和$&#123;arr[3]&#125;同学!`); JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,可以通过delete删除属性，赋值增加属性如： 1234567891011var xiaoming = &#123; name: '小明', score: null&#125;;xiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 利用in操作符检测是否拥有一个属性，但是注意所有对象最终都会在原型链上指向object，所以我们定义的对象都有object对象的属性，所以要判断一个属性是否是我们定义的对象拥有的，而不是继承得到的，可以用hasOwnProperty()方法 容器和一些控制语句条件判断if...else，这些都差不多，就是逻辑的判断。 练习：小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖 用if...else...判断并显示结果： 12345678910111213141516'use strict';var height = parseFloat(prompt('请输入身高(m):'));var weight = parseFloat(prompt('请输入体重(kg):'));var bmi=weight/height/height;if (bmi &lt; 18.5) &#123; console.log('过轻');&#125; else if (bmi &lt;= 25) &#123; console.log('正常');&#125; else if (bmi &lt; 28) &#123; console.log('过重');&#125; else if (bmi &lt; 32) &#123; console.log('肥胖');&#125; else &#123; console.log('严重肥胖');&#125; 循环也是一样利用for或者while或者do...while 练习: 利用for循环计算1 * 2 * 3 * ... * 10的结果： 123456789101112'use strict';var x = 1;var i;for (i=1;i&lt;=10;i++)&#123; x*=i;&#125;if (x === 3628800) &#123; console.log('1 x 2 x 3 x ... x 10 = ' + x);&#125;else &#123; console.log('计算错误');&#125; 请利用循环遍历数组中的每个名字，并显示Hello, xxx!： 12345678910111213'use strict';var arr = ['Bart', 'Lisa', 'Adam'];arr.sort(); // 正序//倒序arr.reverse();for(var i=0;i&lt;arr.length;i++)&#123; console.log(`Hello,$&#123;arr[i]&#125;`);&#125;var i=0;while(i&lt;arr.length)&#123; console.log(`Hello,$&#123;arr[i]&#125;`); i++;&#125; Map和Set容器 Map是一组键值对的结构，利用key和value。常用的函数有set，delete，get。用法都差不多。 set一组key的集合且不重复，常用的函数有delete，add。 iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for ... of循环来遍历。因为遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。如： 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 或者通过forEach()方法循环，forEach()有三个参数 1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，可以忽略。 Js 函数函数函数定义如下： 123456789101112131415function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;//或者另一种var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;;//注意这比上面多一个等号 JavaScript在调用参数的时候允许任意个参数调用，不管传多还是传少都不会报错。因此JavaScript提供了一个关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array，利用它可以判断传入参数的个数。 之后JavaScript又引入了rest参数，rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。如 1234567891011121314151617function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] 练习： 请用rest参数编写一个sum()函数，接收任意个参数并返回它们的和： 1234567891011121314151617181920212223242526'use strict';function sum(...rest) &#123; var arr = []; arr = rest; //获取所有的参数，以数组显示保存在arr数组中 var result = 0; for(var i = 0; i &lt; arr.length; i++)&#123; result = result + arr[i]; &#125; return result;&#125; // 测试:var i, args = [];for (i=1; i&lt;=100; i++) &#123; args.push(i);&#125;if (sum() !== 0) &#123; console.log('测试失败: sum() = ' + sum());&#125; else if (sum(1) !== 1) &#123; console.log('测试失败: sum(1) = ' + sum(1));&#125; else if (sum(2, 3) !== 5) &#123; console.log('测试失败: sum(2, 3) = ' + sum(2, 3));&#125; else if (sum.apply(null, args) !== 5050) &#123; console.log('测试失败: sum(1, 2, 3, ..., 100) = ' + sum.apply(null, args));&#125; else &#123; console.log('测试通过!');&#125; 定义一个计算圆面积的函数area_of_circle()，它有两个参数： r: 表示圆的半径； pi: 表示π的值，如果不传，则默认3.14 12345678910111213141516171819202122'use strict';function area_of_circle(r, pi) &#123; var area; if (arguments.length == 2) &#123; area = pi * r * r; &#125; else if (arguments.length &lt; 2)&#123; pi = 3.14; area = pi * r * r; &#125; else&#123; console.log("arguments number must be 1 or 2."); return ; &#125; return r * r * (pi || 3.14);&#125;// 测试:if (area_of_circle(2) === 12.56 &amp;&amp; area_of_circle(2, 3.1416) === 12.5664) &#123; console.log('测试通过');&#125; else &#123; console.log('测试失败');&#125; 函数变量作用域以及解析赋值在JavaScript中，用var申明的变量实际上是有作用域的。一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量，但是由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量。但是如果内部函数和外部函数的变量名重名的情况下在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。看样例： 1234567891011121314function foo() &#123; var x = 1; function bar() &#123; var x = 'A'; console.log('x in bar() = ' + x); // 'A' &#125; console.log('x in foo() = ' + x); // 1 bar();&#125;foo();/*结果为x in foo() = 1x in bar() = A*/ 而且JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部，也就是所有的变量都会在函数初步就定义了。 同时JavaScript默认有一个全局对象window，不在任何函数内定义的变量就具有全局作用域，全局作用域的变量实际上被绑定到window的一个属性。我们在之前说过函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象，其实我们每次直接调用的alert()函数其实也是window的一个变量。 所以JavaScript中任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。 因此在这个基础上，个人感觉引用了c++的using namespace std命名空间的概念，在JavaScript中有一个名字空间，因为全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，就会造成命名冲突，解决的方式就是把自己的所有变量和函数绑定到一个全局变量里面会减少全局变量冲突的几率。 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 解构赋值：在ES6后引入了这个解构赋值，直接对于多个变量同时赋值如： 1234567var [x, y, z] = ['hello', 'JavaScript', 'ES6'];// x, y, z分别被赋值为数组对应元素:console.log('x = ' + x + ', y = ' + y + ', z = ' + z);/*结果为x = hello, y = JavaScript, z = ES6*/根据数组的格式进行嵌套赋值，但是要注意嵌套层次和位置要保持一致 同理解构赋值也能对对象进行同样的操作如： 12345678910111213141516171819var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: &#123; city: 'Beijing', street: 'No.1 Road', zipcode: '100001' &#125;&#125;;var &#123;name, address: &#123;city, zip&#125;&#125; = person;name; // '小明'city; // 'Beijing'zip; // undefined, 因为属性名是zipcode而不是zip// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:address; // Uncaught ReferenceError: address is not defined//当然可以赋默认值避免了不存在的属性返回undefined的问题 方法和高阶函数在一个对象中绑定函数，那么就成为这个对象的方法，如 1234567891011var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 在函数内部this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性，但是我们要注意this这个指向，最好是在引用函数之前就把这个this给记录下来如that，然后在方法内定义其他的函数，用that去代替this；或者呢用aplpy函数去修复，apply它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。同样有个call函数。 一个很重要的点高阶函数： 什么叫高阶函数？高阶函数指最少满足下列条件之一的函数：函数可以作为参数传递，函数可以作为返回值输出。（理解的不够，再细致的理解再补） map/reduce函数：它们都是Array中定义的，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果，比方说我要得到一个数组中每个数的平方： 12345678'use strict';function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); //map()传入的参数是pow(),是函数本身console.log(results);// [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce函数的话是把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，实际能做的事情是对一个数组进行重复的处理，比方说求和，求积，如： 1234567891011121314’use strict';function product(arr) &#123; var ans=arr.reduce(function(x,y)&#123; return x*y; &#125;); return ans;&#125;// 测试:if (product([1, 2, 3, 4]) === 24 &amp;&amp; product([0, 1, 2]) === 0 &amp;&amp; product([99, 88, 77, 66]) === 44274384) &#123; console.log('测试通过!');&#125;else &#123; console.log('测试失败!');&#125; 把[1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场： 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x * 10 + y;&#125;); // 13579 练习： 不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数： 1234567891011121314151617181920212223'use strict';function string2int(s) &#123; var arr= []; for(let i=0;i&lt;s.length;i++) arr[i]=s[i]-'0'; var ans=arr.reduce(function (x, y) &#123; return x * 10 + y; &#125;); return ans;&#125;// 测试:if (string2int('0') === 0 &amp;&amp; string2int('12345') === 12345 &amp;&amp; string2int('12300') === 12300) &#123; if (string2int.toString().indexOf('parseInt') !== -1) &#123; console.log('请勿使用parseInt()!'); &#125; else if (string2int.toString().indexOf('Number') !== -1) &#123; console.log('请勿使用Number()!'); &#125; else &#123; console.log('测试通过!'); &#125;&#125;else &#123; console.log('测试失败!');&#125; 请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]，输出：[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]。 1234567891011121314'use strict';function normalize(arr) &#123; return arr.map(function(x) &#123; return x[0].toUpperCase() + x.substring(1).toLowerCase() &#125;);&#125;// 测试:if (normalize(['adam', 'LISA', 'barT']).toString() === ['Adam', 'Lisa', 'Bart'].toString()) &#123; console.log('测试通过!');&#125;else &#123; console.log('测试失败!');&#125; 小明希望利用map()把字符串变成整数，他写的代码很简洁： 123456'use strict';var arr = ['1', '2', '3'];var r;r = arr.map(parseInt);console.log(r);结果竟然是1, NaN, NaN，小明百思不得其解，请帮他找到原因并修正代码。 这个主要是parseInt的一些误区，后序会写篇来介绍这个，先暂时性看这个理解一下https://blog.csdn.net/wjl84945979/article/details/56478927 filter函数filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。类似一个筛选的功能，例如：在一个Array中，删掉偶数，只保留奇数 12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (element, index, self) &#123; return element% 2 !== 0;&#125;);r; // [1, 5, 9, 15] 看上面的调用filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身。 练习： 请尝试用filter()筛选出素数： 1234567891011121314151617181920212223242526272829303132333435'use strict';function get_primes(arr) &#123; var ans=arr.filter(function (element,index,self) &#123; if(element&lt;2 ) return false; else&#123; var flag=false; for(let i=2;i&lt;element;i++)&#123; if(element%i===0)&#123; flag=true; break; &#125; &#125; if(flag) return false; else return true; &#125; &#125;); return ans;&#125;// 测试:var x, r, arr = [];for (x = 1; x &lt; 100; x++) &#123; arr.push(x);&#125;r = get_primes(arr);if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) &#123; console.log('测试通过!');&#125; else &#123; console.log('测试失败: ' + r.toString());&#125;]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
</search>
